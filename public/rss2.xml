<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>WildRage&#39;s Blog</title>
    <link>https://blog.wildrage.xyz/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>WildRage 的博客 爱这个世界</description>
    <pubDate>Tue, 06 Mar 2018 01:40:06 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>BZOJ1004 [HNOI2008] Cards</title>
      <link>https://blog.wildrage.xyz/2018/03/05/133/</link>
      <guid>https://blog.wildrage.xyz/2018/03/05/133/</guid>
      <pubDate>Mon, 05 Mar 2018 13:13:22 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;小春现在很清闲,面对书桌上的N张牌,他决定给每张染色,目前小春只有$
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>小春现在很清闲,面对书桌上的N张牌,他决定给每张染色,目前小春只有$3$种颜色:红色,蓝色,绿色.他询问 Sun 有多少种染色方案, Sun 很快就给出了答案.进一步,小春要求染出$Sr$张红色,$Sb$张蓝色,$Sg$张绝色.他又询问有多少种方案, Sun 想了一下,又给出了正确答案. 最后小春发明了$M$种不同的洗牌法,这里他又问 Sun 有多少种不同的染色方案.两种染色方法相同当且仅当其中一种可以通过任意的洗牌法(即可以使用多种洗牌法,而每种方法可以使用多次)洗成另一种. Sun 发现这个问题有点难度,决定交给你,答案可能很大,只要求出答案除以$P$的余数($P$为质数).  </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行输入 $5$ 个整数：$Sr,Sb,Sg,m,p(m&lt;=60,m+1&lt;p&lt;100)$。$n=Sr+Sb+Sg$。<br>接下来 $m$ 行，每行描述一种洗牌法，每行有 n 个用格隔开的整数 $X_1 X_2…X_n$，恰为 $1$ 到 $n$ 的一个排列，表示使用这种洗牌法，第 $i$ 位变为原来的 $X_i$ 位的牌。输入数据保证任意多次洗牌都可用这 $m$ 种洗牌法中的一种代替，且对每种洗牌法，都存在一种洗牌法使得能回到原状态。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>不同染法除以$P$的余数</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>1 1 1 2 72 3 13 1 2</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>2</code></pre><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>有 $2$ 种本质上不同的染色法 $RGB$ 和 $RBG$，使用洗牌法 $231$ 一次可得 $GBR$ 和 $BGR$ ，使用洗牌法 $312$ 一次可得 $BRG$ 和 $GRB$。<br>$100\%$ 数据满足 $Max{Sr,Sb,Sg}&lt;=20$。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>一道比较基础的$Burnside$题目<br>这里先介绍一下$Burnside$定理<br>设$D(a_j)$为在置换$a_j$下不变的元素的个数。 $L$表示本质不同的方案数<br>则$$L = \frac{1}{|G|}\sum_{j = 1}^{|G|}{D(a_j)}$$</p><p>在本题中<br>我们群的大小为$m+1$<br>对于每一个置换，我们都可以求出它不变的元素个数<br>首先求出所有的环， 因为我们的环上必须是同一种颜色才能使他这个元素在置换下不变(这里把涂色方案看做是一个元素)<br>我们求出所有环之后就可以$DP$出方案的个数  </p><p>!要注意如果要使所有的洗牌法构成一个群，我们必须有一个单位元， 也就是存在一个置换使得任意一个置换与他运算完不变<br>在本题中显然是一下$i-&gt;i$的的置换， 但这个置换不是读入的， 而是要自己加上去的。  </p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;inline int read(){    int x=0,f=1;char ch=getchar();    while (ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while (ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}    return x*f;}int MOD; const int MAXN = 65;int a[MAXN];long long pow_mod(long long a, int b){    long long ans = 1;    while (b)    {        if (b &amp; 1) ans = ans * a % MOD;        b &gt;&gt;= 1;        a = a * a % MOD;    }    return ans;}int vis[MAXN], st[MAXN];int dfs(int x, int C){    if (vis[x] == C) return 0;    vis[x] = C;    return dfs(a[x], C) + 1;}int DP[2][25][25][25];int main(){    int Sr = read(), Sb = read(), Sg = read(), m = read();    MOD = read();    int n = Sr + Sb + Sg;    int Ans = 0;    memset (vis, -1, sizeof (vis));    for (int i = 0; i &lt;= m; i++)    {        for (int j = 1; j &lt;= n; j++)            a[j] = (i == 0 ? (j) : read());        int cnt = 0;        for (int j = 1; j &lt;= n; j++)            if (vis[j] != i)                st[++cnt] = dfs(j, i);        memset (DP, 0, sizeof (DP));        DP[0][Sr][Sb][Sg] = 1;        int now = 0;        for (int j = 1; j &lt;= cnt; j++)        {            now ^= 1;            memset(DP[now], 0, sizeof (DP[now]));            for (int r = 0; r &lt;= Sr; r++)                for (int b = 0; b &lt;= Sb; b++)                    for (int g = 0; g &lt;= Sg; g++)                    {                        if (r + st[j] &lt;= Sr) DP[now][r][b][g] = (DP[now][r][b][g] + DP[now ^ 1][r + st[j]][b][g]) % MOD;                        if (b + st[j] &lt;= Sb) DP[now][r][b][g] = (DP[now][r][b][g] + DP[now ^ 1][r][b + st[j]][g]) % MOD;                        if (g + st[j] &lt;= Sg) DP[now][r][b][g] = (DP[now][r][b][g] + DP[now ^ 1][r][b][g + st[j]]) % MOD;                    }        }        Ans = (DP[now][0][0][0] + Ans) % MOD;    }    printf (&quot;%d\n&quot;, 1ll * Ans * pow_mod(m + 1, MOD - 2) % MOD);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2018/03/05/133/#disqus_thread</comments>
    </item>
    
    <item>
      <title>UOJ182 【UR #12】a^-1 + b problem</title>
      <link>https://blog.wildrage.xyz/2018/02/28/132/</link>
      <guid>https://blog.wildrage.xyz/2018/02/28/132/</guid>
      <pubDate>Wed, 28 Feb 2018 22:08:11 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;在你的帮助下，跳蚤国王终于打开了最后一间房间的大门。然而，picks 博士和他的猴子们早已通过地道逃跑了。万幸的是，因为阿姆斯特朗回旋加速喷气式阿姆斯特朗炮本身太过笨重，无法从地道中运走，所以还被静静的停放在房间的正中央。&lt;br&gt;拥有了征服世界的力量，跳蚤国王感觉非常一颗赛
        
      
      </description>
      
      <content:encoded><![CDATA[<p>在你的帮助下，跳蚤国王终于打开了最后一间房间的大门。然而，picks 博士和他的猴子们早已通过地道逃跑了。万幸的是，因为阿姆斯特朗回旋加速喷气式阿姆斯特朗炮本身太过笨重，无法从地道中运走，所以还被静静的停放在房间的正中央。<br>拥有了征服世界的力量，跳蚤国王感觉非常一颗赛艇。为了试验这个传说中的武器的威力，跳蚤国王让士兵们把炮口对准空无一人的实验室开炮。<br>然而，事情总是没有这么顺利。片刻之后，一个士兵匆匆跑到跳蚤国王身前：“报！picks 博士给它设置了保险！但是我们根本不知道解除方法！”<br>经过研究，跳蚤国王发现，picks 博士所设置的保险措施可以简化为这样一个问题：<br>首先炮身的屏幕上显示了 $n$ 个数，接着在模 $998244353(7\times 17 \times 2^{23}+1$，一个质数) 意义下，给出了 $m$ 条指令，每一条指令都是下列两种之一：  </p><ol><li>给<strong>所有</strong>数加上某一个数。  </li><li>让<strong>所有</strong>数都变成原来的逆元。（保证这时所有数的逆元都存在）  </li></ol><p>在每个指令完成之后，你要回答当前屏幕上<strong>所有</strong>数的和。<br>跳蚤国王思索了片刻，发现这个问题奥妙重重，于是他让你——这附近最著名的民间科学家来帮他解决这个难题。   </p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行两个正整数 $n,m$，含义如题意所述。  </p><p>第二行$n$个数，表示屏幕上最初显示的 $n$ 个数。  </p><p>接下来$m$行，表示 $m$ 条指令，第 $i$ 行第一个数$t_i$表示第 $i$ 个操作的类型。  </p><p>若 $t_i=1$ 则接下来有一个整数 $x_i$，表示给所有数都加上 $x_i$。  </p><p>若 $t_i=2$ 则表示将所有数都变成原来的逆元。  </p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出$m$行，第$i$行一个整数表示第$i$条指令之后当前屏幕上每个数的和。  </p><h3 id="样例一"><a href="#样例一" class="headerlink" title="样例一"></a>样例一</h3><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><pre><code>5 51 2 3 4 51 121 122</code></pre><h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><pre><code>20349385525349385530292342993349385530</code></pre><p>explanation</p><h4 id="执行每个指令后的数列分别如下："><a href="#执行每个指令后的数列分别如下：" class="headerlink" title="执行每个指令后的数列分别如下："></a>执行每个指令后的数列分别如下：</h4><p>2 3 4 5 6<br>499122177 332748118 748683265 598946612 166374059<br>499122178 332748119 748683266 598946613 166374060<br>665496236 249561089 399297742 831870295 142606337<br>499122178 332748119 748683266 598946613 166374060  </p><h3 id="限制与约定"><a href="#限制与约定" class="headerlink" title="限制与约定"></a>限制与约定</h3><table class="table table-bordered table-text-center table-vertical-middle"><thead><tr><th>测试点编号</th><th>限制与约定</th></tr></thead><tbody><tr><td>1</td><td rowspan="1">$n, m \leq 1000$</td></tr><tr><td>2</td><td rowspan="1">$n \leq 100000$, $m \leq 60000$, $t_i = 1$</td></tr><tr><td>3</td><td rowspan="1">$n, m \leq 10000$</td></tr><tr><td>4</td><td rowspan="1">$n, m \leq 20000$</td></tr><tr><td>5</td><td rowspan="1">$n, m \leq 30000$</td></tr><tr><td>6</td><td rowspan="2">$n \leq 100000$, $m \leq 30000$</td></tr><tr><td>7</td></tr><tr><td>8</td><td rowspan="3">$n \leq 100000$, $m \leq 60000$</td></tr><tr><td>9</td></tr><tr><td>10</td></tr></tbody></table><p>对于所有数据$1 \le n \le 100000$，$1 \le m \le 60000$, $t_i \in {1, 2}$其他所有数均为区间中的整数。</p><p>保证任何时候每个数的逆元均存在。</p><p>时间限制：$4s$<br>空间限制：$256MB$</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>出门左拐<a href="http://jiry-2.blog.uoj.ac/blog/1375" target="_blank" rel="noopener">UOJ</a>;<br>那一毫秒的距离<br><img src="https://i.loli.net/2018/02/28/5a96b2464c28b.png" alt="PNG"></p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e6 * 4;const int MOD  = 998244353;const int L = (1 &lt;&lt; 18) + 1;const int LM = (1 &lt;&lt; 16) + 1;inline int read(){    int x=0,f=1;char ch=getchar();    while (ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while (ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}    return x*f;}int N, Inv, rev[MAXN];int Sum = 0, n, m;struct data{    int e, f, g, id;}s[60005];long long pow_mod(long long a, int b){    long long ans = 1;    while (b)    {        if (b &amp; 1)            ans = ans * a % MOD;        b &gt;&gt;= 1;        a = a * a % MOD;    }    return ans;}int ans[MAXN], cnt;void insert(int a, int b, int c, int d, int id){    if (b == 0)    {        ans[id] = ((1ll * a * Sum) + (1ll * c * n)) % MOD * pow_mod(d, MOD - 2) % MOD;        return;    }    s[++cnt].f = (1ll * b * c - 1ll * a * d) % MOD;    b = pow_mod(b, MOD - 2);    s[cnt].e = 1ll * a * b % MOD, s[cnt].g = 1ll * d * b % MOD;    b = 1ll * b * b % MOD; s[cnt].f = 1ll * s[cnt].f * b % MOD;    if (s[cnt].f &lt; 0) s[cnt].f += MOD;    s[cnt].id = id;}void Init(int x){    N = 1;    while (N &lt; (x &lt;&lt; 1)) N &lt;&lt;= 1;    Inv = pow_mod(N, MOD - 2);    for (int i = 1; i &lt; N; i++)        if (i &amp; 1)            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | (N &gt;&gt; 1);        else            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1);}inline int Calc(int x){    N = 1;    while (N &lt; (x &lt;&lt; 1)) N &lt;&lt;= 1;    return N;}void FFt(int *a, int op){    int w, wn, t;    for (int i = 0; i &lt; N; i++)        if (i &lt; rev[i])            swap(a[i], a[rev[i]]);    for (int k = 2; k &lt;= N; k &lt;&lt;= 1)    {        wn = pow_mod(3, op == 1 ? (MOD - 1) / k : MOD - 1 - (MOD - 1) / k);        for (int j = 0; j &lt; N; j += k)        {            w = 1;            for (int i = 0; i &lt; (k &gt;&gt; 1); i++, w = 1ll * w * wn % MOD)            {                t = 1ll * a[i + j + (k &gt;&gt; 1)] * w % MOD;                a[i + j + (k &gt;&gt; 1)] = (a[i + j] - t + MOD) % MOD;                a[i + j] = (a[i + j] + t) % MOD;            }        }    }    if (op == -1)        for (int i = 0; i &lt; N; i++)            a[i] = 1ll * a[i] * Inv % MOD;}int tmp[MAXN], x[MAXN];void Get_Inv(int *a, int *b, int n){    if (n == 1) return b[0] = pow_mod(a[0], MOD - 2), void();    Get_Inv(a, b, n + 1 &gt;&gt; 1);    Init(n);    for (int i = 0; i &lt; n; i++) tmp[i] = a[i];    for (int i = n; i &lt; N; i++) tmp[i] = 0;    FFt(tmp, 1), FFt(b, 1);    for (int i = 0; i &lt; N; i++)         b[i] = 1ll * b[i] * ((2 - 1ll * b[i] * tmp[i] % MOD + MOD) % MOD) % MOD;    FFt(b, -1);    for (int i = n; i &lt; N; i++) b[i] = 0;}int Get_mod(int *a, int ra, int *b, int rb, int *c){    while (ra &amp;&amp; !a[ra - 1]) --ra;    while (rb &amp;&amp; !b[rb - 1]) --rb;    if (ra &lt; rb)    {        memcpy (c, a, ra &lt;&lt; 2);        memset (c + ra, 0, (rb - ra) &lt;&lt; 2);        return rb;    }    static int tmp1[MAXN], tmp2[MAXN];    int rc = ra - rb + 1;    int l = Calc(rc);    for (int i = 0; i &lt; l; i++) tmp1[i] = 0;    reverse_copy(b, b + rb, tmp1);    for (int i = 0; i &lt; l; i++) tmp2[i] = 0;    // for (int i = 0; i &lt; rb; i++) printf (&quot;1: %d, tmp1: %d\n&quot;, rb, tmp1[i]);        Get_Inv(tmp1, tmp2, rc);    for (int i = rc; i &lt; l; i++) tmp2[i] = 0;    reverse_copy(a, a + ra, tmp1);    for (int i = rc; i &lt; l; i++) tmp1[i] = 0;    Init(rc), FFt(tmp1, 1), FFt(tmp2, 1);    for (int i = 0; i &lt; N; i++) tmp1[i] = 1ll * tmp1[i] * tmp2[i] % MOD;    FFt(tmp1, -1);    // for (int i = 0; i &lt; rb; i++) printf (&quot;2: %d, tmp1: %d\n&quot;, rb, tmp1[i]);        reverse(tmp1, tmp1 + rc);    // for (int i = 0; i &lt; rb; i++) printf (&quot;3: %d, tmp1: %d\n&quot;, rb, tmp1[i]);        Init(ra);    for (int i = 0; i &lt; rb; i++) tmp2[i] = b[i];    for (int i = rb; i &lt; N; i++) tmp2[i] = 0;    for (int i = rc; i &lt; N; i++) tmp1[i] = 0;    FFt(tmp1, 1), FFt(tmp2, 1);    for (int i = 0; i &lt; N; i++) tmp1[i] = 1ll * tmp1[i] * tmp2[i] % MOD;    FFt(tmp1, -1);    // for (int i = 0; i &lt; rb; i++) printf (&quot;4: %d, tmp1: %d\n&quot;, rb, tmp1[i]);    for (int i = 0; i &lt; rb; i++) c[i] = (a[i] - tmp1[i] + MOD) % MOD;    for (int i = rb; i &lt; N; i++) c[i] = 0;    // for (int i = 0; i &lt; rb; i++) printf (&quot;C: %d, %d\n&quot;, rb, c[i]);    while (rb &amp;&amp; !c[rb - 1]) --rb;    return rb;}int Solve0(int *a, int l, int r){    int ra = r - l + 2;    if (ra &lt;= 256)    {        memset(a, 0, ra &lt;&lt; 2), a[0] = 1;        for (int i = l; i &lt;= r; i++)            for (int v = x[i], j = i - l; j != -1; j--)            {                a[j + 1] = (a[j + 1] + a[j]) % MOD;                a[j] = 1ll * a[j] * v % MOD;            }        return ra;    }    int mid = l + r &gt;&gt; 1;    int *f1 = a, r1 = Solve0(f1, l, mid);    int *f2 = a + r1, r2 = Solve0(f2, mid + 1, r);    N = 1;    while (N &lt; ra) N &lt;&lt;= 1;    Inv = pow_mod(N, MOD - 2);    for (int i = 1; i &lt; N; i++)        if (i &amp; 1)            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | (N &gt;&gt; 1);        else            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1);    static int tmp1[L], tmp2[L];    memcpy(tmp1, f1, r1 &lt;&lt; 2), memset (tmp1 + r1, 0, (N - r1) &lt;&lt; 2), FFt(tmp1, 1);    memcpy(tmp2, f2, r2 &lt;&lt; 2), memset (tmp2 + r2, 0, (N - r2) &lt;&lt; 2), FFt(tmp2, 1);    for (int i = 0; i &lt; N; i++) a[i] = 1ll * tmp1[i] * tmp2[i] % MOD;    FFt(a, -1);    return ra;}int *p[L];int sta[MAXN];int mem[LM &lt;&lt; 4], *head = mem;inline int Solve1(int id, int l, int r){    int ra = r - l + 2;    if (ra &lt;= 256)    {        int *f = p[id] = head; head += ra;        memset (f, 0, ra &lt;&lt; 2), 0[f] = 1;        for (int i = l; i &lt;= r; i++)            for (int v = (MOD - sta[i]) % MOD, j = i - l; j != -1; j--)                f[j + 1] = (f[j + 1] + f[j]) % MOD, f[j] = 1ll * f[j] * v % MOD;        return ra;    }    int mid = l + r &gt;&gt; 1;    int r1 = Solve1(id &lt;&lt; 1, l, mid), *f1 = p[id &lt;&lt; 1];    int r2 = Solve1(id &lt;&lt; 1 | 1, mid + 1, r), *f2 = p[id &lt;&lt; 1 | 1];    N = 1;    while (N &lt; ra) N &lt;&lt;= 1;    Inv = pow_mod(N, MOD - 2);    for (int i = 1; i &lt; N; i++)        if (i &amp; 1)            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | (N &gt;&gt; 1);        else            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1);    static int tmp1[LM], tmp2[LM];    memcpy(tmp1, f1, r1 &lt;&lt; 2), memset (tmp1 + r1, 0, (N - r1) &lt;&lt; 2), FFt(tmp1, 1);    memcpy(tmp2, f2, r2 &lt;&lt; 2), memset (tmp2 + r2, 0, (N - r2) &lt;&lt; 2), FFt(tmp2, 1);    int *f = p[id] = head; head += ra;    for (int i = 0; i &lt; N; i++) f[i] = 1ll * tmp1[i] * tmp2[i] % MOD;    FFt(f, -1);    return ra; }int val0[LM], val[LM];void Solve2(int id, int *a, int *b, int l, int r, int deg){    int ra = r - l + 2;    if (deg &lt;= 256)    {        int F, G;        for (int i = l; i &lt;= r; i++)        {            F = G = 0;            int u = sta[i], v = 1;            for (int j = 0; j &lt;= deg; j++)            {                F = (F + 1ll * v * a[j]) % MOD;                G = (G + 1ll * v * b[j]) % MOD;                v = 1ll * v * u % MOD;            }            val0[i] = F, val[i] = G;        }        return;    }    int mid = l + r &gt;&gt; 1;    int r1 = Get_mod(a, deg, p[id], ra, a + deg); a += deg;    int r2 = Get_mod(b, deg, p[id], ra, b + deg); b += deg;    ra = min(r1, r2);    Solve2(id &lt;&lt; 1, a, b, l, mid, ra), Solve2(id &lt;&lt; 1 | 1, a, b, mid + 1, r, ra);}int g[MAXN], h[MAXN];int main(){    // freopen (&quot;1.in&quot;, &quot;r&quot;, stdin);    // freopen (&quot;1.out&quot;, &quot;w&quot;, stdout);    n = read(), m = read();    Sum = 0;    for (int i = 1; i &lt;= n; i++)        x[i] = read() % MOD, Sum = (Sum + x[i]) % MOD;    int A = 1, B = 0, C = 0, D = 1;    for (int i = 1; i &lt;= m; i++)    {        if (read() == 1)        {            int v = read() % MOD;            A = (A + 1ll * v * B % MOD) % MOD;            C = (C + 1ll * v * D % MOD) % MOD;            insert(A, B, C, D, i);        }        else        {            swap(A, B);            swap(C, D);            insert(A, B, C, D, i);        }    }    if (cnt)    {        for (int i = 1; i &lt;= cnt; i++) sta[i] = s[i].g;        sort(sta + 1, sta + cnt + 1);        int lenth = unique(sta + 1, sta + cnt + 1) - sta - 1;        for (int i = 1; i &lt;= cnt; i++)            s[i].g = lower_bound(sta + 1, sta + lenth + 1, s[i].g) - sta;        Solve0(g, 1, n);        for (int i = 1; i &lt;= n; i++) h[i - 1] = 1ll * g[i] * i % MOD;        Solve1(1, 1, lenth);        Solve2(1, g, h, 1, lenth, n + 1);        for (int i = 1; i &lt;= cnt; i++)            ans[s[i].id] = (1ll * s[i].e * n % MOD + 1ll * s[i].f * val[s[i].g] % MOD * pow_mod(val0[s[i].g], MOD - 2) % MOD) % MOD;    }    for (int i = 1; i &lt;= m; i++)        printf (&quot;%d\n&quot;, ans[i]);    // while (1);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2018/02/28/132/#disqus_thread</comments>
    </item>
    
    <item>
      <title>UOJ50 【UR #3】链式反应</title>
      <link>https://blog.wildrage.xyz/2018/02/28/131/</link>
      <guid>https://blog.wildrage.xyz/2018/02/28/131/</guid>
      <pubDate>Wed, 28 Feb 2018 11:04:10 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;著名核物理专家 Picks 最近发现了一种非常适合核裂变的元素叫囧元素。囧元素原子序数为 1024，囧-2333 如果被一个中子撞击后会分裂成 蒟-1234 和 蒻-1098 同时&lt;strong&gt;释放出恰好 $2$ 个中子&lt;/strong&gt;，并且&lt;strong&gt;以破坏死光的
        
      
      </description>
      
      <content:encoded><![CDATA[<p>著名核物理专家 Picks 最近发现了一种非常适合核裂变的元素叫囧元素。囧元素原子序数为 1024，囧-2333 如果被一个中子撞击后会分裂成 蒟-1234 和 蒻-1098 同时<strong>释放出恰好 $2$ 个中子</strong>，并且<strong>以破坏死光的方式释放光子</strong>。</p><br><p>核物理专家 Picks 做实验从来不用实验仪器。他用手指从宇宙中挑选出了 $n$ 个 囧-2333 原子并编号为 $1$ 到 $n$，并用帅气的眼神发射中子撞击了编号为 $1$ 的囧原子，启动了链式反应。</p><br><p>当一个囧-2333原子被中子撞击时，有两种情况。要么这个囧-2333原子变为了囧-2334 并不再参与后续反应，要么囧-2333会进行核裂变，一方面，裂变产生的破坏死光会<strong>照射到 $c$ 个不同的囧-2333原子</strong>并且这些原子会极为神奇地分解为氢和氦的混合物并不再参与后续反应。另一方面，裂变后产生的 $2$ 个中子会<strong>分别撞上两个不同的囧-2333原子</strong>。显然被破坏死光照射后就不是囧-2333了，所以不可能又被中子撞上又被破坏死光照射到。</p><br><p>经过反复实验，核物理专家 Picks 终于确定了 $c$ 的范围 $A$，其中 $A$ 是一个非负整数集合。每次破坏死光会照射并影响到的囧-2333原子数量 $c$ 满足 $c \in A$ 。</p><br><p>链式反应时 Picks 会用肉眼观察实验中出现的事件（仅包括中子的撞击和破坏死光的信息），结束后 Picks 会写下实验记录。</p><br><p>但是很不幸 Picks 的实验记录丢失了。他只记得链式反应后<strong>没有剩余的囧-2333原子</strong>，而且每次一个囧-2333原子核裂变时，中子总是撞击<strong>编号比它大的囧-2333原子</strong>，破坏死光也总是照射<strong>编号比它大的囧-2333原子</strong>。</p><br><p>求可能会有多少种不同的实验记录。你需要对于 $n = 1, \dots, n_{max}$ 输出答案。你只用输出答案对 $998244353$（$7 \times 17 \times 2^{23} + 1$，一个质数）取模后的值。</p><br><p>两个实验记录 $T_1$，$T_2$ 被认为是相同的当且仅当：</p><br><ol><li>“编号为 $v$ 的囧-2333分裂产生的中子撞上了编号为 $u$ 的囧-2333” 这个事件在 $T_1$ 中当且仅当这个事件在 $T_2$ 中。</li><br><li>“编号为 $v$ 的囧-2333分裂产生的破坏死光照射了编号为 $u$ 的囧-2333” 这个事件在 $T_1$ 中当且仅当这个事件在 $T_2$ 中。</li><br></ol><h3>输入格式</h3><br><p>第一行一个正整数 $n_{max}$。</p><br><p>第二行是一个长度为 $n_{max}$ 的01字符串。如果把字符从 $0$ 开始编号，那么第 $i$ 个字符为 $0$ 表示 $i$ 不在集合 $A$ 内，否则表示 $i$ 在集合 $A$ 内。</p><br><h3>输出格式</h3><br><p>$n_{max}$ 行，如果把行从 $1$ 开始编号，那么第 $i$ 行表示 $n = i$ 时该问题的答案。</p><br><h3>样例一</h3><br><h4>input</h4><br><br><code>510100</code><br><br>#### output<br><br><code>101010</code><br><br><br><h4>explanation</h4><br><p>$n = 1$ 时，只有一种实验记录。</p><br><p>$n = 2$ 时，没有可能的实验记录。</p><br><p>$n = 3$ 时，唯一可能的实验记录为：</p><br><ul><li>编号为 $1$ 的囧-2333分裂产生的中子撞上了编号为 $2$ 的囧-2333。</li><br><li>编号为 $1$ 的囧-2333分裂产生的中子撞上了编号为 $3$ 的囧-2333。</li><br></ul><p>$n = 4$ 时，没有可能的实验记录。</p><br><p>$n = 5$ 时，有十种可能的实验记录。第一种是：</p><br><ul><li>编号为 $1$ 的囧-2333分裂产生的中子撞上了编号为 $2$ 的囧-2333。</li><br><li>编号为 $1$ 的囧-2333分裂产生的中子撞上了编号为 $3$ 的囧-2333。</li><br><li>编号为 $2$ 的囧-2333分裂产生的中子撞上了编号为 $4$ 的囧-2333。</li><br><li>编号为 $2$ 的囧-2333分裂产生的中子撞上了编号为 $5$ 的囧-2333。</li><br></ul><p>第二种是：</p><br><ul><li>编号为 $1$ 的囧-2333分裂产生的中子撞上了编号为 $2$ 的囧-2333。</li><br><li>编号为 $1$ 的囧-2333分裂产生的中子撞上了编号为 $4$ 的囧-2333。</li><br><li>编号为 $2$ 的囧-2333分裂产生的中子撞上了编号为 $3$ 的囧-2333。</li><br><li>编号为 $2$ 的囧-2333分裂产生的中子撞上了编号为 $5$ 的囧-2333。</li><br></ul><p>第三种是：</p><br><ul><li>编号为 $1$ 的囧-2333分裂产生的中子撞上了编号为 $2$ 的囧-2333。</li><br><li>编号为 $1$ 的囧-2333分裂产生的中子撞上了编号为 $5$ 的囧-2333。</li><br><li>编号为 $2$ 的囧-2333分裂产生的中子撞上了编号为 $3$ 的囧-2333。</li><br><li>编号为 $2$ 的囧-2333分裂产生的中子撞上了编号为 $4$ 的囧-2333。</li><br></ul><p>第四种是：</p><br><ul><li>编号为 $1$ 的囧-2333分裂产生的中子撞上了编号为 $2$ 的囧-2333。</li><br><li>编号为 $1$ 的囧-2333分裂产生的中子撞上了编号为 $3$ 的囧-2333。</li><br><li>编号为 $3$ 的囧-2333分裂产生的中子撞上了编号为 $4$ 的囧-2333。</li><br><li>编号为 $3$ 的囧-2333分裂产生的中子撞上了编号为 $5$ 的囧-2333。</li><br></ul><p>第五种是：</p><br><ul><li>编号为 $1$ 的囧-2333分裂产生的中子撞上了编号为 $2$ 的囧-2333。</li><br><li>编号为 $1$ 的囧-2333分裂产生的中子撞上了编号为 $3$ 的囧-2333。</li><br><li>编号为 $1$ 的囧-2333分裂产生的破坏死光照射了编号为 $4$ 的囧-2333。</li><br><li>编号为 $1$ 的囧-2333分裂产生的破坏死光照射了编号为 $5$ 的囧-2333。</li><br></ul><p>第六种到第十种均与第五种类似。空白太小我就不演示了。</p><br><h3>样例二</h3><br><h4>input</h4><br><br><code>810000000</code><br><br><h4>output</h4><br><br><code>101040340</code><br><br><h3>样例三</h3><br><p>见样例数据下载</p><br><h3>样例四</h3><br><p>见样例数据下载</p><br><h3>限制与约定</h3><br><div class="table-responsive"><br><table class="table table-bordered table-text-center table-vertical-middle"><thead><tr><th>测试点编号</th><br><th>$n$</th><br></tr></thead><tbody><tr><td>1</td><td>$n \leq 8$</td></tr><tr><td>2</td><td>$n \leq 100$</td></tr><tr><td>3</td><td>$n \leq 100$</td></tr><tr><td>4</td><td>$n \leq 200$</td></tr><tr><td>5</td><td>$n \leq 5000$</td></tr><tr><td>6</td><td>$n \leq 5000$</td></tr><tr><td>7</td><td>$n \leq 50000$</td></tr><tr><td>8</td><td>$n \leq 50000$</td></tr><tr><td>9</td><td>$n \leq 70000$</td></tr><tr><td>10</td><td>$n \leq 200000$</td></tr></tbody></table></div><br><p><strong>时间限制：</strong>$4\texttt{s}$</p><br><p><strong>空间限制：</strong>$256\texttt{MB}$</p><br><h3>下载</h3><br><p><a href="/download.php?type=problem&amp;id=50">样例数据下载</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>设$f[i]$为$n$个节点的树的方案数$f[1] = 1$<br>我们设两个中子打中的子树大小为j,k<br>则答案为$f[n] = \sum_{j}\sum_{k}C_{n - 1}^{j}C_{n - 1 - j}^{k}*f[j]*f[k]$<br>然后DP有40分  </p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;# define int long long using namespace std;inline int read(){    int x=0,f=1;char ch=getchar();    while (ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while (ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}    return x*f;}const int MAXN = 1000;const int MOD = 998244353;char s[MAXN];int F[MAXN];int c[MAXN][MAXN];int Inv2 = 499122177;int DP(int x){    if (F[x] != -1) return F[x];    if (x == 1) return F[x] = 1;    else F[x] = 0;    for (int i = 1; i &lt;= x; i++)        for (int j = 1; j &lt;= x; j++)            if (x - 1 - i - j &gt;= 0 &amp;&amp; s[x - 1 - i - j])                (F[x] += 1ll * DP(i) * DP(j) % MOD * c[x - 1][i] % MOD * c[x - 1 - i][j] % MOD * Inv2 % MOD) %= MOD;    return F[x];}signed main(){    int n = read();    scanf (&quot;%s&quot;, s);    for (int i = 0; i &lt; n; i++) s[i] -= &#39;0&#39;;    c[0][0] = 1;    for (int i = 1; i &lt;= n; i++)    {        c[i][0] = 1;        for (int j = 1; j &lt;= n; j++)            c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;    }    memset (F, -1, sizeof (F));    for (int i = 1; i &lt;= n; i++)         printf (&quot;%d\n&quot;, DP(i));    return 0;}</code></pre><p>建立生成函数<br>设$f(x)$为答案的生成函数<br>设$g(x)$为限制条件的生成函数<br>则$f’(x)=\frac{1}{2}f^{2}(x)g(x)+1$<br>可以CDQ+FFT用$0 \cdots n-1$的$f$来更新$f(n)$<br>时间复杂度$O(n\log^{2}{n})$</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;inline int read(){    int x=0,f=1;char ch=getchar();    while (ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while (ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}    return x*f;}const int MAXN = 200005 * 4;const int MOD = 998244353;long long pow_mod(long long a, int b){    long long ans = 1;    while (b)    {        if (b &amp; 1) ans = ans * a % MOD;        b &gt;&gt;= 1;        a = a * a % MOD;    }    return ans;}char s[MAXN];int F[MAXN], FInv[MAXN];int g[MAXN], f[MAXN], h[MAXN];int N, Inv;int rev[MAXN];int tmp1[MAXN], tmp2[MAXN];int Init(int x){    N = 1;    while (N &lt; (x &lt;&lt; 1)) N &lt;&lt;= 1;    for (int i = 1; i &lt; N; i++)        if (i &amp; 1)            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | (N &gt;&gt; 1);        else            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1);    Inv = pow_mod(N, MOD - 2);}void FFt(int *a, int op){    int w, wn, t;    for (int i = 1; i &lt; N; i++)        if (i &lt; rev[i])            swap(a[i], a[rev[i]]);    for (int k = 2; k &lt;= N; k &lt;&lt;= 1)    {        wn = pow_mod(3, op == 1 ? (MOD - 1) / k : MOD - 1 - (MOD - 1) / k);        for (int j = 0; j &lt; N; j += k)        {            w = 1;            for (int i = 0; i &lt; (k &gt;&gt; 1); i++, w = 1ll * w * wn % MOD)            {                t = 1ll * a[i + j + (k &gt;&gt; 1)] * w % MOD;                a[i + j + (k &gt;&gt; 1)] = (a[i + j] - t + MOD) % MOD;                a[i + j] = (a[i + j] + t) % MOD;            }        }    }    if (op == -1)        for (int i = 0; i &lt; N; i++)            a[i] = 1ll * a[i] * Inv % MOD;}void Solve(int l, int r){    if (l == r) return;    int mid = l + r &gt;&gt; 1;    Solve(l, mid);    Init(r - l + 1);    memset (tmp1, 0, N &lt;&lt; 2);    memset (tmp2, 0, N &lt;&lt; 2);    for (int i = l; i &lt;= mid; i++) tmp1[i - l] = f[i];    for (int i = 0; i &lt;= r - l; i++)        if (i &lt; l) tmp2[i] = 2 * f[i] % MOD;        else if (i &lt;= mid) tmp2[i] = f[i];    FFt(tmp1, 1), FFt(tmp2, 1);    for (int i = 0; i &lt; N; i++) tmp1[i] = 1ll * tmp1[i] * tmp2[i] % MOD;    FFt(tmp1, -1);    for (int i = mid + 1; i &lt;= r; i++) h[i] = (h[i] + tmp1[i - l]) % MOD;    memset (tmp1, 0, N &lt;&lt; 2);    memset (tmp2, 0, N &lt;&lt; 2);    for (int i = l; i &lt;= mid; i++) tmp1[i - l] = h[i];    for (int i = 0; i &lt;= r - l; i++) tmp2[i] = g[i];    FFt(tmp1, 1), FFt(tmp2, 1);    for (int i = 0; i &lt; N; i++) tmp1[i] = 1ll * tmp1[i] * tmp2[i] % MOD;    FFt(tmp1, -1);    for (int i = mid + 1; i &lt;= r; i++) f[i] = (f[i] + 1ll * tmp1[i - l - 1] * F[i - 1] % MOD * FInv[i] % MOD) % MOD;    Solve(mid + 1, r);}int main(){    int n = read();    scanf (&quot;%s&quot;, s);    for (int i = 0; i &lt; n; i++) s[i] -= &#39;0&#39;;    F[0] = 1;    for (int i = 1; i &lt;= n; i++) F[i] = 1ll * F[i - 1] * i % MOD;    FInv[n] = pow_mod(F[n], MOD - 2);    for (int i = n - 1; i &gt;= 0; i--) FInv[i] = 1ll * FInv[i + 1] * (i + 1) % MOD;    for (int i = 0; i &lt; n; i++) g[i] = 1ll * s[i] * FInv[i] * FInv[2] % MOD;    f[1] = 1;    Solve(1, n);    for (int i = 1; i &lt;= n; i++)        printf (&quot;%d\n&quot;, 1ll * f[i] * F[i] % MOD);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2018/02/28/131/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ3684: 大朋友和多叉树</title>
      <link>https://blog.wildrage.xyz/2018/02/26/130/</link>
      <guid>https://blog.wildrage.xyz/2018/02/26/130/</guid>
      <pubDate>Mon, 26 Feb 2018 00:52:23 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;我们的大朋友很喜欢计算机科学，而且尤其喜欢多叉树。对于一棵带有正整数
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>我们的大朋友很喜欢计算机科学，而且尤其喜欢多叉树。对于一棵带有正整数点权的有根多叉树，如果它满足这样的性质，我们的大朋友就会将其称作神犇的：点权为1的结点是叶子结点；对于任一点权大于1的结点u，u的孩子数目deg[u]属于集合D，且u的点权等于这些孩子结点的点权之和。<br>给出一个整数s，你能求出根节点权值为s的神犇多叉树的个数吗？请参照样例以更好的理解什么样的两棵多叉树会被视为不同的。<br>我们只需要知道答案关于950009857（453*2^21+1，一个质数）取模后的值。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行有2个整数s,m。<br>第二行有m个互异的整数，d[1],d[2],…,d[m]，为集合D中的元素。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一行仅一个整数，表示答案模950009857的值。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>4 22 3</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>10</code></pre><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p><img src="https://i.loli.net/2018/02/26/5a935c934121c.jpg" alt="aa.jpg"></p><p>数据规模：<br>$1 \leq m &lt; s \leq 10^5$, $2 \leq d[i] \leq s$，有3组小数据和3组大数据。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>求出树的生成函数$T(x) = \sum_{i\ge 0} t_ix^i$<br>$$T(x) = x + \sum_{k \in S}T(x)^k$$</p><p>移一下项<br>$$T(x) - \sum_{k \in S}T(x)^k = x$$</p><p>设$G(y) = y - \sum_{k \in S}{y^k}$</p><p>$$x = G(T(x))$$</p><p>$T(x)$为$G(x)$的复合逆</p><p>上拉格朗日反演</p><p>$$ [x^n]T(x) = \frac{1}{n}[x^{n-1}] ( \frac {x}{G(x)} )^n $$</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MOD = 950009857;const int MAXN = 2e6 + 5;inline int read(){    int x=0,f=1;char ch=getchar();    while (ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while (ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}    return x*f;}long long pow_mod(long long a, int b){    long long ans = 1;    while (b)    {        if (b &amp; 1) ans = ans * a % MOD;        b &gt;&gt;= 1;        a = a * a % MOD;    }    return ans;}int rev[MAXN];int Inv;void FFt(int *a, int N, int op){    int w, wn, t;    for (int i = 1; i &lt; N; i++)        if (i &lt; rev[i])            swap(a[i], a[rev[i]]);    for (int k = 2; k &lt;= N; k &lt;&lt;= 1)    {        wn = pow_mod(7, op == 1 ? (MOD - 1) / k : MOD - 1 - (MOD - 1) / k);        for (int j = 0; j &lt; N; j += k)        {            w = 1;            for (int i = 0; i &lt; (k &gt;&gt; 1); i++, w = 1ll * w * wn % MOD)            {                t = 1ll * a[i + j + (k &gt;&gt; 1)] * w % MOD;                a[i + j + (k &gt;&gt; 1)] = (a[i + j] - t + MOD) % MOD;                a[i + j] = (a[i + j] + t) % MOD;            }        }    }    if (op == -1)        for (int i = 0; i &lt; N; i++)            a[i] = 1ll * a[i] * Inv % MOD;}int tmp[MAXN];void Get_Inv(int dep, int *a, int *b){    if (dep == 1) return b[0] = pow_mod(a[0], MOD - 2), void();    Get_Inv((dep + 1) &gt;&gt; 1, a, b);    int N = 1;    while (N &lt; (dep &lt;&lt; 1))        N &lt;&lt;= 1;    Inv = pow_mod(N, MOD - 2);    for (int i = 1; i &lt; N; i++)        if (i &amp; 1)            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | (N &gt;&gt; 1);        else            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1);    //copy(a, a + dep, tmp);    for (int i = 0; i &lt; dep; i++)        tmp[i] = a[i];    for (int i = dep; i &lt; N; i++)        tmp[i] = 0;    //fill(tmp + dep, tmp + N, 0);    FFt(tmp, N, 1);    FFt(b, N, 1);    for (int i = 0; i &lt; N; i++)        b[i] = 1ll * b[i] * ((2 - 1ll * b[i] * tmp[i] % MOD + MOD) % MOD) % MOD;    FFt(b, N, -1);    for (int i = dep; i &lt; N; i++)        b[i] = 0;    //fill(b + dep, b + N, 0);}int G[MAXN], Ans[MAXN], C[MAXN];int main(){    int n = read(), m = read();    C[0] = 1;    for (int i = 1; i &lt;= m; i++)        C[read() - 1] = MOD - 1;    Get_Inv(n, C, G);    Ans[0] = 1;    int b = n;    int N = 1;    while (N &lt; 2 * n)        N &lt;&lt;= 1;    Inv = pow_mod(N, MOD - 2);    for (int i = 1; i &lt; N; i++)        if (i &amp; 1)            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | (N &gt;&gt; 1);        else            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1);    while (b)    {        if (b &amp; 1)        {            FFt(Ans, N, 1);            FFt(G, N, 1);            for (int i = 0; i &lt; N; i++) Ans[i] = 1ll * Ans[i] * G[i] % MOD;            FFt(Ans, N, -1);            FFt(G, N, -1);            for (int i = n; i &lt; N; i++)                Ans[i] = 0;        }        b &gt;&gt;= 1;        FFt(G, N, 1);        for (int i = 0; i &lt; N; i++) G[i] = 1ll * G[i] * G[i] % MOD;        FFt(G, N, -1);        for (int i = n; i &lt; N; i++)            G[i] = 0;        // fill(G + n, G + N, 0);    }    printf (&quot;%d\n&quot;, 1ll * Ans[n - 1] * pow_mod(n, MOD - 2) % MOD);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2018/02/26/130/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ3456: 城市规划</title>
      <link>https://blog.wildrage.xyz/2018/02/26/129/</link>
      <guid>https://blog.wildrage.xyz/2018/02/26/129/</guid>
      <pubDate>Mon, 26 Feb 2018 00:10:23 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;刚刚解决完电力网络的问题, 阿狸又被领导的任务给难住了.&lt;br&gt;刚才
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>刚刚解决完电力网络的问题, 阿狸又被领导的任务给难住了.<br>刚才说过, 阿狸的国家有n个城市, 现在国家需要在某些城市对之间建立一些贸易路线, 使得整个国家的任意两个城市都直接或间接的连通. 为了省钱, 每两个城市之间最多只能有一条直接的贸易路径. 对于两个建立路线的方案, 如果存在一个城市对, 在两个方案中是否建立路线不一样, 那么这两个方案就是不同的, 否则就是相同的. 现在你需要求出一共有多少不同的方案.<br>好了, 这就是困扰阿狸的问题. 换句话说, 你需要求出n个点的简单(无重边无自环)无向连通图数目.<br>由于这个数字可能非常大, 你只需要输出方案数mod 1004535809(479 * 2 ^ 21 + 1)即可.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>仅一行一个整数n(&lt;=130000)</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>仅一行一个整数, 为方案数 mod 1004535809.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code> 3</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code> 4</code></pre><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>对于 100%的数据, n &lt;= 130000</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>设无向图的生成函数为$G(x)$, 无向联通图的生成函数为$f(x)$<br>$$g(x) = 2^{C_n^2}$$<br>枚举无向图是由几个联通图构成的:<br>$$g(n) = \sum_{i = 1}^{n} { {n - 1} \choose {i - 1} } f(i) G(n - i)$$<br>$$2^{n \choose 2} = \sum_{i = 1}^{n} { {n - 1} \choose {i - 1} } f(i) 2^{ {n - i} \choose 2}$$<br>然后两边同时除以 $$(n−1)!$$<br>$$\frac{2^{n \choose 2} }{(n-1)!} = \sum_{i = 1}^{n} \frac{f(i)}{(i-1)!} \frac{2^{ {n - i} \choose 2} }{(n-i)!}$$</p><p>定义函数 $F(x),G(x),C(x)$</p><p>$$F(x) = \sum_{n=1}^{\infty} \frac{f(n)}{(n-1)!}x^n$$<br>$$G(x) = \sum_{n=0}^{\infty} \frac{2^{n \choose 2} }{n!}x^n $$<br>$$C(x) = \sum_{n=0}^{\infty} \frac{2^{n \choose 2} }{(n-1)!}x^n$$</p><p>$$C(x) = F(x)G(x)$$</p><p>$$C(x) \equiv F(x)G(x) mod { x^{n+1} }$$  </p><p>$$F(x) \equiv C(x)G^{-1}(x) mod { x^{n+1} }$$  </p><p>多项式求逆</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;inline int read(){    int x=0,f=1;char ch=getchar();    while (ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while (ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}    return x*f;}const int MOD = 1004535809;const int MAXN = 1 &lt;&lt; 18 + 1;long long pow_mod(long long a, int b){    long long ans = 1;    while (b)    {        if (b &amp; 1) ans = ans * a % MOD;        b &gt;&gt;= 1;        a = a * a % MOD;    }    return ans;}long long Inv;int N;int rev[MAXN];void FFt(long long *a, int op){    long long w, wn, t;    for (int i = 1; i &lt; N; i++)        if (i &lt; rev[i])            swap(a[i], a[rev[i]]);    for (int k = 2; k &lt;= N; k &lt;&lt;= 1)    {        wn = pow_mod(3, op == 1 ? (MOD - 1) / k : MOD - 1 - (MOD - 1) / k);        for (int j = 0; j &lt; N; j += k)        {            w = 1;            for (int i = 0; i &lt; (k &gt;&gt; 1); i++, w = w * wn % MOD)            {                t = a[i + j + (k &gt;&gt; 1)] * w % MOD;                a[i + j + (k &gt;&gt; 1)] = (a[i + j] - t + MOD) % MOD;                a[i + j] = (a[i + j] + t) % MOD;            }        }    }    if (op == -1)        for (int i = 0; i &lt; N; i++)            a[i] = a[i] * Inv % MOD;}long long tmp[MAXN];void Get_Inv(int dep, long long *a, long long *b){    if (dep == 1)        return b[0] = pow_mod(a[0], MOD - 2), void();    Get_Inv((dep + 1) &gt;&gt; 1, a, b);    N = 1;    while (N &lt; (dep &lt;&lt; 1))        N &lt;&lt;= 1;    Inv = pow_mod(N, MOD - 2);    for (int i = 1; i &lt; N; i++)        if (i &amp; 1)            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | (N &gt;&gt; 1);        else            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1);    copy(a, a + dep, tmp);    fill(tmp + dep, tmp + N, 0);    FFt(tmp, 1);    FFt(b, 1);    for (int i = 0; i &lt; N; i++)        b[i] = b[i] * ((2 - b[i] * tmp[i] % MOD + MOD) % MOD) % MOD;    FFt(b, -1);    fill(b + dep, b + N, 0);}long long F_Inv[MAXN];long long F[MAXN];long long C[MAXN], G[MAXN], G_Inv[MAXN];int main(){    int n = read();    F[0] = 1;    for (int i = 1; i &lt;= n; i++)        F[i] = F[i - 1] * i % MOD;    F_Inv[n] = pow_mod(F[n], MOD - 2);    for (int i = n - 1; i &gt;= 0; i--) F_Inv[i] = F_Inv[i + 1] * (i + 1) % MOD;    for (int i = 0; i &lt;= n; i++)        G[i] = (i &lt; 2) ? (1) : pow_mod(2, 1ll * i * (i - 1) / 2 % (MOD - 1)) * F_Inv[i] % MOD;    for (int i = 0; i &lt;= n; i++) C[i] = i * G[i] % MOD;    Get_Inv(n + 1, G, G_Inv);    N = 1;    while (N &lt;= n &lt;&lt; 1)        N &lt;&lt;= 1;    Inv = pow_mod(N, MOD - 2);    for (int i = 1; i &lt; N; i++)        if (i &amp; 1)            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | (N &gt;&gt; 1);        else            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1);    FFt(G_Inv, 1), FFt(C, 1);    for (int i = 0; i &lt; N; i++) C[i] = C[i] * G_Inv[i] % MOD;    FFt(C, -1);    printf (&quot;%d\n&quot;, C[n] * F[n - 1] % MOD);    // while (1);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2018/02/26/129/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ3771: Triple</title>
      <link>https://blog.wildrage.xyz/2018/02/25/128/</link>
      <guid>https://blog.wildrage.xyz/2018/02/25/128/</guid>
      <pubDate>Sun, 25 Feb 2018 23:32:23 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;我们讲一个悲伤的故事。&lt;br&gt;从前有一个贫穷的樵夫在河边砍柴。&lt;br
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>我们讲一个悲伤的故事。<br>从前有一个贫穷的樵夫在河边砍柴。<br>这时候河里出现了一个水神，夺过了他的斧头，说：<br>“这把斧头，是不是你的？”<br>樵夫一看：“是啊是啊！”<br>水神把斧头扔在一边，又拿起一个东西问：<br>“这把斧头，是不是你的？”<br>樵夫看不清楚，但又怕真的是自己的斧头，只好又答：“是啊是啊！”<br>水神又把手上的东西扔在一边，拿起第三个东西问：<br>“这把斧头，是不是你的？”<br>樵夫还是看不清楚，但是他觉得再这样下去他就没法砍柴了。<br>于是他又一次答：“是啊是啊！真的是！”<br>水神看着他，哈哈大笑道：<br>“你看看你现在的样子，真是丑陋！”<br>之后就消失了。<br>樵夫觉得很坑爹，他今天不仅没有砍到柴，还丢了一把斧头给那个水神。<br>于是他准备回家换一把斧头。<br>回家之后他才发现真正坑爹的事情才刚开始。<br>水神拿着的的确是他的斧头。<br>但是不一定是他拿出去的那把，还有可能是水神不知道怎么偷偷从他家里拿走的。<br>换句话说，水神可能拿走了他的一把，两把或者三把斧头。<br>樵夫觉得今天真是倒霉透了，但不管怎么样日子还得过。<br>他想统计他的损失。<br>樵夫的每一把斧头都有一个价值，不同斧头的价值不同。总损失就是丢掉的斧头价值和。<br>他想对于每个可能的总损失，计算有几种可能的方案。<br>注意：如果水神拿走了两把斧头a和b，(a,b)和(b,a)视为一种方案。拿走三把斧头时，(a,b,c),(b,c,a),(c,a,b),(c,b,a),(b,a,c),(a,c,b)视为一种方案。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行是整数N，表示有N把斧头。<br>接下来n行升序输入N个数字Ai，表示每把斧头的价值。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>若干行，按升序对于所有可能的总损失输出一行x y，x为损失值，y为方案数。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>44567</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>4 15 16 17 19 110 111 212 113 115 116 117 118 1</code></pre><h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p>11<br>有两种方案是4+7和5+6，其他损失值都有唯一方案，例如4=4,5=5,10=4+6,18=5+6+7.</p><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>所有数据满足：Ai&lt;=40000</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>一把，两把或者三把</p><p>首先写出生成函数$F(x) = x^{a_1}+x^{a_2}+x^{a_3}+…+x^{a_n}$<br>两把就是$F^2(x)$减去$B(x)=x^{2a_1}+x^{2a_2}+x^{2a_3}+…+x^{2a_n}$<br>三把就是$F^3(x)$减去$3*F(x)*B(x)$加上$C(x)=x^{3a_1}+x^{3a_2}+x^{3a_3}+…+x^{3a_n}$<br>FFT优化乘法</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;inline int read(){    int x=0,f=1;char ch=getchar();    while (ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while (ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}    return x*f;}const double pi = acos(-1.);struct Complex{    double x, y;    Complex() { x = y = 0; }    Complex(double a, double b) : x(a), y(b) {}    Complex operator+(const Complex &amp;a) { return Complex(x + a.x, y + a.y); }    Complex operator-(const Complex &amp;a) { return Complex(x - a.x, y - a.y); }    Complex operator*(const Complex &amp;a) { return Complex(x * a.x - y * a.y, x * a.y + y * a.x); }    Complex operator*(const double a) { return Complex(x * a, y * a); }    Complex Get() { return Complex(x, -y); }};double Inv;const int MAXN = 5e5 + 5;int N;int rev[MAXN];void FFt(Complex *a, int op){    Complex wn, w, t;    for (int i = 0; i &lt; N; i++)        if (i &lt; rev[i])            swap(a[i], a[rev[i]]);    for (int k = 2; k &lt;= N; k &lt;&lt;= 1)    {        wn = Complex(cos(pi / (k &gt;&gt; 1)), op * sin(pi / (k &gt;&gt; 1)));        for (int j = 0; j &lt; N; j += k)        {            w = Complex(1, 0);            for (int i = 0; i &lt; (k &gt;&gt; 1); i++, w = w * wn)            {                t = a[i + j + (k &gt;&gt; 1)] * w;                a[i + j + (k &gt;&gt; 1)] = a[i + j] - t;                a[i + j] = a[i + j] + t;            }        }    }    if (op == -1)        for (int i = 0; i &lt; N; i++)            a[i] = a[i] * Inv;}Complex A[MAXN], B[MAXN], C[MAXN];Complex tmp[MAXN];long long ans[MAXN];int m = 0;int main(){    int n = read();    for (int i = 1; i &lt;= n; i++)    {        int x = read();        ans[x]++;        A[x].x = 1;        B[2 * x].x = 1;        C[3 * x].x = 1;        m = max(m, 3 * x);    }    m = m + m + 1;    N = 1;    while (N &lt; m)         N &lt;&lt;= 1;    for (int i = 1; i &lt; N; i++)         if (i &amp; 1)            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | (N &gt;&gt; 1);        else            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1);    Inv = 1. / N;    FFt(A, 1);    for (int i = 0; i &lt; N; i++) tmp[i] = A[i] * A[i];    FFt(tmp, -1);    for (int i = 0; i &lt; N; i++) ans[i] += round((tmp[i].x - B[i].x) / 2);    // for (int i = 0; i &lt; N; i++)    //     if (ans[i])    //         printf (&quot;%d %lld\n&quot;, i, ans[i]);    // printf (&quot;======================================\n&quot;);    FFt(B, 1);    for (int i = 0; i &lt; N; i++) B[i] = B[i] * A[i];    FFt(B, -1);    for (int i = 0; i &lt; N; i++) tmp[i] = A[i] * A[i] * A[i];    FFt(tmp, -1);    for (int i = 0; i &lt; N; i++) ans[i] += round((tmp[i].x - B[i].x * 3 + C[i].x * 2) / 6);    for (int i = 0; i &lt;= m / 2; i++)        if (ans[i])            printf (&quot;%d %lld\n&quot;, i, ans[i]);    // while (1);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2018/02/25/128/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ3509: [CodeChef] COUNTARI</title>
      <link>https://blog.wildrage.xyz/2018/02/25/127/</link>
      <guid>https://blog.wildrage.xyz/2018/02/25/127/</guid>
      <pubDate>Sun, 25 Feb 2018 22:28:02 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;给定一个长度为N的数组A[]，求有多少对i, j, k（1&amp;lt;=
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给定一个长度为N的数组A[]，求有多少对i, j, k（1&lt;=i&lt;j&lt;k&lt;=N）满足A[k]-A[j]=A[j]-A[i]。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行一个整数N（N&lt;=10^5）。<br>接下来一行N个数A[i]（A[i]&lt;=30000）。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一行一个整数。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>103 5 3 6 3 4 10 4 5 2</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>9</code></pre><p>分块FFT<br>先分块， 暴力求出有三个在同一块，和两个在同一块的答案<br>三个都不在一块的FFT</p><pre><code class="c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;inline int read(){    int x=0,f=1;char ch=getchar();    while (ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while (ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}    return x*f;}const int MAXN = 1e6;const int MOD = 998244353;long long pow_mod(long long a, long long b, long long P){    long long ans = 1;    while (b)    {        if (b &amp; 1) ans = ans * a % P;        b &gt;&gt;= 1;        a = a * a % P;    }    return ans;}long long Inv, N;int rev[MAXN];void FFt(long long *a, int op){    long long wn, w, t;    for (int i = 0; i &lt; N; i++)        if (i &lt; rev[i])            swap(a[i], a[rev[i]]);    for (int k = 2; k &lt;= N; k &lt;&lt;= 1)    {        wn = pow_mod(3, op == 1 ? (MOD - 1) / k : MOD - 1 - (MOD - 1) / k, MOD);        for (int j = 0; j &lt; N; j += k)        {            w = 1;            for (int i = 0; i &lt; (k &gt;&gt; 1); i++, w = w * wn % MOD)            {                t = a[i + j + (k &gt;&gt; 1)] * w % MOD;                a[i + j + (k &gt;&gt; 1)] = (a[i + j] - t + MOD) % MOD;                a[i + j] = (a[i + j] + t) % MOD;            }        }    }    if (op == -1)        for (int i = 0; i &lt; N; i++)            a[i] = a[i] * Inv % MOD;}int Sum1[MAXN], Sum2[MAXN];int W[MAXN];int l[MAXN], r[MAXN];long long A[65537], B[65537];int main(){    int n = read();    for (int i = 0; i &lt; n; i++)        W[i] = read();    int len = min((int)sqrt(n) * 6, n);    int num = n / len;    if (n % len) num++;    long long ans = 0;    for (int i = 1; i &lt;= num; i++)    {        l[i] = (i - 1) * len;        r[i] = min(l[i] + len - 1, n - 1);    }    for (int i = 1; i &lt;= num; i++)    {        for (int j = l[i]; j &lt;= r[i]; j++)        {            for (int k = j + 1; k &lt;= r[i]; k++)                 if (2 * W[j] - W[k] &gt;= 0)                    ans += Sum1[2 * W[j] - W[k]];            Sum1[W[j]]++;        }    }    for (int i = num; i &gt;= 1; i--)    {        for (int j = l[i]; j &lt;= r[i]; j++)        {            for (int k = j + 1; k &lt;= r[i]; k++)                if (2 * W[k] - W[j] &gt;= 0)                    ans += Sum2[2 * W[k] - W[j]];        }        for (int j = l[i]; j &lt;= r[i]; j++)            Sum2[W[j]]++;    }    N = 65536;    Inv = pow_mod(N, MOD - 2, MOD);    for (int i = 1; i &lt; N; i++)        if (i &amp; 1)             rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | (N &gt;&gt; 1);        else            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1);    for (int i = 2; i &lt; num; i++)    {        memset (A, 0, sizeof (A));        memset (B, 0, sizeof (B));        for (int j = 0; j &lt; l[i]; j++) A[W[j]]++;        for (int j = r[i] + 1; j &lt; n; j++) B[W[j]]++;        FFt(A, 1), FFt(B, 1);        for (int j = 0; j &lt; N; j++) A[j] = A[j] * B[j];        FFt(A, -1);        for (int j = l[i]; j &lt;= r[i]; j++) ans += A[2 * W[j]];    }    printf (&quot;%lld\n&quot;, ans);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2018/02/25/127/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ3527: [ZJOI2014] 力</title>
      <link>https://blog.wildrage.xyz/2018/02/25/126/</link>
      <guid>https://blog.wildrage.xyz/2018/02/25/126/</guid>
      <pubDate>Sun, 25 Feb 2018 13:16:40 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;给出n个数qi，给出Fj的定义如下：&lt;br&gt;&lt;img src=&quot;ht
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给出n个数qi，给出Fj的定义如下：<br><img src="https://i.loli.net/2018/02/25/5a92b7c5d85cd.jpg" alt="11.jpg"><br>令Ei=Fi/qi，求Ei.  </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行一个整数n。<br>接下来n行每行输入一个数，第i行表示qi。<br>n≤100000，0&lt;qi&lt;1000000000  </p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>n行，第i行输出Ei。与标准答案误差不超过1e-2即可。  </p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>54006373.88518415375036.4357591717456.4691448514941.0049121410681.345880</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>-16838672.6933439.7937509018.5664595686.88610903040.872</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>写写题解证明自己还活着  </p><p>这道题是一道比较基础的题目  </p><p>先把Ei写出来得</p><p>$$ E_i = \sum_{i&lt;j} {\frac{p_i}{(i - j) ^ 2}} - \sum_{i&gt;j}{\frac{qi}{(i - j)^2}}$$</p><p>令 $f(i) = q_i,\ g(i) = \frac{1}{i^2}$</p><p>$$E_j=\sum_{i=1}^{j-1}f(i) \times g(j-i)-\sum_{i=j+1}^nf(i) \times g(j-i)$$</p><p>前一部分直接FFT算。</p><p>后一部分$\sum_{i=j+1}^nf(i) \times g(j-i)=\sum_{i=1}^{n-j}f(i+j) \times g(i)$  </p><p>令 $f’(n-i-j)=f(i+j)$ ，则第二部分变为 $\sum_{i=0}^{n-j-1}f’(n-i-j-1) \times g(i)$，转化为卷积的形式用FFT解即可。</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;complex&gt;using namespace std;#define Complex complex&lt;double&gt;const double pi = acos(-1.);inline int read(){    int x=0,f=1;char ch=getchar();    while (ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while (ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}    return x*f;}const int MAXN = 100005 * 8;int rev[MAXN]; double Inv;int N;void FFt(Complex *a, int op){    Complex t, w;    for (int i = 0; i &lt; N; i++)        if (i &gt; rev[i]) swap(a[i], a[rev[i]]);    for (int k = 2; k &lt;= N; k &lt;&lt;= 1)    {        Complex wn(cos(pi / (k &gt;&gt; 1)), op * sin(pi / (k &gt;&gt; 1)));        for (int j = 0; j &lt; N; j += k)        {            w = Complex(1, 0);            for (int i = 0; i &lt; (k &gt;&gt; 1); i++, w = w * wn)            {                t = a[i + j + (k &gt;&gt; 1)] * w;                a[i + j + (k &gt;&gt; 1)] = a[i + j] - t;                a[i + j] = a[i + j] + t;            }        }    }    if (op == -1)        for (int i = 0; i &lt; N; i++)            a[i] *= Inv;}Complex a[MAXN], b[MAXN], g[MAXN];int main(){    int n = read();    n--;    for (int i = 0; i &lt;= n; i++)    {        double x;        scanf (&quot;%lf&quot;, &amp;x);        b[n - i] = a[i] = x;    }    for (int i = 1; i &lt;= n; i++) g[i] = (1. / i / i);    int m = n + n + 1;    N = 1;    while (N &lt; m)        N &lt;&lt;= 1;    Inv = 1. / N;    for (int i = 0; i &lt; N; i++)        if (i &amp; 1)            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | (N &gt;&gt; 1);        else            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1);    FFt(a, 1), FFt(b, 1), FFt(g, 1);    for (int i = 0; i &lt; N; i++) a[i] = a[i] * g[i];    for (int i = 0; i &lt; N; i++) b[i] = b[i] * g[i];    FFt(a, -1), FFt(b, -1);    for (int i = 0; i &lt;= n; i++)        printf (&quot;%.3f\n&quot;, a[i].real() - b[n - i].real());    // while (1);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2018/02/25/126/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ2688: Green Hackenbush</title>
      <link>https://blog.wildrage.xyz/2018/01/18/125/</link>
      <guid>https://blog.wildrage.xyz/2018/01/18/125/</guid>
      <pubDate>Thu, 18 Jan 2018 12:57:55 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;有一个古老的游戏叫做Green Hackenbush，游戏是这样进行
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>有一个古老的游戏叫做Green Hackenbush，游戏是这样进行的：两个人轮流在一棵树上删边，每次删边后不与根联通的子树直接被ignore，不能删边的游戏者输。Alice和Bob也在玩这个游戏，不过他们面对的是n棵树，第i棵树是含有a[i]个节点的二叉树。先手的Alice想知道自己有多大的概率获胜(假设我们的Alice和Bob同学都是无限聪明的)。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行一个数n。<br>接下来每行一个数a[i]。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一个保留6位小数的实数ans。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>12</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>1.000000</code></pre><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>对于100%的数据，n&lt;=100，a[i]&lt;=100</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先我们考虑正常的Green Hackenbush游戏  </p><h4 id="Step1"><a href="#Step1" class="headerlink" title="Step1:"></a>Step1:</h4><p>让我们先从最简单的开始<br>假设树退化为一条链<br>那么我们会发现这好像就是一个Nim游戏<br>那么我们可以通过异或来解决这个问题  </p><h4 id="Step2"><a href="#Step2" class="headerlink" title="Step2:"></a>Step2:</h4><p>再让我们考虑一颗树<br>那么根据Colon Principle原理<br>一个点的SG函数值为它的所有的子树的SG+1的异或和<br>举个例子<br>从网上找的一张图  </p><p><img src="https://i.loli.net/2018/01/18/5a609c4e07868.jpg" alt="1344074319_7883.jpg"><br>大家可以自己算一下  </p><h5 id="感性证明"><a href="#感性证明" class="headerlink" title="感性证明"></a>感性证明</h5><blockquote><p>首先不考虑这个点以下的部分(我们一会再去管他) ， 在这个点以上的部分先不考虑链接这个点的那些边。<br>那么他上面可以看做是几个子游戏。 我们可以递归的计算他们是SG值<br>把他们等效成一条链， 然后加上链接这个点的那些边， 及SG+1<br>根据Nim 的结论， 我们可以将他们异或起来。  </p><hr><p>现在让我们考虑下面的部分<br>假设一个任意固定的图G，一个任意节点x，让H1和H2为任意的树，且拥有相同的SG值。考虑这样两个图G1=Gx:H1和G2=Gx:H2，Gx：Hi表示该图是把树Hi连接图的x节点。<br>则我们需要证明G1与G2的SG值相等<br>G1、G2拥有相同的SG值意味着两个游戏的总SG值为0，G1+G2的和是一个P局面，也就是必败<br>先手一旦在其中一幅图中取走任意一条边，后手即可在另一幅图中取走相对应的一条边。轮流下去，最后肯定是后手获胜。</p></blockquote><p>然后我们搞定了正常的Green Hackenbush游戏 </p><p>现在让我们来看这道题<br>对应$x$个点去建一颗二叉树有多少种方法?<br>分别考虑左右子树<br>我们有<br>$$h[x] = \sum_{i = 0}^{n - 1}{h[i] * h[n - i - 1]}$$<br>这好像就是卡特兰数。<br>然后我们设$g[i][j]$为有$i$个点的树SG值为$j$的概率  </p><p>得DP方程为</p><p>$$g[n][(x + 1) \^ (y + 1)] = \sum_{i = 0}^{n - 1}{ h[i] * g[i][x] * h[n - 1 - i] * g[n - 1 - i][y]}$$</p><p>f[i][j]表示的是前i颗子树异或值为j的概率</p><p>$$f[i][j \^ k]=f[i-1][j] * g[a[i]][k]$$</p><p>搞定<br>$ans = 1-f[n][0]$</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;inline int read(){    int x=0,f=1;char ch=getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}    return x*f;}int a[105];double h[150];double g[350][350], f[350][350];int main(){    int n = read(), m = 0;    for (int i = 1; i &lt;= n; i++)        a[i] = read(), m = max(m, a[i]);    h[0] = 1;    for (int i = 1; i &lt;= m; i++)        h[i] = h[i - 1] * (4 * i - 2) / (i + 1);    g[1][0] = 1;    for (int i = 2; i &lt;= m; i++)    {        for (int j = 0; j &lt;= 127; j++) g[i][j + 1] += h[i - 1] * 2 * g[i - 1][j];        for (int j = 1; j &lt; i - 1; j++)        {            int k = i - j - 1;            for (int x = 0; x &lt;= 127; x++)                for (int y = 0; y &lt;= 127; y++)                    g[i][(x + 1) ^ (y + 1)] += h[j] * g[j][x] * h[k] * g[k][y];        }        for (int j = 0; j &lt;= n - 1; j++) g[i][j] /= h[i];    }    for (int i = 0; i &lt;= 127; i++) f[1][i] = g[a[1]][i];    for (int i = 2; i &lt;= n; i++)        for (int j = 0; j &lt;= 127; j++)            for (int k = 0; k &lt;= 127; k++)                f[i][j ^ k] += f[i - 1][j] * g[a[i]][k];    printf (&quot;%.6f\n&quot;, 1.0 - f[n][0]);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2018/01/18/125/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ2017 [Usaco2009 Nov] 硬币游戏</title>
      <link>https://blog.wildrage.xyz/2018/01/18/124/</link>
      <guid>https://blog.wildrage.xyz/2018/01/18/124/</guid>
      <pubDate>Thu, 18 Jan 2018 12:44:36 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;农夫约翰的奶牛喜欢玩硬币游戏，因此他发明了一种称为“Xoinc”的两
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>农夫约翰的奶牛喜欢玩硬币游戏，因此他发明了一种称为“Xoinc”的两人硬币游戏。 初始时，一个有N(5 &lt;= N &lt;= 2,000)枚硬币的堆栈放在地上，从堆顶数起的第I枚硬币的币值为$C_i$ (1 &lt;= $C_i$ &lt;= 100,000)。 开始玩游戏时，第一个玩家可以从堆顶拿走一枚或两枚硬币。如果第一个玩家只拿走堆顶的一枚硬币，那么第二个玩家可以拿走随后的一枚或两枚硬币。如果第一个玩家拿走两枚硬币，则第二个玩家可以拿走1，2，3，或4枚硬币。在每一轮中，当前的玩家至少拿走一枚硬币，至多拿走对手上一次所拿硬币数量的两倍。当没有硬币可拿时，游戏结束。 两个玩家都希望拿到最多钱数的硬币。请问，当游戏结束时，第一个玩家最多能拿多少钱呢？</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：1个整数N</p><p>第2..N+1行：第i+1行包含1个整数$C_i$</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>第1行：1个整数表示第1个玩家能拿走的最大钱数。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>513172</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>9</code></pre><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>样例说明：第1个玩家先取走第1枚，第2个玩家取第2枚；第1个取走第3，4两枚，第2个玩家取走最后1枚。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>DP  </p><p>设f[i][j]为还剩i个硬币这一次最多能取j个的最大价值<br>a[i]为硬币价值的后缀和<br>为了方便逆序读入<br>然后$f[i][j] = max(f[i][j - 1], a[i] - f[i - j][min(i - j, 2 * j)])$<br>搞定</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;inline int read(){    int x=0,f=1;char ch=getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}    return x*f;}int a[2005];int f[2005][2005];int main(){    int n = read();    for (int i = n; i &gt;= 1; i--) a[i] = read();    for (int i = 1; i &lt;= n; i++) a[i] += a[i - 1];    for (int i = 1; i &lt;= n; i++)        for (int j = 1; j &lt;= i; j++)            f[i][j] = max(f[i][j - 1], a[i] - f[i - j][min(i - j, j * 2)]);    printf (&quot;%d\n&quot;, f[n][2]);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2018/01/18/124/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ1095 [ZJOI2007] Hide 捉迷藏</title>
      <link>https://blog.wildrage.xyz/2018/01/16/123/</link>
      <guid>https://blog.wildrage.xyz/2018/01/16/123/</guid>
      <pubDate>Tue, 16 Jan 2018 00:24:12 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;　　捉迷藏 Jiajia和Wind是一对恩爱的夫妻，并且他们有很多孩
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>　　捉迷藏 Jiajia和Wind是一对恩爱的夫妻，并且他们有很多孩子。某天，Jiajia、Wind和孩子们决定在家里玩<br>捉迷藏游戏。他们的家很大且构造很奇特，由N个屋子和N-1条双向走廊组成，这N-1条走廊的分布使得任意两个屋<br>子都互相可达。游戏是这样进行的，孩子们负责躲藏，Jiajia负责找，而Wind负责操纵这N个屋子的灯。在起初的<br>时候，所有的灯都没有被打开。每一次，孩子们只会躲藏在没有开灯的房间中，但是为了增加刺激性，孩子们会要<br>求打开某个房间的电灯或者关闭某个房间的电灯。为了评估某一次游戏的复杂性，Jiajia希望知道可能的最远的两<br>个孩子的距离（即最远的两个关灯房间的距离）。 我们将以如下形式定义每一种操作： C(hange) i 改变第i个房<br>间的照明状态，若原来打开，则关闭；若原来关闭，则打开。 G(ame) 开始一次游戏，查询最远的两个关灯房间的<br>距离。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>　　第一行包含一个整数N，表示房间的个数，房间将被编号为1,2,3…N的整数。接下来N-1行每行两个整数a, b，<br>表示房间a与房间b之间有一条走廊相连。接下来一行包含一个整数Q，表示操作次数。接着Q行，每行一个操作，如<br>上文所示。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>　　对于每一个操作Game，输出一个非负整数到hide.out，表示最远的两个关灯房间的距离。若只有一个房间是关<br>着灯的，输出0；若所有房间的灯都开着，输出-1。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>81 22 33 43 53 66 76 87GC 1GC 2GC 1G</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>4334</code></pre><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>对于100%的数据， N ≤100000, M ≤500000。</p><p>动态点分治<br>将每次点分治中的重心建树<br>在每个点维护值<br>本题维护两个堆<br>C[i] 维护子树中的黑点到起分治父亲的Dis<br>B[i] 维护子树中C[i]的堆顶  </p><p>ans 维护答案  </p><pre><code class="c++">#pragma GCC optimize(&quot;O3&quot;)#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;iostream&gt;#include&lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;inline int read(){    int x=0,f=1;char ch=getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;0&#39;)f=-1;ch=getchar();}    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}    return x*f;}const int MAXN = 100005;struct Priority_queue{    __gnu_pbds::priority_queue&lt;int, less&lt;int&gt;, __gnu_pbds::binary_heap_tag&gt; Q1, Q2;    inline int size()    {        return Q1.size() - Q2.size();    }    inline void push(const int &amp;x)    {        Q1.push(x);    }    inline void erase(const int &amp;x)    {        Q2.push(x);    }    inline int top()    {        while (!Q2.empty() &amp;&amp; Q1.top() == Q2.top())        {            Q1.pop();            Q2.pop();        }        if (!Q1.empty()) return Q1.top();        else return 0;    }    inline int top2()    {        if (size() &lt; 2) return 0;        while (!Q2.empty() &amp;&amp; Q1.top() == Q2.top())        {            Q1.pop();            Q2.pop();        }        int tmp = Q1.top(); Q1.pop();        while (!Q2.empty() &amp;&amp; Q1.top() == Q2.top())        {            Q1.pop();            Q2.pop();        }        int ans = Q1.top(); Q1.push(tmp);        return ans;    }}B[MAXN], C[MAXN], ans;struct edge{    int END, next;}v[MAXN &lt;&lt; 1];int first[MAXN], p;inline void add(int a, int b){    v[p].END = b;    v[p].next = first[a];    first[a] = p++;}int f[MAXN][18];int dep[MAXN];inline void PreDFS(int rt, int fa){    dep[rt] = dep[fa] + 1;    f[rt][0] = fa;    for (int i = 1; i &lt;= 17; i++) f[rt][i] = f[f[rt][i - 1]][i - 1];    for (int i = first[rt]; i != -1; i = v[i].next)    {        if (v[i].END == fa) continue;        PreDFS(v[i].END, rt);    }}int sum, Max[MAXN], size[MAXN], root;bool vis[MAXN];static inline void GetRoot(int rt, int fa){    size[rt] = 1; Max[rt] = 0;    for (int i = first[rt]; i != -1; i = v[i].next)    {        if (vis[v[i].END] || v[i].END == fa) continue;        GetRoot(v[i].END, rt);        size[rt] += size[v[i].END];        Max[rt] = max(Max[rt], size[v[i].END]);    }    Max[rt] = max(Max[rt], sum - size[rt]);    if (Max[rt] &lt; Max[root]) root = rt;}int Fa[MAXN];static inline void Divide(int rt, int fa){    vis[rt] = 1;    Fa[rt] = fa;    // cerr &lt;&lt; rt &lt;&lt; endl;    for (int i = first[rt]; i != -1; i = v[i].next)    {        if (vis[v[i].END]) continue;        sum = size[v[i].END], root = 0;        GetRoot(v[i].END, 0);        Divide(root, rt);    }}static inline int LCA(int a, int b){    if (dep[a] &lt; dep[b]) swap(a, b);    int d = dep[a] - dep[b];    for (int i = 17; i &gt;= 0; i--)        if (d &amp; (1 &lt;&lt; i))            d -= (1 &lt;&lt; i), a = f[a][i];    if (a == b) return a;    for (int i = 17; i &gt;= 0; i--)        if (f[a][i] != f[b][i])            a = f[a][i], b = f[b][i];    return f[a][0];}static inline int dis(const int &amp;a, const int &amp;b){    return dep[a] + dep[b] - 2 * dep[LCA(a, b)];}int Color[MAXN];static inline void Change_To_Black(const int &amp;Height_root, const int &amp;Child){    if (Height_root == Child)    {        B[Height_root].push(0);        if (B[Height_root].size() == 2)            ans.push(B[Height_root].top());    }    if (!Fa[Height_root]) return;    int Father = Fa[Height_root];    int Dis = dis(Father, Child);    int tmp = C[Height_root].top();    C[Height_root].push(Dis);    if (Dis &gt; tmp)    {        int size = B[Father].size();        int tmp2 = B[Father].top() + B[Father].top2();        if (tmp)            B[Father].erase(tmp);        B[Father].push(Dis);        int now = B[Father].top() + B[Father].top2();        if (now &gt; tmp2)        {            if (size &gt;= 2) ans.erase(tmp2);            if (B[Father].size() &gt;= 2)                ans.push(now);        }    }    Change_To_Black(Father, Child);}static inline void Change_To_White(const int &amp;Height_root, const int &amp;Child){    if (Height_root == Child)    {        if (B[Height_root].size() == 2)            ans.erase(B[Height_root].top());        B[Height_root].erase(0);    }    if (!Fa[Height_root]) return;    int Father = Fa[Height_root];    int Dis = dis(Father, Child);    int tmp = C[Height_root].top();    C[Height_root].erase(Dis);    if (tmp == Dis)    {        int size = B[Father].size();        int tmp2 = B[Father].top() + B[Father].top2();        B[Father].erase(Dis);        if (C[Height_root].top())            B[Father].push(C[Height_root].top());        int now = B[Father].top() + B[Father].top2();        if (now &lt; tmp2)        {            if (size &gt;= 2)                ans.erase(tmp2);            if (B[Father].size() &gt;= 2)                ans.push(now);        }    }    Change_To_White(Father, Child);}int main(){    memset (first, -1, sizeof (first));    int n = read();    for (int i = 1; i &lt; n; i++)    {        int a = read(), b = read();        add(a, b);        add(b, a);        // cerr &lt;&lt; i &lt;&lt; endl;    }    PreDFS(1, 0);    Max[0] = sum = n;    GetRoot(1, 0);    Divide(root, 0);    // cerr &lt;&lt; &quot;11!!&quot; &lt;&lt; endl;    for (int i = 1; i &lt;= n; i++)    {        Color[i] = 1;        // cerr &lt;&lt; i &lt;&lt; endl;        C[i].push(0);        // Change_To_Black(i, i);    }    for (int i = 1; i &lt;= n; i++)    {        Change_To_Black(i, i);        // cerr &lt;&lt; i &lt;&lt; endl;            }    // for (int i = 1; i &lt;= n; i++) cerr &lt;&lt; &quot;i fa is &quot; &lt;&lt; Fa[i] &lt;&lt; endl;    int m = read();    char s[10];    for (int i = 1; i &lt;= m; i++)    {        // cerr &lt;&lt; i &lt;&lt; endl;        scanf (&quot;%s&quot;, s);        if (s[0] == &#39;C&#39;)        {            int k = read();            if (Color[k])            {                Color[k] = 0;                Change_To_White(k, k);            }            else            {                Color[k] = 1;                Change_To_Black(k, k);            }        }        else            printf (&quot;%d\n&quot;, ans.top());    }}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2018/01/16/123/#disqus_thread</comments>
    </item>
    
    <item>
      <title>上下界网络流笔记</title>
      <link>https://blog.wildrage.xyz/2018/01/15/122/</link>
      <guid>https://blog.wildrage.xyz/2018/01/15/122/</guid>
      <pubDate>Mon, 15 Jan 2018 23:19:34 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;无源汇可行流&quot;&gt;&lt;a href=&quot;#无源汇可行流&quot; class=&quot;headerlink&quot; title=&quot;无源汇可行流&quot;&gt;&lt;/a&gt;无源汇可行流&lt;/h3&gt;&lt;p&gt;将上下界的网络流转化为普通网络流。  &lt;/p&gt;
&lt;p&gt;建图:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加源点S与汇点T&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="无源汇可行流"><a href="#无源汇可行流" class="headerlink" title="无源汇可行流"></a>无源汇可行流</h3><p>将上下界的网络流转化为普通网络流。  </p><p>建图:</p><ul><li>添加源点S与汇点T</li><li>对于原图中的边$a-&gt;b$ 流量限制为$[c, d]$, 则连边$a-&gt;b$, 流量为$d-c$</li><li>对于原图中的每一个点$i$, 记$d(i)$ 为流入这个点的所有边的下界-流出这个点的所有边的下界<ul><li>若$d(i) &gt; 0$连$S-&gt;i$, 流量为$d(i)$</li><li>若$d(i) &lt; 0$连$i-&gt;T$, 流量为$-d(i)$</li></ul></li></ul><p>在新图上跑$S-&gt;T$的最大流<br>若新图满流则原图存在可行流<br>原图中边流量为新图中对应边的流量加下界。  </p><h3 id="有源汇可行流"><a href="#有源汇可行流" class="headerlink" title="有源汇可行流"></a>有源汇可行流</h3><p>建图:</p><ul><li>在原图中加一条$t-&gt;s$的边流量为$[0, INF]$  </li><li>用无源汇求解</li></ul><h3 id="有源汇最大流"><a href="#有源汇最大流" class="headerlink" title="有源汇最大流"></a>有源汇最大流</h3><p>建图 同上</p><p>在新图上跑$S-&gt;T$最大流<br>记此时$\sum{f(s, i)} = sum1$<br>讲$t-&gt;s$的边拆掉， 跑$s-&gt;t$的最大流<br>记此时$\sum{f(s, i)} = sum2$<br>则答案为$sum1+sum2$</p><h3 id="有源汇最小流"><a href="#有源汇最小流" class="headerlink" title="有源汇最小流"></a>有源汇最小流</h3><p>建图方法同无源汇可行流<br>求$S-&gt;T$最大流<br>连边$t-&gt;s,INF$<br>求$S-&gt;T$最大流<br>答案为$t-&gt;s$的实际流量</p><h3 id="有源汇费用流"><a href="#有源汇费用流" class="headerlink" title="有源汇费用流"></a>有源汇费用流</h3><p>将上下界的网络流转化为普通网络流。  </p><p>建图:</p><ul><li>添加源点$S$与汇点$T$</li><li>对于原图中的边$a-&gt;b$ 流量限制为$[c, d]$,费用为$v$, 则连边$a-&gt;b$, 流量为$d-c$, 费用为$v$</li><li>对于原图中的每一个点$i$, 记$d(i)$ 为流入这个点的所有边的下界-流出这个点的所有边的下界<ul><li>若$d(i) &gt; 0$连$S-&gt;i$, 流量为$d(i)$, 费用为$0$</li><li>若$d(i) &lt; 0$连$i-&gt;T$, 流量为$-d(i)$, 费用为$0$</li></ul></li></ul><p>连边$t-&gt;s$，流量为$INF$，费用为$0$</p><p>跑$S-&gt;T$的最小费用最大流<br>答案为$ans$+原图中边的下界*边的费用</p>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2018/01/15/122/#disqus_thread</comments>
    </item>
    
    <item>
      <title>你好 2018</title>
      <link>https://blog.wildrage.xyz/2018/01/01/hello-2018/</link>
      <guid>https://blog.wildrage.xyz/2018/01/01/hello-2018/</guid>
      <pubDate>Mon, 01 Jan 2018 00:21:11 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/01/01/5a49f0a6c5298.jpg&quot; alt=&quot;new_year_2018_color-790x500.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;新的一年到来了，送走了2017年的伤心与欢乐，我们迎来的新的20
        
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="https://i.loli.net/2018/01/01/5a49f0a6c5298.jpg" alt="new_year_2018_color-790x500.jpg"></p><p>新的一年到来了，送走了2017年的伤心与欢乐，我们迎来的新的2018。<br>在新的一年里，我们要带着欢笑带着不放弃的精神继续向前。<br>无论我们面对是什么， 还是要走下去。</p><h2 id="新年快乐！"><a href="#新年快乐！" class="headerlink" title="新年快乐！"></a>新年快乐！</h2><h5 id="再见-2017！你好-2018！"><a href="#再见-2017！你好-2018！" class="headerlink" title="再见 2017！你好 2018！"></a>再见 2017！你好 2018！</h5><h5 id="再見-2017！你好-2018！"><a href="#再見-2017！你好-2018！" class="headerlink" title="再見 2017！你好 2018！"></a>再見 2017！你好 2018！</h5><h5 id="Goodbye-2017-Hello-2018"><a href="#Goodbye-2017-Hello-2018" class="headerlink" title="Goodbye 2017! Hello 2018!"></a>Goodbye 2017! Hello 2018!</h5><h5 id="さよなら2017！こんにちは2018！"><a href="#さよなら2017！こんにちは2018！" class="headerlink" title="さよなら2017！こんにちは2018！"></a>さよなら2017！こんにちは2018！</h5><h5 id="Au-revoir-2017-Bonjour-2018"><a href="#Au-revoir-2017-Bonjour-2018" class="headerlink" title="Au revoir 2017! Bonjour 2018!"></a>Au revoir 2017! Bonjour 2018!</h5><h5 id="До-свидания-2017-Привет-2018"><a href="#До-свидания-2017-Привет-2018" class="headerlink" title="До свидания 2017! Привет 2018!"></a>До свидания 2017! Привет 2018!</h5><h5 id="Auf-Wiedersehen-2017-Hallo-2018"><a href="#Auf-Wiedersehen-2017-Hallo-2018" class="headerlink" title="Auf Wiedersehen 2017! Hallo 2018!"></a>Auf Wiedersehen 2017! Hallo 2018!</h5><h5 id="وداعا-2017-مرحبا-2018"><a href="#وداعا-2017-مرحبا-2018" class="headerlink" title="وداعا 2017! مرحبا 2018!"></a>وداعا 2017! مرحبا 2018!</h5><h5 id="Adios-2017-¡Hola-2018"><a href="#Adios-2017-¡Hola-2018" class="headerlink" title="Adiós 2017! ¡Hola 2018!"></a>Adiós 2017! ¡Hola 2018!</h5>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2018/01/01/hello-2018/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ2716 [Violet 3]天使玩偶</title>
      <link>https://blog.wildrage.xyz/2017/12/14/121/</link>
      <guid>https://blog.wildrage.xyz/2017/12/14/121/</guid>
      <pubDate>Thu, 14 Dec 2017 06:16:10 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2017/
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p><img src="https://i.loli.net/2017/12/14/5a3217db068a2.gif" alt="T3des(2).gif"></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p><img src="https://i.loli.net/2017/12/14/5a3217ff16911.gif" alt="T3input(2).gif"></p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p><img src="https://i.loli.net/2017/12/14/5a32181b4a7e4.gif" alt="T3output(2).gif"></p><h3 id="Sample-Input-amp-Output"><a href="#Sample-Input-amp-Output" class="headerlink" title="Sample Input &amp; Output"></a><a href="https://gist.coding.net/u/WildRage/7d0ed646ecbf4c2bbba59382e1288dbe" target="_blank" rel="noopener">Sample Input &amp; Output</a></h3><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p><img src="https://i.loli.net/2017/12/14/5a3218388c880.gif" alt="T3hint(2).gif"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>KD-Tree带插入的板子。<br>应该<code>rebuild</code>的。<br>但没<code>rebuild</code>就过了。  </p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;inline int read(){    int x=0,f=1;char ch=getchar();    while (ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while (ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}    return x*f;}const int INF = 0x3f3f3f3f;const double alpha = 0.756;const int MAXN = 5e5 + 5;int now;struct Point{    int d[2];    int &amp;operator[](const int &amp;x)    {        return d[x];    }    inline bool operator &lt; (const Point &amp;x) const     {        return d[now] == x.d[now] ? d[now ^ 1] &lt; x.d[now ^ 1] : d[now] &lt; x.d[now];    }}a[MAXN], cur;#define dis(_, __) (\    int(abs(_[0] - __[0]) + abs(_[1] - __[1]))\)#define size(_) ((_) ? (_)-&gt;s : 0)struct Node{    Node *ch[2];    Point v;    int s, d;    int Max[2], Min[2];    Node(Point x)    {        ch[0] = ch[1] = NULL;        v = x;        s = 1, d = now;        Max[0] = Min[0] = x[0];        Max[1] = Min[1] = x[1];    }    Node(){;}    inline bool operator &lt; (const Node &amp;x) const     {        return v &lt; x.v;    }    bool IsBad()    {        return ((size(ch[0]) &gt; s * alpha) || (size(ch[1]) &gt; s * alpha));    }    void Pushup(Node *x)    {        if (!x) return;        for (int i = 0; i &lt;= 1; i++) Min[i] = min(Min[i], x-&gt;Min[i]);        for (int i = 0; i &lt;= 1; i++) Max[i] = max(Max[i], x-&gt;Max[i]);        s += x-&gt;s;    }    int min_dis()    {        int ans = 0;        ans += max(Min[0] - cur[0], 0) + max(cur[0] - Max[0], 0);        ans += max(Min[1] - cur[1], 0) + max(cur[1] - Max[1], 0);        return ans;    }}*root;inline void Build(Node *&amp;rt, int l, int r, int d = 0){    if (l &gt; r) return;    int mid = l + r &gt;&gt; 1;    now = d;    nth_element(a + l, a + mid, a + r + 1);    rt = new Node(a[mid]);    Build(rt-&gt;ch[0], l, mid - 1, d ^ 1);    Build(rt-&gt;ch[1], mid + 1, r, d ^ 1);    rt-&gt;s = 1;    rt-&gt;Pushup(rt-&gt;ch[0]);    rt-&gt;Pushup(rt-&gt;ch[1]);}Node **res;inline void Insert(Node *&amp;rt){    if (rt == NULL)    {        rt = new Node(cur);        res = NULL;        return;    }    now = rt-&gt;d;    if (cur &lt; rt-&gt;v) Insert(rt-&gt;ch[0]);    else Insert(rt-&gt;ch[1]);    rt-&gt;s = 1;    rt-&gt;Pushup(rt-&gt;ch[0]);    rt-&gt;Pushup(rt-&gt;ch[1]);    if (rt-&gt;IsBad()) res = &amp;rt;}inline void Insert(Point x){    cur = x;    Insert(root);}int Min_ans;inline void Query(Node *rt){    if (!rt) return;    // if (rt-&gt;min_dis() &gt; Min_ans) return;    Min_ans = min(Min_ans, dis(rt-&gt;v, cur));    int dis_l = rt-&gt;ch[0] ? rt-&gt;ch[0]-&gt;min_dis() : INF;    int dis_r = rt-&gt;ch[1] ? rt-&gt;ch[1]-&gt;min_dis() : INF;    if (dis_l &lt; dis_r)    {        Query(rt-&gt;ch[0]);        if (dis_r &lt; Min_ans) Query(rt-&gt;ch[1]);    }    else    {        Query(rt-&gt;ch[1]);        if (dis_l &lt; Min_ans) Query(rt-&gt;ch[0]);    }}inline int Query(Point x){    cur = x;    Min_ans = INF;    Query(root);    return Min_ans;}int main(){    // freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);    // freopen(&quot;2.out&quot;, &quot;w&quot;, stdout);    int n, m;    n = read(), m = read();    for (int i = 1; i &lt;= n; i++)        a[i][0] = read(), a[i][1] = read();    Build(root, 1, n);    Point x;    while (m--)    {        int t = read();        if (t == 1)        {            x[0] = read(), x[1] = read();            Insert(x);        }        else        {            x[0] = read(), x[1] = read();            printf (&quot;%d\n&quot;, Query(x));        }    }}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/12/14/121/#disqus_thread</comments>
    </item>
    
    <item>
      <title>NOIP 考前，考中，考后</title>
      <link>https://blog.wildrage.xyz/2017/11/11/120/</link>
      <guid>https://blog.wildrage.xyz/2017/11/11/120/</guid>
      <pubDate>Sat, 11 Nov 2017 00:14:15 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;p&gt;2017-11-9&lt;/p&gt;
&lt;p&gt;明天就出发了，还有不少东西没有复习，心里好虚啊。&lt;br&gt;觉得自己什么都不会， 不知道怎么办。&lt;br&gt;很压抑啊， 题也做不下去了， 下午去吃了个火锅。 放松了些。&lt;br&gt;但回到机房又是一种压抑的感觉。&lt;br&gt;好难受。&lt;br&gt;果然是还
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><p>2017-11-9</p><p>明天就出发了，还有不少东西没有复习，心里好虚啊。<br>觉得自己什么都不会， 不知道怎么办。<br>很压抑啊， 题也做不下去了， 下午去吃了个火锅。 放松了些。<br>但回到机房又是一种压抑的感觉。<br>好难受。<br>果然是还没有做好退役的准备啊。  </p><p>唉…</p><p>2017-11-13</p><p>考完了， 也是回到了学校。<br>先是一个假期， 然而我好象并不能回家。<br>在机房待着。<br>反正也是考完了， 考的怎样就不想管了。<br>不管能不能参加省选， 首先迎接我们的是恐怖的文化课补课。<br>以及那让人讨厌的会考。。  </p>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/11/11/120/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ3925 状压DP+概率DP</title>
      <link>https://blog.wildrage.xyz/2017/10/30/119/</link>
      <guid>https://blog.wildrage.xyz/2017/10/30/119/</guid>
      <pubDate>Mon, 30 Oct 2017 00:14:15 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;转载自 Cooook&lt;br&gt;&lt;a href=&quot;http://cooook.coding.me/2017/10/30/BZOJ3925/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ3925 状压DP+概率DP&lt;/a&gt;&lt;b
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>转载自 Cooook<br><a href="http://cooook.coding.me/2017/10/30/BZOJ3925/" target="_blank" rel="noopener">BZOJ3925 状压DP+概率DP</a><br>转载请注明原文地址</p></blockquote><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>傲娇少女幽香是一个很萌很萌的妹子，而且她非常非常地有爱心，很喜欢为幻想乡的人们做一些自己力所能及的事情来帮助他们。 这不，幻想乡突然发生了地震，所有的道路都崩塌了。现在的首要任务是尽快让幻想乡的交通体系重新建立起来。幻想乡一共有n个地方，那么最快的方法当然是修复n-1条道路将这n个地方都连接起来。 幻想乡这n个地方本来是连通的，一共有m条边。现在这m条边由于地震的关系，全部都毁坏掉了。每条边都有一个修复它需要花费的时间，第i条边所需要的时间为ei。地震发生以后，由于幽香是一位人生经验丰富，见得多了的长者，她根据以前的经验，知道每次地震以后，每个ei会是一个0到1之间均匀分布的随机实数。并且所有ei都是完全独立的。 现在幽香要出发去帮忙修复道路了，她可以使用一个神奇的大魔法，能够选择需要的那n-1条边，同时开始修复，那么修复完成的时间就是这n-1条边的ei的最大值。当然幽香会先使用一个更加神奇的大魔法来观察出每条边ei的值，然后再选择完成时间最小的方案。 幽香在走之前，她想知道修复完成的时间的期望是多少呢？ </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行两个数n,m，表示地方的数量和边的数量。其中点从1到n标号。<br>接下来m行，每行两个数a,b，表示点a和点b之间原来有一条边。<br>这个图不会有重边和自环。 </p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一行输出答案，四舍五入保留6位小数。 </p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>5 41 21 54 35 3</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>0.800000</code></pre><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>对于n个[0,1]之间的随机变量x1,x2,…,xn，第k小的那个的期望值是k/(n+1)。 </p><h3 id="题解前的扯淡"><a href="#题解前的扯淡" class="headerlink" title="题解前的扯淡"></a>题解前的扯淡</h3><p>贼NB的一道题,有两种做法,PoPoQQQ大爷的积分没看懂…于是写了概率DP<br>WQ刚了一天没刚出来,ZZH还在刚…<br>听WQ说dg说这种题刚不出来就弃了吧233333</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目让求的是最小生成树最大边的期望<br>我们设最小生成树的最大边的排名为$i$<br>设$F(i)$ 为最小生成树最大边排名为$i$的贡献<br>由提示可知$F(i) = \frac{i}{m+1}$<br>设$P(i)$为最小生成树最大边排名为$i$的概率<br>则$Ans=\sum_{i=1}^{m}{\frac{i*P(i)}{m+1}}$<br>然后就可以惊喜的发现这个$P(i)$并不好求<br>考虑转化<br>设$T(i)$为最小生成树最大边排名大于等于$i$的概率<br>那么$Ans=\frac{\sum_{i=1}^{m}{T(i)}}{m+1}$<br>至于为什么<br>首先根据定义$T(i)=\sum_{j=i}^{m}{P(j)}$<br>那么每个$P(i)$被累加的次数正好是$i$次<br>所以成立<br>但$T(i)$还是不好求<br>而最小生成树最大边的排名为$i$则说明排名小于$i$的边不能使图联通<br>设$M(i)$为排名小于i的边不能使图联通的概率<br>所以$T(i)=M(i)$<br>所以求$\frac{\sum_{i=0}^{m}{M(i)}}{m+1}$就是答案了<br>然后怎么还是不好求…<br>不联通的不好求,联通的还不好求么<br>终于进入$DP$的环节了….<br>由于$n$的范围很小,所以我们考虑状态压缩<br>设$f_{i,j}$为点集为$i$有j条边且点之间不联通的方案数<br>设$g_{i,j}$为点集为$i$有j条边且点之间联通的方案数<br>设$cnt_i$为点集为$i$的边的数量<br>从$cnt_i$条边里选$j$条边的方案数为$C_{cnt_i}^{j}$<br>而选出来$j$条边后这个点集只有联通和不联通两种状态<br>所以$f_{i,j}+g_{i,j}=C_{cnt_i}^{j}$<br>方程的转移可以通过选取这个联通块内的一个点,然后枚举那些点和这个点联通来转移<br>即为$f_{i,j}+=g_{S,k}*C_{cnt_{i-S}}^{j-k}$<br>然后根据$f_{i,j}+g_{i,j}=C_{cnt_i}^{j}$来转移$g$<br>最后统计答案的时候$\frac{\sum_{i=0}^{m}{\frac{f_{ALL,i}}{C_m^i}}}{m+1}$<br>终于完了QWQ….</p><pre><code class="C++">#include &lt;stdio.h&gt;#include &lt;iostream&gt;#define int long long #define fi first#define se second#define lowbit(_) ((_)&amp;(-_))typedef std::pair&lt;int,int&gt; pii;int f[1&lt;&lt;10][50],g[1&lt;&lt;10][50],n,m,full,cnt[1&lt;&lt;10],C[50][50];pii a[50];char xb[1&lt;&lt;15],*xs,*xt;#define getc() (xs == xt &amp;&amp; (xt = (xs = xb) + fread(xb,1,1&lt;&lt;15,stdin),xs == xt)?0:*xs++)inline int read() {    int x = 0, f = 1;    char ch = getc();    for (; ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;; ch = getc()) if (ch == &#39;-&#39;) f = -f;    for (; ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;; ch = getc()) x = x * 10 + (ch ^ 48);    return x * f;}void Pre_Work() {    for (int i = 0; i &lt;= 45; i++) {        C[i][0] = 1;        for (int j = 1; j &lt;= i; j++) C[i][j] = C[i-1][j] + C[i-1][j-1];    }}inline int Cnt_Bit(int S) {    int cnt = 0;    for (; S; S -= lowbit(S)) cnt ++;    return cnt;}signed main() {    Pre_Work();    n = read(); m = read(); full = (1 &lt;&lt; n) - 1;    for (int i = 1; i &lt;= m; i++) a[i].fi = read(),a[i].se = read();    for (int i = 1; i &lt;= full; i++)         for (int j = 1; j &lt;= m; j++)            if (((1&lt;&lt;a[j].fi-1) &amp; i) &amp;&amp; ((1&lt;&lt;a[j].se-1) &amp; i)) cnt[i] ++;    for (int i = 1; i &lt;= full; i++) {        if (Cnt_Bit(i) == 1) {            g[i][0] = 1;            continue;        }        int j = lowbit(i);        for (int S = (i - 1) &amp; i; S; S = (S - 1) &amp; i)            if (j &amp; S) {                for (int k = 0; k &lt;= cnt[S]; k++)                    for (int o = 0; o &lt;= cnt[i ^ S]; o++)                        f[i][o+k] += g[S][k] * C[cnt[i^S]][o];            }        for (int k = 0; k &lt;= cnt[i]; k++) g[i][k] = C[cnt[i]][k] - f[i][k];    }    double Ans = 0.0;    for (int i = 0; i &lt;= m; i++) Ans += f[full][i] / 1.0 / C[cnt[full]][i];    printf(&quot;%.6lf\n&quot;,Ans/(m+1));    return 0;}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/10/30/119/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Codeforces 671D Roads in Yusland</title>
      <link>https://blog.wildrage.xyz/2017/10/29/118/</link>
      <guid>https://blog.wildrage.xyz/2017/10/29/118/</guid>
      <pubDate>Sun, 29 Oct 2017 12:36:20 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;Mayor of Yusland just won the lott
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Mayor of Yusland just won the lottery and decided to spent money on something good for town. For example, repair all the roads in the town.</p><p>Yusland consists of n intersections connected by n - 1 bidirectional roads. One can travel from any intersection to any other intersection using only these roads.</p><p>There is only one road repairing company in town, named “RC company”. Company’s center is located at the intersection 1. RC company doesn’t repair roads you tell them. Instead, they have workers at some intersections, who can repair only some specific paths. The i-th worker can be paid ci coins and then he repairs all roads on a path from ui to some vi that lies on the path from ui to intersection 1.</p><p>Mayor asks you to choose the cheapest way to hire some subset of workers in order to repair all the roads in Yusland. It’s allowed that some roads will be repaired more than once.</p><p>If it’s impossible to repair all roads print  -1.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input contains two integers n and m (1 ≤ n, m ≤ 300 000) — the number of cities in Yusland and the number of workers respectively.</p><p>Then follow n−1 line, each of them contains two integers xi and yi (1 ≤ xi, yi ≤ n) — indices of intersections connected by the i-th road.</p><p>Last m lines provide the description of workers, each line containing three integers ui, vi and ci (1 ≤ ui, vi ≤ n, 1 ≤ ci ≤ 109). This means that the i-th worker can repair all roads on the path from vi to ui for ci coins. It’s guaranteed that vi lies on the path from ui to 1. Note that vi and ui may coincide.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>If it’s impossible to repair all roads then print  -1. Otherwise print a single integer — minimum cost required to repair all roads using “RC company” workers.</p><h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><pre><code>6 51 21 33 44 54 62 1 23 1 44 1 35 3 16 3 2</code></pre><h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><pre><code>8</code></pre><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>给一颗树，给定m对祖先节点关系。 每选用一对关系需要付出c的花费， 求用这些关系将所有边都覆盖的最小花费。  </p></blockquote><p>本题有 $nlog(n)$ 树DP做法请看<a href="http://cooook.coding.me/2017/10/29/CF671D/" target="_blank" rel="noopener">CF671D 树形DP+数据结构优化DP</a>  </p><p>这里我想说一下 $nlog(n)$ 的贪心做法</p><p>我们将修路转化为修点， 1 号点不用修<br>首先我们设$x_i$为第$i$个工人的使用次数。 那么显然$x_i \geq 0$<br>然设一个$A$矩阵如果第$j$个工人能覆盖到第$i$点那么$A_{i,j}=1$否则$A_{i,j}=0$<br>那么很显然对于$(\forall 2 &lt;= i &lt;= n)$都有$\sum_{j = 1}^{m}{A_{i,j}*x_j} &gt; 0$  </p><p>如果将这个过程看作矩阵乘， 将x看作m行1列的矩阵<br>那么<br>$$<br>        \begin{bmatrix}<br>        A_{1,1} &amp; A_{1,2} &amp; A_{1,3} &amp; \cdots &amp; A_{1,m} \\<br>        A_{2,1} &amp; A_{2,2} &amp; A_{2,3} &amp; \cdots &amp; A_{2,m} \\<br>        \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>        A_{n,1} &amp; A_{n,2} &amp; A_{n,3} &amp; \cdots &amp; A_{n,m} \\<br>        \end{bmatrix}<br>        \begin{bmatrix}<br>        x_{1,1} \\<br>        x_{1,2} \\<br>        x_{1,3} \\<br>        \vdots \\<br>        x_{1,m} \\<br>        \end{bmatrix} \geq<br>        \begin{bmatrix}<br>        1 \\<br>        1 \\<br>        1 \\<br>        \vdots \\<br>        1 \\<br>        \end{bmatrix}<br>$$</p><p>我们设右边的矩阵为$e$  </p><p>那么我们要求的答案为<br>$$ min\{\sum_{j=1}^{m}c_j * x_j\} $$  </p><p>如果将c看作矩阵则答案为<br>$min\{c^Tx\}$</p><p>那么我们发现他是一个线性规划问题。<br>我们可以考虑它的对偶问题。<br>由于对偶问题求得到函数值与原问题相等， 那么我们只需要求出对偶问题的答案。  </p><p>下面说一下对偶问题的构造  </p><blockquote><ol><li>给每个原始约束条件定义一个非负对偶变量$y_i (i=1,2,…,m)$;</li><li>使原问题的目标函数系数cj变为其对偶问题约束条件的右端常数</li><li>使原问题约束条件的右端常数bi变为其对偶问题目标函数的系数；</li><li>将原问题约束条件的系数矩阵转置，得到其对偶问题约束条件的系数矩阵；</li><li>改变约束条件不等号的方向，即将”=&lt;”改为”&gt;=”；</li><li>原问题“max”型，对偶问题为“min”型．反之亦然.</li></ol></blockquote><p>那么本题的对偶问题为 </p><p>$y &gt;= 0$<br>$A^Ty &lt;= c$</p><p>求$ max\{e^Ty\} $<br>$e$ 是上文中设的矩阵  </p><p>那么用人话说就是</p><p>每个点可以选多次一个工人的路径上的点的选择次数的和在$c_i$以内， 求所有点选择次数的最大和。  </p><p>我们可以贪心的由下向上选取。<br>用一个set启发式合并就可以了。  </p><p>时间复杂度$nlog(n)$ 常数略大。  </p><pre><code class="c++">// #pragma GCC optimize(&quot;O3&quot;)#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 300005;char xch,xB[1&lt;&lt;15],*xS=xB,*xTT=xB;#define getc() (xS==xTT&amp;&amp;(xTT=(xS=xB)+fread(xB,1,1&lt;&lt;15,stdin),xS==xTT)?0:*xS++)inline int read(){    int x=0,f=1;char ch=getc();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getc();}    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getc();}    return x*f;}struct edge{    int END, next;}v[MAXN &lt;&lt; 1];int first[MAXN], p;void add(int a, int b){    v[p].END = b;    v[p].next = first[a];    first[a] = p++;}struct data{    int v, cnt;    data(int c = 0, int cn = 0)    {        v = c, cnt = cn;    }    bool operator &lt; (const data &amp;a) const    {        return cnt == a.cnt ? v &lt; a.v : cnt &lt; a.cnt;    }};vector&lt;data&gt; Add[MAXN], rm[MAXN];set&lt;data&gt; st[MAXN];long long ans;int C[MAXN], Ad[MAXN];bool died;void dfs(int rt, int fa){    set&lt;data&gt;::iterator it;    for (int i = 0; i &lt; Add[rt].size(); i++)        st[rt].insert(Add[rt][i]);    for (int i = first[rt]; i != -1; i = v[i].next)    {        if (v[i].END == fa) continue;        dfs(v[i].END, rt);        if (died) return;        if (st[v[i].END].size() &gt; st[rt].size())            swap(st[v[i].END], st[rt]), swap(Ad[v[i].END], Ad[rt]);        for (it = st[v[i].END].begin(); it != st[v[i].END].end(); it++)            st[rt].insert(data(it-&gt;v, C[it-&gt;v] = it-&gt;cnt - Ad[v[i].END] + Ad[rt]));    }    for (int i = 0; i &lt; rm[rt].size(); i++)        st[rt].erase(data(rm[rt][i].v, C[rm[rt][i].v]));    if (rt == 1) return;    if (st[rt].empty()) {died = 1; return;}    ans += st[rt].begin()-&gt;cnt - Ad[rt];    Ad[rt] += st[rt].begin()-&gt;cnt - Ad[rt];}signed main(){    int n = read(), m = read(), a, b, c;    memset (first, -1, sizeof (first));    for (int i = 1; i &lt; n; i++)    {        a = read(), b = read();        add(a, b);        add(b, a);    }    for (int i = 1; i &lt;= m; i++)    {        a = read(), b = read(), c = read();        Add[a].push_back(data(i, c));        rm[b].push_back(data(i, c));        C[i] = c;    }    dfs(1, 0);    if (died) printf (&quot;-1&quot;);    else printf (&quot;%lld&quot;, ans);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/10/29/118/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 3167 [Heoi2013] Sao</title>
      <link>https://blog.wildrage.xyz/2017/10/28/117/</link>
      <guid>https://blog.wildrage.xyz/2017/10/28/117/</guid>
      <pubDate>Sat, 28 Oct 2017 12:20:20 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;WelcometoSAO(StrangeandAbnormalOnline)。这是一个VRMMORPG，含有n个关卡。但是，
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>WelcometoSAO(StrangeandAbnormalOnline)。这是一个VRMMORPG，含有n个关卡。但是，挑战不同关卡的顺序是一<br>个很大的问题。有n–1个对于挑战关卡的限制，诸如第i个关卡必须在第j个关卡前挑战，或者完成了第k个关卡才<br>能挑战第l个关卡。并且，如果不考虑限制的方向性，那么在这n–1个限制的情况下，任何两个关卡都存在某种程<br>度的关联性。即，我们不能把所有关卡分成两个非空且不相交的子集，使得这两个子集之间没有任何限制。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行，一个整数T，表示数据组数。对于每组数据，第一行一个整数n，表示关卡数。接下来n–1行，每行为“i<br>sign j”,其中$0≤i,j≤n–1$且$i≠j$，sign为“&lt;”或者“&gt;”，表示第i个关卡必须在第j个关卡前/后完成。<br>$T≤5, 1≤n≤1000$</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每个数据，输出一行一个整数，为攻克关卡的顺序方案个数，mod1,000,000,007输出。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><pre><code>5105 &gt; 85 &gt; 60 &lt; 19 &lt; 42 &gt; 55 &lt; 98 &lt; 19 &gt; 31 &lt; 7106 &gt; 72 &gt; 09 &lt; 05 &gt; 97 &gt; 00 &gt; 37 &lt; 81 &lt; 20 &lt; 4102 &lt; 01 &gt; 40 &gt; 59 &lt; 09 &gt; 31 &lt; 24 &gt; 69 &lt; 87 &gt; 1100 &gt; 95 &gt; 63 &gt; 68 &lt; 78 &gt; 40 &gt; 68 &gt; 58 &lt; 21 &gt; 8108 &lt; 38 &lt; 41 &gt; 31 &lt; 93 &lt; 72 &lt; 85 &gt; 25 &lt; 60 &lt; 9</code></pre><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><pre><code>25803960183452083336</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先做了<a href="https://www.wildrage.cf/2017/08/05/66/" target="_blank" rel="noopener">ALO</a>， 又做了SAO。<br>然后就突然想看刀剑了， 虽然看来好几遍了， 不过河北的省选真会玩儿。<br>什么时候来个GGO就好了。  </p><hr><p>回到这道题:</p><p>首先将本题转化为一个树上问题（这tm的不是显然吗）。<br>然后我们发现答案只与每对点的遍历数序有关。<br>那么我们定义$f[i][j]$为一$i$为根节点的子树中有$j$个比他小。<br>那么假设$i$的子节点$u$要求小于$i$<br>那么以$u$为根的子树中有可能有$[0, k - 1]$ 个数比$u$小<br>那么在考虑小于他的数的合并顺序，<br>由插板法得$C_{j}^{k}$<br>同理小于它的为$C_{size[i] + size[u] - j - 1}^{size[u] - k}$<br>综上转移方程为<br>$$f[i][j + k] = f[i][j] * \sum_{c=0}^{k-1}{f[u][c]} * C_{j + k}^{j} * C_{size[u] + size[i] - k - j - 1}^{size[u] - k}$$<br>大于与此类似</p><p>不知道为什么数组越界过来</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1005;const int MOD = 1000000007;inline int read(){    int x=0,f=1;char ch=getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}    return x*f;}struct edge{    int END, next, v;}v[MAXN &lt;&lt; 1];int first[MAXN], p;void add(int a, int b, int c){    v[p].END = b;    v[p].next = first[a];    v[p].v = c;    first[a] = p++;}long long f[MAXN][MAXN];long long g[MAXN];long long Sum[MAXN][MAXN];long long C[MAXN][MAXN];int size[MAXN];void dfs(int rt, int fa){    size[rt] = f[rt][0] = 1;    for (int i = first[rt]; i != -1; i = v[i].next)    {        if (v[i].END == fa) continue;        dfs(v[i].END, rt);        for (int j = 0; j &lt; size[rt] + size[v[i].END]; j++) g[j] = 0;        if (v[i].v == 1)            for (int j = 0; j &lt; size[rt]; j++)                for (int k = 0; k &lt;= size[v[i].END]; k++)                {                    long long tmp = f[rt][j] * Sum[v[i].END][k - 1] % MOD;                    long long rmp = C[j + k][j] * C[size[rt] + size[v[i].END] - k - j - 1][size[v[i].END] - k] % MOD;                    (g[j + k] += tmp * rmp % MOD) %= MOD;                }        else            for (int j = 0; j &lt; size[rt]; j++)                for (int k = 0; k &lt;= size[v[i].END]; k++)                {                    long long tmp = f[rt][size[rt] - j - 1] * (Sum[v[i].END][size[v[i].END] - 1] - Sum[v[i].END][size[v[i].END] - k - 1] + MOD) % MOD;                    long long rmp = C[j + k][j] % MOD * C[size[v[i].END] + size[rt] - k - j - 1][size[v[i].END] - k] % MOD;                    (g[size[rt] + size[v[i].END] - j - k - 1] += tmp * rmp % MOD) %= MOD;                }        size[rt] += size[v[i].END];        for (int j = 0; j &lt; size[rt]; j++) f[rt][j] = g[j];    }    Sum[rt][0] = f[rt][0];    for (int i = 1; i &lt; size[rt]; i++)        Sum[rt][i] = (Sum[rt][i - 1] + f[rt][i]) % MOD;}int main(){    int t = read();    C[0][0] = 1;        for (int i = 1; i &lt;= 1000; i++)    {        C[i][0] = 1;        for (int j = 1; j &lt;= i; j++)            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;    }    while (t--)    {        memset (size, 0, sizeof (size));        memset (Sum, 0, sizeof (Sum));        memset (f, 0, sizeof (f));        memset (first, -1, sizeof (first));        p = 0;        int n = read(), a, b;        char c[3];        for (int i = 1; i &lt; n; i++)        {            scanf (&quot;%d%s%d&quot;, &amp;a, c, &amp;b);            a++, b++;            if (c[0] == &#39;&gt;&#39;) add(a, b, 1), add(b, a, -1);            else add(a, b, -1), add(b, a, 1);        }        dfs(1, 0);        printf (&quot;%lld\n&quot;, Sum[1][n - 1]);    }    // while (1);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/10/28/117/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 3262 陌上花开 CDQ</title>
      <link>https://blog.wildrage.xyz/2017/10/25/116/</link>
      <guid>https://blog.wildrage.xyz/2017/10/25/116/</guid>
      <pubDate>Wed, 25 Oct 2017 13:29:20 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;有n朵花，每朵花有三个属性：花形(s)、颜色(c)、气味(m)，又三个整数表示。现要对每朵花评级，一朵花的级别是它拥有的美丽
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有n朵花，每朵花有三个属性：花形(s)、颜色(c)、气味(m)，又三个整数表示。现要对每朵花评级，一朵花的级别是它拥有的美丽能超过的花的数量。定义一朵花A比另一朵花B要美丽，当且仅当Sa&gt;=Sb,Ca&gt;=Cb,Ma&gt;=Mb。显然，两朵花可能有同样的属性。需要统计出评出每个等级的花的数量。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行为N,K (1 &lt;= N &lt;= 100,000, 1 &lt;= K &lt;= 200,000), 分别表示花的数量和最大属性值。<br>以下N行，每行三个整数si, ci, mi (1 &lt;= si, ci, mi &lt;= K)，表示第i朵花的属性</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>包含N行，分别表示评级为0…N-1的每级花的数量。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><pre><code>10 33 3 32 3 3 2 3 1 3 1 1 3 1 2 1 3 1 1 1 2 1 2 2 1 3 2 1 2 1</code></pre><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><pre><code>3130101001</code></pre><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>1 &lt;= N &lt;= 100,000, 1 &lt;= K &lt;= 200,000</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>三维偏序<br>将一个维度作为时间。  </p><p>比如我令 <strong>颜色(c)</strong> 为时间维。 </p><p>那么第一步将除时间(颜色)以外的一个维度排序，<br>比如说我这里将 <strong>花形(s)</strong> 排序</p><p>那么我们要保证这一维(花形) 时刻有序。</p><p>然后我们分治时间(颜色);</p><p>我选择的方法是暴力<code>sort</code>， 先递归。</p><p>那么在分治后左边的花型一定是小于右边的。 </p><p>所以只要将左右分别按时间排序， 对于每一个右边的值， 将左边时间比他小的更新到树状数组中。 然后查询第三维小于他的个数就可以更新答案了。  </p><p>一些具体的细节可以看代码实现</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 100005;const int M = 200005;struct data{    int s, c, m, pos, num, ans;    bool operator &lt; (const data &amp;a) const    {        if (s == a.s &amp;&amp; c == a.c) return m &lt; a.m;        if (s == a.s) return c &lt; a.c;        return s &lt; a.s;     }}a[N], b[N];const bool cmp(const data &amp;a, const data &amp;b){    if (a.c == b.c) a.m &lt; b.m;    return a.c &lt; b.c;}int Sum[M], cnt, Color[M], C;#define lowbit(_) ((_) &amp; (-_))void add(int x, int c){    for (int i = x; i &lt;= M; i += lowbit(i))    {        if (Color[i] != C) Sum[i] = 0;        Color[i] = C;        Sum[i] += c;    }}int Query(int x){    int ans = 0;    for (int i = x; i &gt; 0; i -= lowbit(i))    {        if (Color[i] == C)            ans += Sum[i];    }    return ans;}void CDQ(int l, int r){    if (l == r) return;    int mid = l + r &gt;&gt; 1;    CDQ(l, mid), CDQ(mid + 1, r);    sort(b + l, b + mid + 1, cmp);    sort(b + mid + 1, b + r + 1, cmp);    C++;    for (int j = mid + 1, i = l; j &lt;= r; j++)    {        for (; b[i].c &lt;= b[j].c &amp;&amp; i &lt;= mid; i++)            add(b[i].m, b[i].num);        b[j].ans += Query(b[j].m);    }}int main(){    int n, k;    scanf (&quot;%d%d&quot;, &amp;n, &amp;k);    for (int i = 1; i &lt;= n; i++){        scanf (&quot;%d%d%d&quot;, &amp;a[i].s, &amp;a[i].c, &amp;a[i].m);        a[i].pos = i;    }    sort(a + 1, a + n + 1);    for (int i = 1; i &lt;= n; i++)    {        if (a[i].c == a[i - 1].c &amp;&amp; a[i].s == a[i - 1].s &amp;&amp; a[i].m == a[i - 1].m)            b[cnt].num++;        else            b[++cnt] = a[i], b[cnt].num = 1;    }    // for (int i = 1; i &lt;= cnt; i++) printf (&quot;%d%c&quot;, b[i].pos, &quot; \n&quot;[i == cnt]);    CDQ(1, cnt);    // for (int i = 1; i &lt;= cnt; i++) printf (&quot;%d%c&quot;, b[i].ans, &quot; \n&quot;[i == cnt]);    // while(1);    static int Ans[N];    for (int i = 1; i &lt;= cnt; i++) Ans[b[i].ans + b[i].num - 1] += b[i].num;    for (int i = 0; i &lt; n; i++) printf (&quot;%d\n&quot;, Ans[i]);    // while (1);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/10/25/116/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 1176 [Balkan2007]Mokia CDQ</title>
      <link>https://blog.wildrage.xyz/2017/10/21/115/</link>
      <guid>https://blog.wildrage.xyz/2017/10/21/115/</guid>
      <pubDate>Sat, 21 Oct 2017 03:46:59 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;维护一个W*W的矩阵，初始值均为S.每次操作可以增加某格子的权值,或
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>维护一个W*W的矩阵，初始值均为S.每次操作可以增加某格子的权值,或询问某子矩阵的总权值.修改操作数M&lt;=160000,询问数Q&lt;=10000,W&lt;=2000000.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行两个整数,S,W;其中S为矩阵初始值;W为矩阵大小</p><p>接下来每行为一下三种输入之一(不包含引号):<br>“1 x y a”<br>“2 x1 y1 x2 y2”<br>“3”<br>输入1:你需要把(x,y)(第x行第y列)的格子权值增加a<br>输入2:你需要求出以左下角为(x1,y1),右上角为(x2,y2)的矩阵内所有格子的权值和,并输出<br>输入3:表示输入结束</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每个输入2,输出一行,即输入2的答案</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>0 41 2 3 32 1 1 3 31 2 2 22 2 2 3 43</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>35</code></pre><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 800005;struct Query{    int x, y, op, val, id, pos;    bool operator &lt; (const Query &amp;a) const    {        return x == a.x ? op &lt; a.op : x &lt; a.x;    }} Ask[MAXN], tmp[MAXN];int n, m, Ans[MAXN];#define lowbit(_) ((_)&amp;(-_))struct BIT{    int Sum[2000005];    void add(int x, int c)    {        for (int i = x; i &lt;= n; i += lowbit(i))            Sum[i] += c;    }    int Query(int x)    {        int ans = 0;        for (int i = x; i &gt; 0; i -= lowbit(i))            ans += Sum[i];        return ans;    }}bit;void add(){    int x1, y1, x2, y2;    scanf (&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);    ++Ans[0];    Ask[++m].pos = Ans[0], Ask[m].x = x1 - 1, Ask[m].y = y1 - 1, Ask[m].val = 1, Ask[m].op = 1;    Ask[++m].pos = Ans[0], Ask[m].x = x2    , Ask[m].y = y2    , Ask[m].val = 1, Ask[m].op = 1;    Ask[++m].pos = Ans[0], Ask[m].x = x1 - 1, Ask[m].y = y2    , Ask[m].val =-1, Ask[m].op = 1;    Ask[++m].pos = Ans[0], Ask[m].x = x2    , Ask[m].y = y1 - 1, Ask[m].val =-1, Ask[m].op = 1;}void CDQ(int l, int r){    if (l == r)        return;    int mid = l + r &gt;&gt; 1, l1 = l, l2 = mid + 1;    for (int i = l; i &lt;= r; i++)    {        if (Ask[i].id &lt;= mid &amp;&amp; !Ask[i].op)            bit.add(Ask[i].y, Ask[i].val);        if (Ask[i].id &gt; mid &amp;&amp; Ask[i].op)            Ans[Ask[i].pos] += Ask[i].val * bit.Query(Ask[i].y);    }    for (int i = l; i &lt;= r; i++)        if (Ask[i].id &lt;= mid &amp;&amp; !Ask[i].op)            bit.add(Ask[i].y, -Ask[i].val);    for (int i = l; i &lt;= r; i++)    {        if (Ask[i].id &lt;= mid)            tmp[l1++] = Ask[i];        else tmp[l2++] = Ask[i];    }    for (int i = l; i &lt;= r; i++)        Ask[i] = tmp[i];    CDQ(l, mid);    CDQ(mid + 1, r);    return;}int main(){    freopen(&quot;mokia.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;mokia.out&quot;, &quot;w&quot;, stdout);    int op;    scanf (&quot;%d%d&quot;, &amp;op, &amp;n);    while (1)    {        scanf (&quot;%d&quot;, &amp;op);        if (op == 1)        {            m++;            scanf (&quot;%d%d%d&quot;, &amp;Ask[m].x, &amp;Ask[m].y, &amp;Ask[m].val);        }        else if (op == 2)            add();        else break;    }    for (int i = 1; i &lt;= m; i++)        Ask[i].id = i;    sort(Ask + 1, Ask + m + 1);    CDQ(1 ,m);    for (int i = 1; i &lt;= Ans[0]; i++)        printf (&quot;%d\n&quot;, Ans[i]);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/10/21/115/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 2064 分裂 状压DP</title>
      <link>https://blog.wildrage.xyz/2017/10/21/114/</link>
      <guid>https://blog.wildrage.xyz/2017/10/21/114/</guid>
      <pubDate>Sat, 21 Oct 2017 00:23:31 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;背景： 和久必分，分久必和。。。 题目描述： 中国历史上上分分和和次
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>背景： 和久必分，分久必和。。。 题目描述： 中国历史上上分分和和次数非常多。。通读中国历史的WJMZBMR表示毫无压力。 同时经常搞OI的他把这个变成了一个数学模型。 假设中国的国土总和是不变的。 每个国家都可以用他的国土面积代替， 又两种可能，一种是两个国家合并为1个，那么新国家的面积为两者之和。 一种是一个国家分裂为2个，那么2个新国家的面积之和为原国家的面积。 WJMZBMR现在知道了很遥远的过去中国的状态，又知道了中国现在的状态，想知道至少要几次操作（分裂和合并各算一次操作），能让中国从当时状态到达现在的状态。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行一个数n1，表示当时的块数，接下来n1个数分别表示各块的面积。 第二行一个数n2，表示现在的块，接下来n2个数分别表示各块的面积。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一行一个数表示最小次数。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>1 63 1 2 3</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>2</code></pre><h3 id="数据范围："><a href="#数据范围：" class="headerlink" title="数据范围："></a>数据范围：</h3><p>对于100%的数据，n1,n2&lt;=10，每个数&lt;=50<br>对于30%的数据，n1,n2&lt;=6，</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>状压DP<br>首先可以知道用$n+m-2$次一定可以实现<br>所以我们考虑减少次数。<br>如果原集合能分出来一块与新集合中的一块大小相同。<br>那么这是一个子问题, 他的答案也是$n+m-2$<br>同样剩下的集合也是如此。 这样我们就把答案减小了2。<br>然后可以看出我们需要尽可能多的将集合分为几部分。 每部分对应相等。<br>这可以用状压DP来解决。<br>可以将新集合中所有值设为相反数， 这样就可以求和为0就可以了。  </p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int a[100];int S[(1 &lt;&lt; 20) + 1], f[(1 &lt;&lt; 20) + 1];int main(){    int n, m;    int cnt = 0;    scanf (&quot;%d&quot;, &amp;n);    for (cnt = 1; cnt &lt;= n; cnt++)        scanf (&quot;%d&quot;, &amp;a[cnt]);    scanf (&quot;%d&quot;, &amp;m);    n += m;    for (; cnt &lt;= n; cnt++)        scanf (&quot;%d&quot;, &amp;a[cnt]), a[cnt] = -a[cnt];    int N = (1 &lt;&lt; n) - 1;    for (int i = 1; i &lt;= N; i++)    {        int j = 0;        for (j = 1; j &lt;= n; j++)            if (i &amp; (1 &lt;&lt; (j - 1)))                break;        S[i] = S[i ^ (1 &lt;&lt; (j - 1))] + a[j];        for (j = 1; j &lt;= n; j++)            if (i &amp; (1 &lt;&lt; (j - 1)))                f[i] = max(f[i], f[i ^ (1 &lt;&lt; (j - 1))] + (!S[i]));    }    printf (&quot;%d&quot;, n - f[N] * 2);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/10/21/114/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 1972 [Sdoi2010]猪国杀</title>
      <link>https://blog.wildrage.xyz/2017/10/10/113/</link>
      <guid>https://blog.wildrage.xyz/2017/10/10/113/</guid>
      <pubDate>Tue, 10 Oct 2017 13:41:16 GMT</pubDate>
      <description>
      
        &lt;ul&gt;
&lt;li&gt;概述&lt;ul&gt;
&lt;li&gt;《猪国杀》是一种多猪牌类回合制游戏，一共有三种角色：主猪，忠猪，反猪。&lt;/li&gt;
&lt;li&gt;每局游戏主猪有且只有一只，忠猪和反猪可以有多只，每只猪扮演一种角色。
      
      </description>
      
      <content:encoded><![CDATA[<ul><li>概述<ul><li>《猪国杀》是一种多猪牌类回合制游戏，一共有三种角色：主猪，忠猪，反猪。</li><li>每局游戏主猪有且只有一只，忠猪和反猪可以有多只，每只猪扮演一种角色。<a id="more"></a></li></ul></li><li>游戏目的<ul><li>主猪（MP）：自己存活的情况下消灭所有的反猪。</li><li>忠猪（ZP）：不惜一切保护主猪，胜利条件与主猪相同。</li><li>反猪（FP）：杀死主猪。</li></ul></li><li>游戏过程<ul><li>游戏开始时候，每个玩家手里都会有 4 张牌，且体力上限和初始体力都是 4 。</li><li>开始游戏时，从主猪开始，按照逆时针方向（数据中就是按照编号从 1, 2, 3…n, 1… 的顺序）依次行动。</li><li>每个玩家自己的回合可以分为 4 个阶段<ul><li>摸牌阶段<ul><li>从牌堆顶部摸两张牌，依次放到手牌的最右边。</li></ul></li><li>出牌阶段<ul><li>你可以使用 0 张到任意张牌，每次使用牌的时候都使用最靠左的能够使用的牌。</li><li>当然，要满足如下规则<ul><li>如果没有猪哥连弩，每个出牌阶段只能使用一次“杀”来攻击。</li><li>任何牌被使用后被弃置（武器是装备上）。</li><li>被弃置的牌以后都不能再用，即与游戏无关。</li></ul></li></ul></li></ul></li></ul></li><li>各种牌介绍<ul><li>每张手牌用一个字母表示，字母代表牌的种类。</li><li>基本牌<ul><li>『桃(P)』<ul><li>在自己的回合内，如果自己的体力值不等于体力上限，那么使用一个桃可以为自己补充一点体力；否则不能使用桃。<br>桃只能对自己使用。</li><li>在自己的回合外，如果自己的血变为 0 或者更低，那么也可以使用。</li></ul></li><li>『杀(K)』<ul><li>在自己的回合内，对攻击范围内除自己以外的一名角色使用。</li><li>如果没有被『闪』抵消，则造成 1 点伤害。</li><li>无论有无武器，杀的攻击范围都是 1。</li></ul></li><li>『闪(D)』<ul><li>当你受到杀的攻击时，可以弃置一张闪来抵消杀的效果。</li></ul></li></ul></li><li>锦囊牌<ul><li>『决斗(F)』<ul><li>出牌阶段，对除自己以外任意一名角色使用，由目标角色先开始，自己和目标角色轮流弃置一张杀，首先没有杀可弃的一方受到1点伤害，另一方视为此伤害的来源。</li></ul></li><li>『南猪入侵(N)』<ul><li>出牌阶段，对除你以外所有角色使用，按逆时针顺序从使用者下家开始依次结算，除非弃置一张杀，否则受到1点伤害。</li></ul></li><li>『万箭齐发(W)』<ul><li>和南猪入侵类似，不过要弃置的不是杀而是闪。</li></ul></li><li>『无懈可击(J)』<ul><li>在目标锦囊生效前抵消其效果。</li><li>每次有一张锦囊即将生效时，从使用这张锦囊的猪开始，按照逆时针顺序，依次得到使用无懈可击的机会。</li><li>效果<ul><li>用于决斗时，决斗无效并弃置。</li><li>用于南猪入侵或万箭齐发时，当结算到某个角色时才能使用，当前角色不需弃置牌并且不会受到伤害（仅对一个角色产生效果）。</li><li>用于无懈可击时，成为目标的无懈可击被无效。</li></ul></li></ul></li></ul></li><li>装备牌<ul><li>『猪哥连弩(Z)』<ul><li>武器，攻击范围 1，出牌阶段你可以使用任意张杀。<br>同一时刻最多只能装一个武器。</li><li>如果先前已经有了一把武器，那么之后再装武器的话，会弃置以前的武器来装现在的武器。</li></ul></li></ul></li></ul></li><li>特殊事件及概念解释<ul><li>伤害来源<ul><li>杀、南猪入侵、万箭齐发的伤害来源均是使用该牌的猪。</li><li>决斗的伤害来源如上。</li></ul></li><li>距离<ul><li>两只猪的距离定义为沿着逆时针方向间隔的猪数 +1。即初始时 1 和 2 的距离为 1 ，但是 2 和 1 的距离就是 n - 1 。</li><li>注意一个角色的死亡会导致一些猪距离的改变。</li></ul></li><li>玩家死亡<ul><li>如果该玩家的体力降到 0 或者更低，并且自己手中没有足够的桃使得自己的体力值回到 1，那么就死亡了，死亡后所有的牌（装备区，手牌区）被弃置、</li></ul></li><li>奖励与惩罚<ul><li>反猪死亡时，最后一个伤害来源处（即使是反猪）立即摸三张牌。</li><li>忠猪死亡时，如果最后一个伤害来源是主猪，那么主猪所有装备牌、手牌被弃置。</li><li>注意，一旦达成胜利条件，游戏立刻结束，因此即使会摸 3 张牌或者还有牌可以用也不用执行了。</li></ul></li></ul></li><li>现在，我们已经知道每只猪的角色、手牌，还有牌堆初始情况，并且假设每个角色会按照如下的行为准则进行游戏，你需要做的就是告诉小猪 iPig 最后的结果。</li><li>几种行为<ul><li>献殷勤<ul><li>使用无懈可击挡下南猪入侵、万箭齐发、决斗。</li><li>使用无懈可击抵消表敌意。</li></ul></li><li>表敌意<ul><li>对某个角色使用杀、决斗。</li><li>使用无懈可击抵消献殷勤。</li></ul></li><li>跳忠<ul><li>即通过行动表示自己是忠猪。</li><li>跳忠行动就是对主猪或对某只已经跳忠的猪献殷勤，或者对某只已经跳反的猪表敌意。</li></ul></li><li>跳反<ul><li>即通过行动表示自己是反猪。</li><li>跳反行动就是对主猪或对某只已经跳忠的猪表敌意，或者对某只已经跳反的猪献殷勤。</li><li>忠猪不会跳反，反猪也不会跳忠。</li><li>不管是忠猪还是反猪，能够跳必然跳。</li></ul></li></ul></li><li>行动准则<ul><li>共性<ul><li>每个角色如果手里有桃且生命值未满，那么必然吃掉。</li><li>有南猪入侵、万箭齐发、必然使用。</li><li>有装备必然装上。</li><li>受到杀时，有闪必然弃置。</li><li>响应南猪入侵或者万箭齐发时候，有杀/闪必然弃置。</li><li>不会对未表明身份的猪献殷勤（包括自己）。</li></ul></li><li>特性<ul><li>主猪<ul><li>主猪会认为没有跳身份，且用南猪入侵/万箭齐发对自己造成伤害的猪是“类反猪”（没伤害到不算，注意“类反猪”并没有表明身份），如果之后跳了，那么主猪会重新认识这只猪。<br>对于每种表敌意的方式，对逆时针方向能够执行到的第一只“类反猪”或者已跳反猪表；如果没有，那么就不表敌意。<br>决斗时会不遗余力弃置杀。</li><li>如果能对已经跳忠的猪或自己献殷勤，那么一定献。</li><li>如果能够对已经跳反的猪表敌意，那么一定表。</li></ul></li><li>忠猪<ul><li>对于每种表敌意的方式，对逆时针方向能够执行到的第一只已经跳反的猪表；如果没有，那么就不表敌意。</li><li>决斗时，如果对方是主猪，那么不会弃置杀，否则，会不遗余力弃置杀。</li><li>如果有机会对主猪或者已经跳忠的猪献殷勤，那么一定献。</li></ul></li><li>反猪<ul><li>对于每种表敌意的方式，如果有机会则对主猪表，否则，对逆时针方向能够执行到的第一只已经跳忠的猪表；如果没有，那么就不表敌意。</li><li>决斗时会不遗余力弃置杀。</li><li>如果有机会对已经跳反的猪献殷勤，那么一定献。</li></ul></li></ul></li></ul></li><li>限于 iPig 只会用 P++ 语言写 A + B，他请你用 Pigcal(Pascal)、P(C) 或 P++(C++) 语言来帮他预测最后的结果。</li><li>输入<ul><li>第一行包含两个正整数n(2 &lt;= n &lt;= 10) 和m( m &lt;= 2000)，分别代表玩家数和牌堆中牌的数量。</li><li>接下来n行，每行5个字符串，依次表示对第i只猪的角色和初始4张手牌描述。</li><li>编号为1的肯定是主猪。</li><li>再接下来一行，一共m个字符串，按照从牌堆顶部到牌堆底部的顺序描述每张牌</li><li>所有的相邻的两个字符串都严格用1个空格隔开，行尾没有多余空格。​</li></ul></li><li>输出<ul><li>输出数据第一行包含一个字符串代表游戏结果。<ul><li>如果是主猪胜利<ul><li>那么输出“MP”</li><li>否则输出“FP”。</li></ul></li></ul></li><li>接下来n行，第i行是对第i只猪的手牌描述<ul><li>按照手牌从左往右的顺序输出</li><li>相邻两张牌用一个空格隔开，行末尾没有多余空格</li><li>如果这只猪已阵亡，那么只要输出“DEAD”即可。</li><li>注意如果要输出手牌而没有手牌的话，那么只需输出一个空行。</li></ul></li></ul></li><li><p>样例输入</p><p>  3 10<br>  MP D D F F<br>  ZP N N N D<br>  FP J J J J<br>  F F D D J J F F K D  </p></li><li><p>样例输出</p><p>  FP<br>  DEAD<br>  DEAD<br>  J J J J J D  </p></li></ul><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目就是题解</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;list&gt;#include &lt;cstdlib&gt;int n, m, T, D_F, Z_D_to_M;char C[2005];// #define Log 1namespace Pig{    bool Died[11];    struct Pig_data    {        /*        Id :            1: 主猪            2: 忠猪            3: 反猪        */        std::list&lt;char&gt; Card;        std::list&lt;char&gt;::iterator it, it2;        int Identity, Strength;        bool Equipped, Jump, Similar;        void init(int Id, char *s)        {            Strength = 4, Similar = 0;            Identity = Id;            if (Id == 1) Jump = 1;            for (int i = 1; i &lt;= 4; i++)                Card.push_back(s[i]);        }        void Print(int i)        {            it2 = Card.end();            if (it2 == Card.begin())             {                if(i != n)                    printf(&quot;\n&quot;);                return;            }            it2--;            for (it = Card.begin(); it != it2; it++)                printf(&quot;%c &quot;, *it);            printf(&quot;%c&quot;, *it2);            if(i != n) printf (&quot;\n&quot;);        }    }Pig[11];}namespace Card{    struct Card_Heap_data    {        char Card_Heap[2005];        int h, t;        void init(char *s, int Num)        {            t = Num;            h = 0;            for (int i = 1; i &lt;= Num; i++)                Card_Heap[i] = s[i];        }        char Get_Card()        {            if (h == t)                return Card_Heap[h];            else                return Card_Heap[++h];        }    }Card;}namespace Main{void Read_init(){    #ifdef Log        printf(&quot;===========================================\n Read Start\n=================================\n&quot;);    #endif    scanf(&quot;%d%d&quot;, &amp;::n ,&amp;::m);    char s[5], ID[4];    for (int i = 1; i &lt;= n; i++)    {        scanf (&quot;%s&quot;, ID);        for (int j = 1; j &lt;= 4; j++)            std::cin &gt;&gt; s[j];        if (ID[0] == &#39;M&#39;)            Pig::Pig[i].init(1, s);        else if (ID[0] == &#39;Z&#39;)            Pig::Pig[i].init(2, s);        else            Pig::Pig[i].init(3, s), T++;    }#ifdef Log    printf(&quot;===========================================\n Read Pig Succeed\n=================================\n&quot;);#endif    memset(Pig::Died, 0, sizeof(Pig::Died));    for (int i = 1; i &lt;= m; i++)        std::cin &gt;&gt; C[i];    #ifdef Log        printf(&quot;===========================================\n Read Card Succeed\n=================================\n&quot;);    #endif    Card::Card.init(C, m);#ifdef Log    printf(&quot;===========================================\nCard Init Succeed\n=================================\n&quot;);#endif}void Get_Card(int x, int t){#ifdef Log    printf(&quot;Pig %d Get %d Card\n&quot;, x, t);#endif    while (t--)    {        Pig::Pig[x].Card.push_back(Card::Card.Get_Card());    }}int nxt[11];int next(int x){    if (nxt[x] != 0) return nxt[x];    for (int i = x + 1; ; i++)    {        if (i == n + 1) i = 1;        if (!Pig::Died[i])             return nxt[x] = i;    }}std::list&lt;char&gt;::iterator it, it2, searchit, eraseit;bool Over(int &amp;W){    bool No_Fan = 1;    int now = 0;    if (Pig::Died[1]) return W = 1, 1;    else now = 1;    int Next_Pig = now;    do    {        if (Pig::Pig[Next_Pig].Identity == 3) No_Fan = 0;        Next_Pig = next(Next_Pig);    }while (Next_Pig != now);    if (No_Fan)        return W = 0, 1;    else        return 0;}bool Judge(int x, char c, int K_Num, int &amp;t){    if (c == &#39;P&#39;)     {        if (Pig::Pig[x].Strength != 4)            return t = x, 1;        else return 0;    }    else if (c == &#39;K&#39;)    {        if (K_Num &amp;&amp; !Pig::Pig[x].Equipped) return 0;        if (Pig::Pig[x].Identity == 1)        {            if (Pig::Pig[next(x)].Similar) return t = next(x), 1;            if (Pig::Pig[next(x)].Identity == 3 &amp;&amp; Pig::Pig[next(x)].Jump)                return t = next(x), 1;            else return 0;        }        else if (Pig::Pig[x].Identity == 2)        {            if (Pig::Pig[next(x)].Identity == 3 &amp;&amp; Pig::Pig[next(x)].Jump)                return t = next(x), 1;            else return 0;        }        else if (Pig::Pig[x].Identity == 3)        {            if ((Pig::Pig[next(x)].Identity == 1 || Pig::Pig[next(x)].Identity == 2) &amp;&amp; Pig::Pig[next(x)].Jump)                return t = next(x), 1;            else return 0;        }        else        {            printf (&quot;ERROR No Identity\n&quot;);        }    }     else if (c == &#39;D&#39;) return 0;    else if (c == &#39;F&#39;)    {        bool flag = 0;        int Next_Pig = next(x);        while (Next_Pig != x)        {            if (Pig::Pig[x].Identity == 1)            {                if (Pig::Pig[Next_Pig].Similar) return t = Next_Pig, 1;                if (Pig::Pig[Next_Pig].Identity == 3 &amp;&amp; Pig::Pig[Next_Pig].Jump)                    return t = Next_Pig, 1;                else goto Restart;            }            else if (Pig::Pig[x].Identity == 2)            {                if (Pig::Pig[Next_Pig].Identity == 3 &amp;&amp; Pig::Pig[Next_Pig].Jump)                    return t = Next_Pig, 1;                else goto Restart;            }            else if (Pig::Pig[x].Identity == 3)            {                if (Pig::Pig[Next_Pig].Identity == 1)                    return t = Next_Pig, 1;                else if (Pig::Pig[Next_Pig].Identity == 2 &amp;&amp; Pig::Pig[Next_Pig].Jump)                 {                    if (!flag) flag = 1, t = Next_Pig;                    goto Restart;                }                else goto Restart;            }            else            {                printf (&quot;ERROR No Identity\n&quot;);            }            Restart: Next_Pig = next(Next_Pig);        }        if (Pig::Pig[x].Identity == 3 &amp;&amp; flag) return 1;        else return 0;    }    else if (c == &#39;N&#39; || c == &#39;W&#39;)    {        return t = -1, 1;    }    else if (c == &#39;J&#39;)        return 0;    else if (c == &#39;Z&#39;)        return t = x, 1;    else    {        printf (&quot;ERROR in Card ID\n&quot;);        exit(0);        return 0;    }    return 0;}bool Have(char c, int t)// and erase{    #ifdef Log        printf(&quot;It&#39;s %d to return He have &quot;, t);        Pig::Pig[t].Print();    #endif    for (searchit = Pig::Pig[t].Card.begin(); searchit != Pig::Pig[t].Card.end(); searchit++)        if (*searchit == c)        {            #ifdef Log                printf(&quot;Pig %d Used %c\n&quot;, t, c);            #endif            return Pig::Pig[t].Card.erase(searchit), 1;        }    return 0;}bool Need_Wuxie(int x){    if (!Have(&#39;J&#39;, x)) return 0;    Pig::Pig[x].Jump = 1;    Pig::Pig[x].Similar = 0;    return 1;}bool Wuxie(int x, bool op){    int Next_Pig = x;    do    {        if ((op == 0 &amp;&amp; Pig::Pig[Next_Pig].Identity == 3) || (op == 1 &amp;&amp; Pig::Pig[Next_Pig].Identity != 3))        {            if (!Need_Wuxie(Next_Pig)) goto again;            if (!Wuxie(Next_Pig, op ^ 1)) return 1;            return 0;        }        again: Next_Pig = next(Next_Pig);    }while (Next_Pig != x);    return 0;}bool Okforwuxie(int x, int t){    if (!Pig::Pig[t].Jump) return 0;    if (Pig::Pig[t].Identity == 3) return Wuxie(x, 0);    else return Wuxie(x, 1);}void UseM(int x, char c, int t){    if (c == &#39;K&#39;)    {        #ifdef Log            printf(&quot;Pig %d use %c to %d\n&quot;, x, c, t);        #endif        if (Pig::Pig[t].Jump) Pig::Pig[x].Jump = 1;        if (!Have(&#39;D&#39;, t))        {            #ifdef Log                printf(&quot;Pig %d not have %c\n&quot;, t, &#39;D&#39;);            #endif // Log            Pig::Pig[t].Strength--;            #ifdef Log            printf(&quot;Pig %d HP = %d\n&quot;, t, Pig::Pig[t].Strength);            #endif // Log            if (Pig::Pig[t].Strength == 0)            {                if (!Have(&#39;P&#39;, t))                {                    #ifdef Log                    printf(&quot;Pig %d Died\n&quot;, t);                    #endif // Log                    Pig::Died[t] = 1;                    memset(nxt, 0, sizeof (nxt));                    if (Pig::Died[1] == 1) return;                    if (Pig::Pig[t].Identity == 2 &amp;&amp; Pig::Pig[x].Identity == 1)                     {                        Pig::Pig[x].Card.clear(), Pig::Pig[x].Equipped = 0;                        Z_D_to_M = 1;                    }                    if (Pig::Pig[t].Identity == 3)                     {                        D_F++;                        if (D_F == T) return;                        Get_Card(x, 3);                    }                }                else                    Pig::Pig[t].Strength = 1;            }        }        return;    }    else if (c == &#39;P&#39;)        return Pig::Pig[x].Strength++, void(0);    else if (c == &#39;F&#39;)    {        #ifdef Log            printf(&quot;Pig %d use %c to %d\n&quot;, x, c, t);        #endif        Pig::Pig[x].Jump = 1, Pig::Pig[x].Similar = 0;        if (Pig::Pig[x].Identity == 1 &amp;&amp; Pig::Pig[t].Identity == 2)         {            Pig::Pig[t].Strength--;            #ifdef Log            printf(&quot;Pig %d HP = %d\n&quot;, t, Pig::Pig[t].Strength);            #endif // Log            if (Pig::Pig[t].Strength == 0)            {                if (!Have(&#39;P&#39;, t))                {                    #ifdef Log                    printf(&quot;Pig %d Died\n&quot;, t);                    #endif // Log                    Pig::Died[t] = 1;                    memset(nxt, 0, sizeof (nxt));                    if (Pig::Died[1] == 1) return;                    if (Pig::Pig[t].Identity == 2 &amp;&amp; Pig::Pig[x].Identity == 1)                     {                        Pig::Pig[x].Card.clear(), Pig::Pig[x].Equipped = 0;                        Z_D_to_M = 1;                    }                    if (Pig::Pig[t].Identity == 3)                     {                        D_F++;                        if (D_F == T) return;                        Get_Card(t, 3);                    }                }                else                    Pig::Pig[t].Strength = 1;            }            return;        }        if (Okforwuxie(x, t)) return void(0);        while (1)        {            if (!Have(&#39;K&#39;, t))             {                Pig::Pig[t].Strength--;                #ifdef Log                printf(&quot;Pig %d HP = %d\n&quot;, t, Pig::Pig[t].Strength);                #endif // Log                if (Pig::Pig[t].Strength == 0)                {                    if (!Have(&#39;P&#39;, t))                    {                        #ifdef Log                        printf(&quot;Pig %d Died\n&quot;, t);                        #endif // Log                        Pig::Died[t] = 1;                        memset (nxt, 0, sizeof (nxt));                        if (Pig::Died[1] == 1) return;                        if (Pig::Pig[t].Identity == 2 &amp;&amp; Pig::Pig[x].Identity == 1)                         {                            Pig::Pig[x].Card.clear(), Pig::Pig[x].Equipped = 0;                            Z_D_to_M = 1;                        }                        if (Pig::Pig[t].Identity == 3)                         {                            D_F++;                            if (D_F == T) return;                            Get_Card(x, 3);                        }                    }                    else                        Pig::Pig[t].Strength = 1;                }                return;            }            if (!Have(&#39;K&#39;, x))            {                Pig::Pig[x].Strength--;                #ifdef Log                printf(&quot;Pig %d HP = %d\n&quot;, x, Pig::Pig[x].Strength);                #endif // Log                if (Pig::Pig[x].Strength == 0)                {                    if (!Have(&#39;P&#39;, x))                    {                        #ifdef Log                        printf(&quot;Pig %d Died\n&quot;, x);                        #endif // Log                        Pig::Died[x] = 1;                        memset (nxt, 0, sizeof (nxt));                        if (Pig::Died[1] == 1) return;                        if (Pig::Pig[x].Identity == 2 &amp;&amp; Pig::Pig[t].Identity == 1)                         {                            Pig::Pig[t].Card.clear(), Pig::Pig[t].Equipped = 0;                            Z_D_to_M = 1;                        }                        if (Pig::Pig[x].Identity == 3)                         {                            D_F++;                            if (D_F == T) return;                            Get_Card(t, 3);                            return;                        }                    }                    else                        Pig::Pig[x].Strength = 1;                }                return;            }        }    }    else if (c == &#39;N&#39;)    {        #ifdef Log        printf(&quot;Pig %d use %c to %d\n&quot;, x, c, t);        #endif        int Next_Pig = next(x);        do        {            if (Okforwuxie(x, Next_Pig)) goto END1;            if (!Have(&#39;K&#39;, Next_Pig))            {                Pig::Pig[Next_Pig].Strength--;                #ifdef Log                printf(&quot;Pig %d HP = %d\n&quot;, Next_Pig, Pig::Pig[Next_Pig].Strength);                #endif // Log                if (Pig::Pig[Next_Pig].Strength == 0)                {                    if (!Have(&#39;P&#39;, Next_Pig))                    {                        #ifdef Log                        printf(&quot;Pig %d Died\n&quot;, Next_Pig);                        #endif // Log                        memset (nxt, 0, sizeof (nxt));                        Pig::Died[Next_Pig] = 1;                        if (Pig::Died[1] == 1) return;                        if (Pig::Pig[Next_Pig].Identity == 2 &amp;&amp; Pig::Pig[x].Identity == 1)                         {                            Pig::Pig[x].Card.clear(), Pig::Pig[x].Equipped = 0;                            Z_D_to_M = 1;                        }                        if (Pig::Pig[Next_Pig].Identity == 3)                         {                            D_F++;                            if (D_F == T) return;                            Get_Card(x, 3);                        }                    }                    else                        Pig::Pig[Next_Pig].Strength = 1;                }                if (Pig::Pig[Next_Pig].Identity == 1 &amp;&amp; Pig::Pig[x].Jump == 0) Pig::Pig[x].Similar = 1;            }            END1:Next_Pig = next(Next_Pig);        }while (Next_Pig != x);        return;    }    else if (c == &#39;W&#39;)    {        #ifdef Log        printf(&quot;Pig %d use %c to %d\n&quot;, x, c, t);        #endif        int Next_Pig = next(x);        do        {            if (Okforwuxie(x, Next_Pig)) goto END2;            if (!Have(&#39;D&#39;, Next_Pig))            {                Pig::Pig[Next_Pig].Strength--;                #ifdef Log                printf(&quot;Pig %d HP = %d\n&quot;, Next_Pig, Pig::Pig[Next_Pig].Strength);                #endif // Log                if (Pig::Pig[Next_Pig].Strength == 0)                {                    if (!Have(&#39;P&#39;, Next_Pig))                    {                        #ifdef Log                        printf(&quot;Pig %d Died\n&quot;, Next_Pig);                        #endif // Log                        Pig::Died[Next_Pig] = 1;                        memset (nxt, 0, sizeof (nxt));                        if (Pig::Died[1] == 1) return;                        if (Pig::Pig[Next_Pig].Identity == 2 &amp;&amp; Pig::Pig[x].Identity == 1)                         {                            Pig::Pig[x].Card.clear(), Pig::Pig[x].Equipped = 0;                            Z_D_to_M = 1;                        }                        if (Pig::Pig[Next_Pig].Identity == 3)                         {                            D_F++;                            if (D_F == T) return;                            Get_Card(x, 3);                        }                    }                    else                        Pig::Pig[Next_Pig].Strength = 1;                }                if (Pig::Pig[Next_Pig].Identity == 1 &amp;&amp; Pig::Pig[x].Jump == 0) Pig::Pig[x].Similar = 1;            }            END2:Next_Pig = next(Next_Pig);        }while (Next_Pig != x);        return;    }    else if (c == &#39;Z&#39;)        return Pig::Pig[x].Equipped = 1, void(0);}void Use(int x, char c, int t){    UseM(x, c, t);    // printf(&quot;ERROR in Use at Identity, There is no Id in the Pig\n&quot;);}void Play(int x){    it = Pig::Pig[x].Card.begin();    int K_Num = 0;    int Y = D_F;    for (; it != Pig::Pig[x].Card.end(); it = it2)    {        int t = 0;        if (Judge(x, *it, K_Num, t))        {            #ifdef Log                printf(&quot;Pig %d Used %c to %d\n&quot;, x, *it, t);            #endif            Use(x, *it, t);            if (Z_D_to_M) return;            if (*it == &#39;K&#39;) K_Num++;            Pig::Pig[x].Card.erase(it);            it2 = Pig::Pig[x].Card.begin();            if (Pig::Died[1] == 1 || Pig::Died[x] == 1 || D_F == T) return;        }        else        {            it2 = it;            it2++;        }    }}void Run(){    int now = 1, W = 0;    while (!Over(W))    {    #ifdef Log        printf(&quot;It is %d Paly, It&#39;s Identity is %d &quot;, now, Pig::Pig[now].Identity);        if (Pig::Pig[now].Jump == 1)            printf(&quot;He Jumped\n&quot;);        else            printf(&quot;He not Jumped\n&quot;);    #endif // Log        Get_Card(now, 2);    #ifdef Log        printf(&quot;He has &quot;);        Pig::Pig[now].Print();    #endif        Play(now);        Z_D_to_M = 0;        now = next(now);    }    if (W == 0)    {        printf (&quot;MP\n&quot;);        for (int i = 1; i &lt;= n; i++)        {            if (Pig::Died[i])                printf(&quot;DEAD\n&quot;);            else                Pig::Pig[i].Print(i);        }    }    else    {        printf (&quot;FP\n&quot;);        for (int i = 1; i &lt;= n; i++)        {            if (Pig::Died[i])                printf(&quot;DEAD\n&quot;);            else                Pig::Pig[i].Print(i);        }    }}}int main(){    // freopen(&quot;kopk10.in&quot;, &quot;r&quot;, stdin);    // freopen(&quot;1.out&quot;, &quot;w&quot;, stdout);#ifdef Log    printf(&quot;======================================\n Start\n======================================\n&quot;);#endif    Main::Read_init();#ifdef Log    printf(&quot;Read Success\n\n&quot;);    printf(&quot;======================================\nGame Start\n\n&quot;);#endif    Main::Run();}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/10/10/113/#disqus_thread</comments>
    </item>
    
    <item>
      <title>集训小记</title>
      <link>https://blog.wildrage.xyz/2017/10/01/112/</link>
      <guid>https://blog.wildrage.xyz/2017/10/01/112/</guid>
      <pubDate>Sun, 01 Oct 2017 07:44:21 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;2017-10-1-Day1&quot;&gt;&lt;a href=&quot;#2017-10-1-Day1&quot; class=&quot;headerlink&quot; title=&quot;2017 - 10 - 1 Day1&quot;&gt;&lt;/a&gt;2017 - 10 - 1 Day1&lt;/h3&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="2017-10-1-Day1"><a href="#2017-10-1-Day1" class="headerlink" title="2017 - 10 - 1 Day1"></a>2017 - 10 - 1 Day1</h3><a id="more"></a><p>开坑<br>今天是集训的第一天， 上午就考了一场考试；<br>心中满怀希望，但又充满忐忑<br>我不知未来如何， 但希望过好今天  </p><p>今天的考试T1很明显是一道找规律的题目，但是因为一些问题，我好久才找到正确的公式。<br>这道题让我意识到基础的重要性， 因为本题用到了高精度， 也就是说， 如果没有高精度的基础， 做本题就无从谈起。<br>如果打一个高精度调上半天， 那考试就没得考了。 </p><p>然后T2是一道好题， 真的好， 这道题当场我并没有什么思路。 连暴力都没有想出来。  就骗了一点分完了。<br>然后考完试 听说输出m就有40。 真是个悲哀的故事。<br>正解是分类讨论， 情况很多。</p><p>最后T3也是一道思路好题；<br>看到n的范围， 一下子想到了状压， 但是在仔细一看题， 发现状压好像压不下。<br>想了想也没有办法， 正解是按深度状压 + dfs 来减少状态数。 真的没有见过这么压的， 学习了。</p><h3 id="2017-10-2-Day2"><a href="#2017-10-2-Day2" class="headerlink" title="2017 - 10 - 2 Day2"></a>2017 - 10 - 2 Day2</h3><p>集训的第二天了， 早上跟着物理奥赛的跑了个操。<br>发现信息奥赛的好像只有我来了， 一脸尴尬。。。<br>发现高三的竟然还起上课啊， 为他们默哀。<br>突然感觉自己不孤单了</p><p>今天上午的考试<br>T1一开始没看出来， 先做到T2， 做完之后想了想T1，发现如果把店转换成线段的话就很好解决了。</p><p>T2是一个裸的线段树。感觉复杂度不大对， 但是还是过了。</p><p>T3是到好题， 反正我考场上没做出来， 全场平均分1分。<br>考完后看题解。 觉得应该先找规律， 在去想怎么打。<br>其实规律就是一个杨辉三角， 累加就可以。 二分左右边界。 </p><p>今天是死在第三题上了， 还是思路不够开阔， 还有就是A了前两道题之后不太想想第三题了。</p><h3 id="2017-10-3-Day3"><a href="#2017-10-3-Day3" class="headerlink" title="2017 - 10 - 3 Day3"></a>2017 - 10 - 3 Day3</h3><p>早上逃了个操<br>反正下雨也没跑  </p><p>昨天晚上考了个试都不是什么难题<br>T1 直接结论 第一个为m第二个为m - 1, 之后就是m - 2的n - 2 次方<br>前面的小数特判一下就过了</p><p>T2 是一个简单的树DP 和概率充电器那题很想， 上下分别考虑。  </p><p>T3 读错题了。 其他的都没想错。 用平衡树维护翻转。然后并查集搞就好了</p><p>听说昨天晚上有人浪被逮了。。</p><h3 id="2017-10-4-Day4"><a href="#2017-10-4-Day4" class="headerlink" title="2017 - 10 - 4 Day4"></a>2017 - 10 - 4 Day4</h3><p>上午考了个试， AK了<br>做完后还有一个多小时， 好无聊的， 什么也干不了。<br>然后Rank1， 讲了题， 然后就放假了， 开心。<br>然后就办域名修好了。 蜜汁不能实名认证。  </p><h3 id="2017-10-5-Day5"><a href="#2017-10-5-Day5" class="headerlink" title="2017 - 10 - 5 Day5"></a>2017 - 10 - 5 Day5</h3><p>放假在家<br>下午就返校了</p><h3 id="2017-10-6-Day6"><a href="#2017-10-6-Day6" class="headerlink" title="2017 - 10 - 6 Day6"></a>2017 - 10 - 6 Day6</h3><p>该了昨天的题， 每一道是简单的。<br>T1 是一道线段树的题， 没想出来， 其实正解很暴力。 26次修改即可</p><p>T2 很神的一个DP 状态的定义和处理方法很巧， 先计算出结果，再让结果是正确的， 修正。</p><p>T3 一个Trie树上的题需要转化模型。 然后是一个DP 。 不是很难。</p><p>下午又考试。 </p><p>看到标题<img src="https://images-1254442371.image.myqcloud.com/Blog/2017-10-7-1.JPG" alt=""> 有点害怕。</p><p>但第一题是个水题， 打打就过了。</p><p>T2 杜教筛<br>额。。 不会啊。。<br>学习了一下，这道题还是不难的</p><p>T3 用线段树维护Treap 上的LCA， 又是迷一波<br>最长上升子序列。</p><h3 id="2017-10-7-Day7"><a href="#2017-10-7-Day7" class="headerlink" title="2017 - 10 - 7 Day7"></a>2017 - 10 - 7 Day7</h3><p>把昨天的题改完了。<br>下午考试<br>又是一个恐怖的标题 HEOI2016 Day0 试题 好怕<br>结果T1 是个水题</p><p>T2<br>读完题？什么玩意。<br>先打个暴力， 想了想DP 想到了60分的DP<br>结果打挂了， 好伤心。<br>正解<br>$ dp[i][j][k] $表示前i个字符，最长同色长度&lt;=j,最后一个字符是k。<br>$ s[i][j]=\sum_{k=1}^{m}dp[i][j][k] $<br>$ dp[i][j][k]=s[i-1][j]*g[i][i][k]-(s[i-j-1][j]-dp[i-j-1][j][k])*g[i-j][i][k] $<br>然后就可以DP了</p><p>T3<br>将集合分为重集合和轻集合。 轻集合暴力修改， 重集合打标记。<br>然后预处理搞一搞就出来了</p><h3 id="2017-10-8-Day8"><a href="#2017-10-8-Day8" class="headerlink" title="2017 - 10 - 8 Day8"></a>2017 - 10 - 8 Day8</h3><p>上午考试， 第三题被很多人水过了<br>正解好难啊啊啊啊啊啊啊啊啊啊。。。。  </p><p>T1 直接二分即可。 set  </p><p>T2 线段树， 和前几天做的一道题类似。 结果也没想出来。<br>    不过不是很难， 改一会就改完了</p><p>T3 真是恶心。。。<br><a href="https://github.com/HZoi-WildRage/OIcode/blob/master/Codes/HZOI/2017-10-8/Drink.cpp" target="_blank" rel="noopener">代码(github)</a><br>改了好久<br><a href="https://mubu.com/doc/1xT0WAONRA" target="_blank" rel="noopener">思路</a>  </p><p>这雨下了一天。。  </p><h3 id="2017-10-9-Day9"><a href="#2017-10-9-Day9" class="headerlink" title="2017 - 10 - 9 Day9"></a>2017 - 10 - 9 Day9</h3><p>没考好啊。。<br>T1 是个容斥原理， 几乎用了我全部的时间， 结果也没推出来。。  </p><p>T2 是个水题。。。 结果都没怎么做。 Tarjan 缩点 + DFS  </p><p>T3 没人改出来<br>打了一天的 猪国杀  </p><h3 id="2017-10-10-Day10"><a href="#2017-10-10-Day10" class="headerlink" title="2017 - 10 - 10 Day10"></a>2017 - 10 - 10 Day10</h3><p>那群被开回家的回来了<br>T1 将 m 用类似离散的方法搞一搞能出来  </p><p>T2 裸DP</p><p>T3 将后面的几位单独考虑转移就可以了。。  </p><p>猪国杀 终于过了</p><h3 id="2017-10-11-Day11"><a href="#2017-10-11-Day11" class="headerlink" title="2017 - 10 - 11 Day11"></a>2017 - 10 - 11 Day11</h3><p>T1, T2 都是水题<br>T3 改了好久</p><h3 id="2017-10-12-Day12"><a href="#2017-10-12-Day12" class="headerlink" title="2017 - 10 - 12 Day12"></a>2017 - 10 - 12 Day12</h3><p>两场啊啊啊<br>上午的题不可做， 不可改。 说是noi水平<br>下午的题到是不难  </p><h3 id="2017-10-13-Day13"><a href="#2017-10-13-Day13" class="headerlink" title="2017 - 10 - 13 Day13"></a>2017 - 10 - 13 Day13</h3><p>又是两场。。<br>上午也是不难， 第三题没找到规律<br>下午全场AK</p><h3 id="2017-10-14-Day14"><a href="#2017-10-14-Day14" class="headerlink" title="2017 - 10 - 14 Day14"></a>2017 - 10 - 14 Day14</h3><h3 id="2017-10-15-Day15"><a href="#2017-10-15-Day15" class="headerlink" title="2017 - 10 - 15 Day15"></a>2017 - 10 - 15 Day15</h3><h3 id="2017-10-16-Day16"><a href="#2017-10-16-Day16" class="headerlink" title="2017 - 10 - 16 Day16"></a>2017 - 10 - 16 Day16</h3><h3 id="2017-10-17-Day17"><a href="#2017-10-17-Day17" class="headerlink" title="2017 - 10 - 17 Day17"></a>2017 - 10 - 17 Day17</h3><h3 id="2017-10-18-Day18"><a href="#2017-10-18-Day18" class="headerlink" title="2017 - 10 - 18 Day18"></a>2017 - 10 - 18 Day18</h3><p>跳了好几天， 不太想更了<br>今天复习了一下 Tarjan<br>开始学2-SAT 有点懵</p><h3 id="2017-10-25-Day25"><a href="#2017-10-25-Day25" class="headerlink" title="2017 - 10 - 25 Day25"></a>2017 - 10 - 25 Day25</h3><p>又是好几天。。<br>总结一下这几天的情况<br>这几天脑子有点乱， 刷题也刷不动的样子。<br>考试的题一改改一天。<br>虽然也有好点的时候，但是心里还是苦啊。<br>CDQ好懵啊。。<br>感觉自己少学了好多东西。心累。</p><h6 id="未完待续。。。"><a href="#未完待续。。。" class="headerlink" title="未完待续。。。"></a>未完待续。。。</h6>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/10/01/112/#disqus_thread</comments>
    </item>
    
    <item>
      <title>后缀数组</title>
      <link>https://blog.wildrage.xyz/2017/09/26/111/</link>
      <guid>https://blog.wildrage.xyz/2017/09/26/111/</guid>
      <pubDate>Tue, 26 Sep 2017 11:43:34 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;后缀数组&quot;&gt;&lt;a href=&quot;#后缀数组&quot; class=&quot;headerlink&quot; title=&quot;后缀数组&quot;&gt;&lt;/a&gt;后缀数组&lt;/h2&gt;&lt;p&gt;详解 请参见 IOI2009 国家集训队论文&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h2><p>详解 请参见 IOI2009 国家集训队论文<br><a id="more"></a></p><h4 id="例3：不可重叠最长重复子串（pku1743）"><a href="#例3：不可重叠最长重复子串（pku1743）" class="headerlink" title="例3：不可重叠最长重复子串（pku1743）"></a>例3：不可重叠最长重复子串（pku1743）</h4><p><a href="http://poj.org/problem?id=1743" target="_blank" rel="noopener">题目链接</a>  </p><p>先二分答案，判断是否存在两个长度为 k 的子串是相同的，且不重叠。<br>对于每组后缀，判断后缀的sa值的最大值和最小值之差是否不小于k  </p><p>Code  </p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 20010;int buc[MAXN], wa[MAXN], wb[MAXN], n;int r[MAXN], sa[MAXN], Rank[MAXN], height[MAXN];void getheight(int n){    int i, j, k = 0;    for (i = 0; i &lt; n; i++)        Rank[sa[i]] = i;    for (i = 0; i &lt; n; height[Rank[i++]] = k)        for (k ? k-- : 0, j = sa[Rank[i] - 1]; r[i + k] == r[j + k]; k++)            ;    return;}bool cmp(int *c, int a, int b, int d){    return c[a] == c[b] &amp;&amp; c[a + d] == c[b + d];}void da(int n, int m = 320){    // for(int i=0;i&lt;n;i++)printf(&quot;%d  %d\n&quot;,i,r[i]);    int i, j, p, *x = wa, *y = wb, *t;    for (i = 0; i &lt; m; i++)        buc[i] = 0;    for (i = 0; i &lt; n; i++)        buc[x[i] = r[i]]++;    for (i = 1; i &lt; m; i++)        buc[i] += buc[i - 1];    for (i = n - 1; ~i; i--)        sa[--buc[x[i]]] = i;    for (j = 1, p = 1; p &lt; n; j *= 2, m = p)    {        for (i = n - j, p = 0; i &lt; n; i++)            y[p++] = i;        for (i = 0; i &lt; n; i++)            if (sa[i] &gt;= j)                y[p++] = sa[i] - j;        for (i = 0; i &lt; m; i++)            buc[i] = 0;        for (i = 0; i &lt; n; i++)            buc[x[y[i]]]++;        for (i = 1; i &lt; m; i++)            buc[i] += buc[i - 1];        for (i = n - 1; ~i; i--)            sa[--buc[x[y[i]]]] = y[i];        for (t = x, x = y, y = t, p = 1, x[sa[0]] = 0, i = 1; i &lt; n; i++)            x[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p - 1 : p++;    }    // for(int i=0;i&lt;n;i++)    //     printf(&quot;%d  %d\n&quot;,i,sa[i]);    getheight(n);    return;}bool Judge(int mid){    int Min = 0x3f3f3f3f, Max = -0x3f3f3f3f;    for (int i = 2; i &lt;= n; i++)    {        if (height[i] &lt; mid)            Min = 0x3f3f3f3f, Max = -0x3f3f3f3f;        else        {            Min = min(Min, min(sa[i - 1], sa[i]));            Max = max(Max, max(sa[i - 1], sa[i]));            if (Max - Min &gt; mid)                return 1;        }    }    return 0;}int a[MAXN];int main(){    while (~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)    {        for (int i = 0; i &lt; n; i++)            scanf(&quot;%d&quot;, &amp;a[i]);        n--;        for (int i = 0; i &lt; n; i++)            r[i] = a[i + 1] - a[i] + 88;        r[n] = 0;        da(n + 1);        int l = 0, r = (n &gt;&gt; 1) + 1, ans = 0;        while (l &lt; r)        {            int m = l + r &gt;&gt; 1;            if(Judge(m))                ans = m, l = m + 1;            else                r = m;        }        if (ans &gt;= 4) printf(&quot;%d\n&quot;, ans + 1);        else printf(&quot;0\n&quot;);    }}</code></pre><h4 id="例4：可重叠的-k-次最长重复子串（pku3261）"><a href="#例4：可重叠的-k-次最长重复子串（pku3261）" class="headerlink" title="例4：可重叠的 k 次最长重复子串（pku3261）"></a>例4：可重叠的 k 次最长重复子串（pku3261）</h4><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1717" target="_blank" rel="noopener">题目链接</a>  </p><p>先二分答案，然后将后缀分成若干组。判断有没有一个组的后缀个数不小于k。  </p><p>Code</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 2000005;int buc[MAXN], wa[MAXN], wb[MAXN], n, K;int r[MAXN], sa[MAXN], Rank[MAXN], height[MAXN];void GetHeight(int n){    int i, j, k = 0;    for (i = 0; i &lt; n; i++)        Rank[sa[i]] = i;    for (i = 0; i &lt; n; height[Rank[i++]] = k)        for (k ? k-- : 0, j = sa[Rank[i] - 1]; r[i + k] == r[j + k]; k++)            ;    return;}bool cmp(int *c, int a, int b, int d){    return c[a] == c[b] &amp;&amp; c[a + d] == c[b + d];}void da(int n, int m = 1000000){    int i, j, p, *x = wa, *y = wb, *t;    for (i = 0; i &lt; m; i++)        buc[i] = 0;    for (i = 0; i &lt; n; i++)        buc[x[i] = r[i]]++;    for (i = 1; i &lt; m; i++)        buc[i] += buc[i - 1];    for (i = n - 1; ~i; i--)        sa[--buc[x[i]]] = i;    for (j = 1, p = 1; p &lt; n; j *= 2, m = p)    {        for (i = n - j, p = 0; i &lt; n; i++)            y[p++] = i;        for (i = 0; i &lt; n; i++)            if (sa[i] &gt;= j)                y[p++] = sa[i] - j;        for (i = 0; i &lt; m; i++)            buc[i] = 0;        for (i = 0; i &lt; n; i++)            buc[x[y[i]]]++;        for (i = 1; i &lt; m; i++)            buc[i] += buc[i - 1];        for (i = n - 1; ~i; i--)            sa[--buc[x[y[i]]]] = y[i];        for (t = x, x = y, y = t, p = 1, x[sa[0]] = 0, i = 1; i &lt; n; i++)            x[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p - 1 : p++;    }    GetHeight(n);    return;}bool Judge(int mid){    int l = 0;    for (int i = 2; i &lt;= n; i++)    {        if (height[i] &lt; mid)            l = 0;        else        {            l++;            if(l + 1 &gt;= K) return 1;        }    }    return 0;}int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;K);    for (int i = 0; i &lt; n; i++)        scanf(&quot;%d&quot;, &amp;r[i]);    da(n + 1);    int l = 0, r = (n &gt;&gt; 1) + 1, ans = 0;    while (l &lt; r)    {        int mid = l + r &gt;&gt; 1;        if (Judge(mid))            ans = mid, l = mid + 1;        else            r = mid;    }    printf(&quot;%d&quot;, ans);}</code></pre><h6 id="未完待续。。。"><a href="#未完待续。。。" class="headerlink" title="未完待续。。。"></a>未完待续。。。</h6>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/09/26/111/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 2827 千山鸟飞绝 Treap</title>
      <link>https://blog.wildrage.xyz/2017/09/24/110/</link>
      <guid>https://blog.wildrage.xyz/2017/09/24/110/</guid>
      <pubDate>Sun, 24 Sep 2017 10:27:12 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;话说有一天doyouloveme和vfleaking到山里玩。谁知doyouloveme刚刚进山，所有的鸟儿竟被他的神犇气场给惊得全部飞走了。vfleaking顿时膜拜不已。&lt;br&gt;这时鸟王用鸟语说道：“!@#$%……?”安抚了一下众鸟的情绪。鸟王生性好斗，作出了一个决定——要排鸟布阵把刚才吓到它们的人类赶出山去。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>话说有一天doyouloveme和vfleaking到山里玩。谁知doyouloveme刚刚进山，所有的鸟儿竟被他的神犇气场给惊得全部飞走了。vfleaking顿时膜拜不已。<br>这时鸟王用鸟语说道：“!@#$%……?”安抚了一下众鸟的情绪。鸟王生性好斗，作出了一个决定——要排鸟布阵把刚才吓到它们的人类赶出山去。<br><a id="more"></a><br>每只鸟都有一个编号，都有一个威武值。每秒钟鸟王都会发一个命令，编号为v的鸟飞到(x,y)去（坐标系原点是山顶，坐标单位为鸟爪）。鸟飞得很快，一秒之内就飞到了，可以看作是瞬间移动。如果编号为v的鸟和编号为u的鸟某一时刻处在同一位置，它们就会互相鼓励，增加各自的士气值和团结值。一只鸟的士气值等于此刻与它处在同一位置的鸟中的威武值的最大值，团结值等于此刻与它处在同一位置的鸟的只数。如果每一时刻都没有鸟与它处在同一位置，则士气值和团结值都为0。要注意自己不能鼓励自己，计算士气值和团结值时不能算上自己。<br>t秒钟后，doyouloveme目测出了现在每只鸟的战斗力，于是感叹了一句：“不妙，我们得走了。”<br>正所谓团结的鸟儿一个顶俩，所以doyouloveme这样描述战斗力：一只鸟战斗力值等于它在0到t秒中士气值的最大值与团结值的最大值的乘积。注意不是乘积的最大值，而是最大值的乘积。<br>vfleaking很想知道现在每只鸟的战斗力，但是他当然不会啦，于是他把这个任务交给了你来完成。  </p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第一行一个数n，代表鸟的只数。（鸟王那家伙你可以完全忽视掉）<br>接下来n行，每行三个整数w,x,y描述每只鸟的威武值和初始坐标。第i+1行描述编号为i的鸟。<br>接下来一行有一个数t，代表经过时间ts。<br>接下来t行，每行三个整数v,x,y描述鸟王每秒的命令。  </p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>一共n行，每行一个数，代表每只鸟的战斗力。  </p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><pre><code>51 1 13 1 24 4 42 0 12 2 351 1 22 4 42 4 33 0 15 0 1</code></pre><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><pre><code>34688</code></pre><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>对于样例的解释：<br>首先5只鸟的位置为(1,1),(1,2),(4,4),(0,1),(2,3)，士气和团结值都是0。<br>鸟1飞到了(1,2)，于是鸟1和鸟2互相鼓励，鸟1士气变为3，鸟2士气变为1。鸟1鸟2的团结值变为1。<br>然后鸟2飞到(4,4)，与鸟3互相鼓励，鸟2士气变为4，鸟3士气变为3。鸟2与鸟3的团结值变为1。<br>鸟2然后飞到了(4,3)，一个没有鸟的地方。于是士气和团结值都变为了0。<br>接下来鸟3和鸟5都飞到了鸟4的位置，于是三只鸟互相鼓励，鸟4、鸟5士气变为4，鸟3士气仍为3。鸟3、鸟4、鸟5的团结值都变为2。<br>于是大家的战斗力：<br>鸟1：3 <em> 1 = 3<br>鸟2：4 </em> 1 = 4<br>鸟3：3 <em> 2 = 6<br>鸟4：4 </em> 2 = 8<br>鸟5：4 * 2 = 8<br>1≤n≤30000   0≤t≤300000<br>坐标范围为整数，且不超过INT_MIN~INT_MAX<br>威武值为不超过INT_MAX的非负整数。  </p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>哈希加Treap  </p><p>把每一个点Hash对应的一棵Treap上<br>在插入和删除的时候不断的打标记跟新<br>注意不要漏情况<br>在最后的时候要把所有的标记都推下去<br>然后就出来了<br>细节很多调了好久  </p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int Max_Morale[30005], Max_Solidarity[30005];struct Point{    int x, y;    Point(int a = 0, int b = 0)    {        x = a, y = b;    }    bool operator==(const Point &amp;a) const    {        return x == a.x &amp;&amp; y == a.y;    }};struct data{    int x, ID;    data(int a = 0, int b = 0)    {        x = a, ID = b;    }    bool operator&gt;(const data &amp;a) const    {        return x == a.x ? ID &gt; a.ID : x &gt; a.x;    }    bool operator&lt;=(const data &amp;a) const    {        return !(*this &gt; a);    }};struct Treap{    struct Node    {        int s, key, Max_Num, Max_Size;        data x;        Node *ch[2];        Node(data sa)        {            ch[0] = ch[1] = NULL;            s = 1, x = sa, key = rand();            Max_Num = Max_Size = 0;        }#define size(_) ((_) ? (_)-&gt;s : 0)        void Pushup()        {            s = size(ch[0]) + size(ch[1]) + 1;        }        void Pushdown()        {            if (ch[0])            {                ch[0]-&gt;Max_Num = max(ch[0]-&gt;Max_Num, Max_Num);                ch[0]-&gt;Max_Size = max(ch[0]-&gt;Max_Size, Max_Size);                Max_Morale[ch[0]-&gt;x.ID] = max(Max_Morale[ch[0]-&gt;x.ID], ch[0]-&gt;Max_Num);                Max_Solidarity[ch[0]-&gt;x.ID] = max(Max_Solidarity[ch[0]-&gt;x.ID], ch[0]-&gt;Max_Size);            }            if (ch[1])            {                ch[1]-&gt;Max_Num = max(ch[1]-&gt;Max_Num, Max_Num);                ch[1]-&gt;Max_Size = max(ch[1]-&gt;Max_Size, Max_Size);                Max_Morale[ch[1]-&gt;x.ID] = max(Max_Morale[ch[1]-&gt;x.ID], ch[1]-&gt;Max_Num);                Max_Solidarity[ch[1]-&gt;x.ID] = max(Max_Solidarity[ch[1]-&gt;x.ID], ch[1]-&gt;Max_Size);            }            Max_Num = Max_Size = 0;        }    } * root;    Treap()    {        root = NULL;    }    Node *Merge(Node *A, Node *B)    {        if (!A)            return B;        if (!B)            return A;        if (A-&gt;key &lt; B-&gt;key)        {            A-&gt;Pushdown();            A-&gt;ch[1] = Merge(A-&gt;ch[1], B);            A-&gt;Pushup();            return A;        }        else        {            B-&gt;Pushdown();            B-&gt;ch[0] = Merge(A, B-&gt;ch[0]);            B-&gt;Pushup();            return B;        }    }    typedef pair&lt;Node *, Node *&gt; DNode;    DNode Split(Node *rt, int k)    {        if (!rt)            return DNode(NULL, NULL);        DNode o;        rt-&gt;Pushdown();        if (size(rt-&gt;ch[0]) &gt;= k)        {            o = Split(rt-&gt;ch[0], k);            rt-&gt;ch[0] = o.second;            rt-&gt;Pushup();            o.second = rt;        }        else        {            o = Split(rt-&gt;ch[1], k - size(rt-&gt;ch[0]) - 1);            rt-&gt;ch[1] = o.first;            rt-&gt;Pushup();            o.first = rt;        }        return o;    }    Node *kth(int k)    {        DNode x = Split(root, k - 1);        DNode y = Split(x.second, 1);        Node *ans = y.first;        root = Merge(Merge(x.first, ans), y.second);        return ans;    }    int Rank(Node *rt, data x)    {        if (!rt)            return 0;        return x &lt;= rt-&gt;x ? Rank(rt-&gt;ch[0], x) : Rank(rt-&gt;ch[1], x) + size(rt-&gt;ch[0]) + 1;    }    void Insert(data x)    {        int k = Rank(root, x);        if (root)        {            root-&gt;Max_Size = max(root-&gt;Max_Size, size(root));            root-&gt;Max_Num = max(root-&gt;Max_Num, x.x);            Max_Morale[root-&gt;x.ID] = max(root-&gt;Max_Num, Max_Morale[root-&gt;x.ID]);            Max_Solidarity[root-&gt;x.ID] = max(root-&gt;Max_Size, Max_Solidarity[root-&gt;x.ID]);        }        DNode y = Split(root, k);        Node *n = new Node(x);        root = Merge(Merge(y.first, n), y.second);    }    void remove(data x)    {        int k = Rank(root, x);        DNode a = Split(root, k);        DNode b = Split(a.second, 1);        delete b.first;        root = Merge(a.first, b.second);    }};#define Hash_MOD 76543#define Hash_MOD_x 9991#define Hash_MOD_y 7307int p = 0;struct Hash_Table{    int first[76545];    struct Link    {        Treap *rt;        Point t;        int next;    } v[400000];    Hash_Table()    {        memset(first, -1, sizeof(first));    }    void Push(int u, Point now, Treap *x)    {        v[p].rt = x;        v[p].t = now;        v[p].next = first[u];        first[u] = p++;    }    Treap *&amp;operator[](Point x)    {        int Hash = (((x.x % Hash_MOD_x) + Hash_MOD_x) % Hash_MOD_x) * (((x.y % Hash_MOD_y) + Hash_MOD_y) % Hash_MOD_y) % Hash_MOD;        for (int i = first[Hash]; i != -1; i = v[i].next)            if (v[i].t == x)                return v[i].rt;        Push(Hash, x, new Treap);        return v[first[Hash]].rt;    }} Hash;#define X(_) ((_) ? (_)-&gt;x : 0)Point bird[30005];int Num[30005];int main(){    int n;    scanf(&quot;%d&quot;, &amp;n);    int a, b, c;    for (int i = 1; i &lt;= n; i++)    {        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);        Max_Morale[i] = max(Max_Morale[i], X(Hash[Point(b, c)]-&gt;kth(size(Hash[Point(b, c)]-&gt;root))).x);        Max_Solidarity[i] = max(Max_Solidarity[i], size(Hash[Point(b, c)]-&gt;root));        Hash[Point(b, c)]-&gt;Insert(data(a, i));        bird[i] = Point(b, c);        Num[i] = a;    }    int m;    scanf(&quot;%d&quot;, &amp;m);    for (int i = 1; i &lt;= m; i++)    {        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);        Hash[bird[a]]-&gt;remove(data(Num[a], a));        Max_Morale[a] = max(Max_Morale[a], X(Hash[Point(b, c)]-&gt;kth(size(Hash[Point(b, c)]-&gt;root))).x);        Max_Solidarity[a] = max(Max_Solidarity[a], size(Hash[Point(b, c)]-&gt;root));        Hash[Point(b, c)]-&gt;Insert(data(Num[a], a));        bird[a] = Point(b, c);    }    for (int i = 1; i &lt;= n; i++)        Hash[bird[i]]-&gt;remove(data(Num[i],i));    for (int i = 1; i &lt;= n; i++)        printf(&quot;%lld\n&quot;, (long long)Max_Morale[i] * Max_Solidarity[i]);    // while(1);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/09/24/110/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 3211 花神游历各国</title>
      <link>https://blog.wildrage.xyz/2017/09/19/109/</link>
      <guid>https://blog.wildrage.xyz/2017/09/19/109/</guid>
      <pubDate>Tue, 19 Sep 2017 11:09:52 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2017/09/19/59c0fb3aab2fe.jpg&quot; alt=&quot;1(16).jpg&quot;&gt;&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p><img src="https://i.loli.net/2017/09/19/59c0fb3aab2fe.jpg" alt="1(16).jpg"><br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p><img src="https://i.loli.net/2017/09/19/59c0fb305a23a.jpg" alt="2(5).jpg">  </p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>每次x=1时，每行一个整数，表示这次旅行的开心度</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>41 100 5 551 1 22 1 21 1 22 2 31 1 4</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>1011111</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>本题和<a href="https://www.wildrage.cf/2017/07/13/34/" target="_blank" rel="noopener">上帝造题的七分钟</a>是一样的  </p><p>但我的程序没有过啊<br>打的比较傻  </p><p>其实只要维护一个值就可以了</p><p>用一个flag标记是否不变</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;#ifndef LL#define LL long long#endif#define lch l, m, rt &lt;&lt; 1#define rch m + 1, r, rt &lt;&lt; 1 | 1const int N = 100005;LL Sum[N &lt;&lt; 2];bool flag[N &lt;&lt; 2];void PushUp(int rt){    Sum[rt] = Sum[rt &lt;&lt; 1] + Sum[rt &lt;&lt; 1 | 1];    flag[rt] = flag[rt &lt;&lt; 1] &amp; flag[rt &lt;&lt; 1 | 1];}void buildtree(int l, int r, int rt){    if(l == r)    {        scanf(&quot;%lld&quot;, &amp;Sum[rt]);        if(Sum[rt] &lt;= 1)            flag[rt] = 1;        return;    }    int m = l + r &gt;&gt; 1;    buildtree(lch);    buildtree(rch);    PushUp(rt);}void Update(int L, int R, int l, int r, int rt){    if(flag[rt])        return;    if(l == r)    {        Sum[rt] = sqrt(Sum[rt]);        if(Sum[rt] &lt;= 1)            flag[rt] = 1;        return;    }    int m = l + r &gt;&gt; 1;    if (L &lt;= m) Update(L, R, lch);    if (R &gt; m) Update(L, R, rch);    PushUp(rt);}LL Query(int L, int R, int l, int r, int rt){    if(L &lt;= l &amp;&amp; R &gt;= r)        return Sum[rt];    int m = l + r &gt;&gt; 1;    LL ans = 0;    if (L &lt;= m) ans += Query(L, R, lch);    if (R &gt; m) ans += Query(L, R, rch);    return ans;}int main(){    int n;    scanf(&quot;%d&quot;, &amp;n);    buildtree(1, n, 1);    int m;    scanf(&quot;%d&quot;, &amp;m);    while (m--)    {        int op, l, r;        scanf(&quot;%d%d%d&quot;, &amp;op, &amp;l, &amp;r);        if(l &gt; r)            swap(l, r);        if (op == 1)        {            printf(&quot;%lld\n&quot;, Query(l, r, 1, n, 1));        }        else            Update(l, r, 1, n, 1);    }}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/09/19/109/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 1770 [Usaco2009 Nov]lights 燈 折半搜索</title>
      <link>https://blog.wildrage.xyz/2017/09/17/108/</link>
      <guid>https://blog.wildrage.xyz/2017/09/17/108/</guid>
      <pubDate>Sun, 17 Sep 2017 13:09:37 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;贝希和她的闺密们在她们的牛棚中玩游戏。但是天不从人愿，突然，牛棚的电源跳闸了，所有的灯都被关闭了。贝希是一个很胆小的女生，在伸手不见拇指的无尽的黑暗中，她感到惊恐，痛苦与绝望。她希望您能够帮帮她，把所有的灯都给重新开起来！她才能继续快乐地跟她的闺密们继续玩游戏！&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>贝希和她的闺密们在她们的牛棚中玩游戏。但是天不从人愿，突然，牛棚的电源跳闸了，所有的灯都被关闭了。贝希是一个很胆小的女生，在伸手不见拇指的无尽的黑暗中，她感到惊恐，痛苦与绝望。她希望您能够帮帮她，把所有的灯都给重新开起来！她才能继续快乐地跟她的闺密们继续玩游戏！<br><a id="more"></a><br>牛棚中一共有N（1 &lt;= N &lt;= 35）盏灯，编号为1到N。这些灯被置于一个非常复杂的网络之中。有M（1 &lt;= M &lt;= 595）条很神奇的无向边，每条边连接两盏灯。每盏灯上面都带有一个开关。当按下某一盏灯的开关的时候，这盏灯本身，还有所有有边连向这盏灯的灯的状态都会被改变。状态改变指的是：当一盏灯是开着的时候，这盏灯被关掉；当一盏灯是关着的时候，这盏灯被打开。问最少要按下多少个开关，才能把所有的灯都给重新打开。数据保证至少有一种按开关的方案，使得所有的灯都被重新打开。</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>＊第一行：两个空格隔开的整数：N和M。</p><p>＊第二到第M+1行：每一行有两个由空格隔开的整数，表示两盏灯被一条无向边连接在一起。没有一条边会出现两次。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>第一行：一个单独的整数，表示要把所有的灯都打开时，最少需要按下的开关的数目。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><pre><code>5 61 21 34 23 42 55 3</code></pre><p>輸入細節：</p><p>一共有五盞燈。燈1、燈4和燈5都連接著燈2和燈3。</p><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><pre><code>3</code></pre><p>輸出細節：</p><p>按下在燈1、燈4和燈5上面的開關。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>【折半搜索】<br>将需要搜索的元素分为不关联的两个部分，分别搜索</p><p>在本题中<br>N的范围有35如果直接搜的话$2^35$会T的很惨<br>所以我们将N分为前后两部分<br>现将前mid个搜出来，记录每个状态集合的最小的答案<br>之后出来后mid + 1到n搜完后加上他的补集跟新答案</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;long long A[36], full, bin[37];int Min = 0x3f, n, m;map&lt;long long, int&gt; Mp;void dfs1(int x, long long now, int k){    if(x == m + 1)    {        if(now == full)            Min = min(k, Min);        int t = Mp[now];        if(!t || t &gt; k)            Mp[now] = k;        return;    }    dfs1(x + 1, now, k);    dfs1(x + 1, now^A[x], k + 1);}void dfs2(int x, long long now, int k){    if(x == n + 1)    {        if(now == full)            Min = min(k, Min);        int t = Mp[full - now];        if(!t)            return;        Min = min(t + k, Min);        return;    }    dfs2(x + 1, now, k);    dfs2(x + 1, now^A[x], k + 1);}int main(){    // freopen(&quot;lights.in&quot;,&quot;r&quot;,stdin);    // freopen(&quot;lights.out&quot;,&quot;w&quot;,stdout);    int c;    scanf(&quot;%d%d&quot;, &amp;n, &amp;c);    bin[1] = 1;    for (int i = 2; i &lt; 37; i++)        bin[i] = bin[i - 1] &lt;&lt; 1;    int a, b;    for (int i = 1; i &lt;= c; i++)    {        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);        A[a] += bin[b];        A[b] += bin[a];    }    for (int i = 1; i &lt;= n; i++)        A[i] += bin[i];    full = bin[n + 1] - 1;    m = n &gt;&gt; 1;    dfs1(1, 0, 0);    dfs2(m + 1, 0, 0);    printf(&quot;%d&quot;, Min);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/09/17/108/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[NOIP2004] 虫食算</title>
      <link>https://blog.wildrage.xyz/2017/09/17/107/</link>
      <guid>https://blog.wildrage.xyz/2017/09/17/107/</guid>
      <pubDate>Sun, 17 Sep 2017 08:42:37 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;所谓虫食算，就是原先的算式中有一部分被虫子啃掉了，需要我们根据剩下的数字来判定被啃掉的字母。来看一个简单的例子：&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>所谓虫食算，就是原先的算式中有一部分被虫子啃掉了，需要我们根据剩下的数字来判定被啃掉的字母。来看一个简单的例子：<br><a id="more"></a></p><pre><code>43#98650#45+ 8468#663344445506978</code></pre><p>其中#号代表被虫子啃掉的数字。根据算式，我们很容易判断：第一行的两个数字分别是5和3，第二行的数字是5。<br>现在，我们对问题做两个限制：<br>首先，我们只考虑加法的虫食算。这里的加法是N进制加法，算式中三个数都有N位，允许有前导的0。<br>其次，虫子把所有的数都啃光了，我们只知道哪些数字是相同的。我们将相同的数字用相同的字母表示，不同的数字用不同的字母表示。如果这个算式是N进制的，我们就取英文字母表中的前N个大写字母来表示这个算式中的0到N-1这N个不同的数字（但是这N个字母并不一定顺序地代表0到N-1）。输入数据保证N个字母分别至少出现一次。</p><pre><code>BADC+ CBDADCCC</code></pre><p>上面的算式是一个4进制的算式。很显然，我们只要让ABCD分别代表0123，便可以让这个式子成立了。你的任务是，对于给定的N进制加法算式，求出N个不同的字母分别代表的数字，使得该加法算式成立。输入数据保证有且仅有一组解。</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>包含4行。第一行有一个正整数N（N &lt;= 26），后面的3行每行有一个由大写字母组成的字符串，分别代表两个加数以及和。这3个字符串左右两端都没有空格，从高位到低位，并且恰好有N位。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>包含一行。在这一行中，应当包含唯一的那组解。解是这样表示的：输出N个数字，分别表示A，B，C……所代表的数字，相邻的两个数字用一个空格隔开，不能有多余的空格。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><pre><code>5ABCEDBDACEEBBAA</code></pre><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><pre><code>1 0 3 4 2</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>从后向前从大到小倒着搜<br>分8种情况讨论<br>打的是真爽  </p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;using namespace std;char a[30], b[30], c[30];bool mark[30];int map[300], n, ans;void dfs(int pos, int y){    ans++;    //printf(&quot;%d\n&quot;, ans);    if(pos == 0)    {        for (int i = &#39;A&#39;; i &lt; &#39;A&#39; + n; i++)            printf(&quot;%d &quot;,map[i]);        exit(0);    }    if(map[a[pos]] != -1 &amp;&amp; map[b[pos]] != -1 &amp;&amp; map[c[pos]] != -1)    {        if((map[a[pos]] + map[b[pos]] + y) % n != map[c[pos]])            return;        else            dfs(pos - 1, (map[a[pos]] + map[b[pos]] + y) / n);    }    else if (map[a[pos]] != -1 &amp;&amp; map[b[pos]] != -1)    {        if(mark[(map[a[pos]] + map[b[pos]] + y) % n])            return;        else        {            map[c[pos]] = (map[a[pos]] + map[b[pos]] + y) % n;            mark[(map[a[pos]] + map[b[pos]] + y) % n] = 1;            dfs(pos - 1, (map[a[pos]] + map[b[pos]] + y) / n);            mark[(map[a[pos]] + map[b[pos]] + y) % n] = 0;            map[c[pos]] = -1;        }    }    else if (map[a[pos]] != -1 &amp;&amp; map[c[pos]] != -1)    {        int now = map[c[pos]] + n - y - map[a[pos]];        if(mark[now % n])            return;        map[b[pos]] = now % n;        mark[now % n] = 1;        dfs(pos - 1, (now % n) == now ? 1 : 0);        map[b[pos]] = -1;        mark[now % n] = 0;    }    else if (map[b[pos]] != -1 &amp;&amp; map[c[pos]] != -1)    {        int now = map[c[pos]] + n - y - map[b[pos]];        if(mark[now % n])            return;        map[a[pos]] = now % n;        mark[now % n] = 1;        dfs(pos - 1, (now % n) == now ? 1 : 0);        map[a[pos]] = -1;        mark[now % n] = 0;    }    else if(map[a[pos]] != -1)    {        for (int i = 0; i &lt; n; i++)            if(!mark[i] &amp;&amp; !mark[(map[a[pos]] + i + y) % n])            {                map[b[pos]] = i;                map[c[pos]] = (map[a[pos]] + i + y) % n;                mark[i] = 1;                mark[(map[a[pos]] + i + y) % n] = 1;                dfs(pos - 1, (map[a[pos]] + i + y) / n);                map[b[pos]] = -1;                map[c[pos]] = -1;                mark[i] = 0;                mark[(map[a[pos]] + i + y) % n] = 0;            }    }    else if(map[b[pos]] != -1)    {        for (int i = 0; i &lt; n; i++)            if(!mark[i] &amp;&amp; !mark[(map[b[pos]] + i + y) % n])            {                map[a[pos]] = i;                map[c[pos]] = (map[b[pos]] + i + y) % n;                mark[i] = 1;                mark[(map[b[pos]] + i + y) % n] = 1;                dfs(pos - 1, (map[b[pos]] + i + y) / n);                map[a[pos]] = -1;                map[c[pos]] = -1;                mark[i] = 0;                mark[(map[b[pos]] + i + y) % n] = 0;            }    }    else if(map[c[pos]] != -1)    {        for (int i = 0; i &lt; n; i++)        {            if(!mark[i] &amp;&amp; !mark[(map[c[pos]] + n - i - y) % n])            {                map[a[pos]] = i;                map[b[pos]] = (map[c[pos]] + n - i - y) % n;                mark[i] = 1;                mark[(map[c[pos]] + n - i - y) % n] = 1;                dfs(pos - 1, ((map[c[pos]] + n - i - y) % n == (map[c[pos]] + n - i - y)));                map[a[pos]] = -1;                map[b[pos]] = -1;                mark[i] = 0;                mark[(map[c[pos]] + n - i - y) % n] = 0;            }        }    }    else    {        // printf(&quot;\\\\\n&quot;);        for (int i = n - 1; i &gt;= 0; i--)        {            if(mark[i]) continue;            mark[i] = 1;            map[a[pos]] = i;            // printf(&quot;------__\n&quot;);            for (int j = n - 1; j &gt;= 0; j--)            {                if(!mark[j] &amp;&amp; !mark[(i + j + y) % n])                {                    // printf(&quot;===\n&quot;);                    mark[j] = mark[(i + j + y) % n] = 1;                    map[b[pos]] = j;                    map[c[pos]] = (i + j + y) % n;                    dfs(pos - 1, (i + j + y) / n);                    mark[j] = mark[(i + j + y) % n] = 0;                    map[b[pos]] = -1;                    map[c[pos]] = -1;                }                else if (mark[j] &amp;&amp; mark[(i + j + y) % n] &amp;&amp; (j == map[b[pos]]) &amp;&amp; ((i + j + y) % n == map[c[pos]]))                {                    dfs(pos - 1, (i + j + y) / n);                }                else if (mark[j] &amp;&amp; (j == map[b[pos]]) &amp;&amp; !mark[(i + j + y) % n])                {                    // printf(&quot;----\n&quot;);                    mark[(i + j + y) % n] = 1;                    map[c[pos]] = (i + j + y) % n;                    dfs(pos - 1, (i + j + y) / n);                    map[c[pos]] = -1;                    mark[(i + j + y) % n] = 0;                }            }            map[a[pos]] = -1;            mark[i] = 0;        }    }}int main(){    // freopen(&quot;alpha.in&quot;,&quot;r&quot;,stdin);    // freopen(&quot;alpha.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%d&quot;, &amp;n);    scanf(&quot;%s%s%s&quot;, a + 1, b + 1, c + 1);    for (int i = &#39;A&#39;; i &lt; &#39;A&#39; + n; i++)        map[i] = -1;    dfs(n, 0);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/09/17/107/#disqus_thread</comments>
    </item>
    
    <item>
      <title>NOIP模拟 超级树</title>
      <link>https://blog.wildrage.xyz/2017/09/15/106/</link>
      <guid>https://blog.wildrage.xyz/2017/09/15/106/</guid>
      <pubDate>Fri, 15 Sep 2017 11:18:35 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;3-1-描述&quot;&gt;&lt;a href=&quot;#3-1-描述&quot; class=&quot;headerlink&quot; title=&quot;3.1 描述&quot;&gt;&lt;/a&gt;3.1 描述&lt;/h3&gt;&lt;p&gt;一棵k-超级树可按如下方法得到：取一棵深度为k的满二叉树，对每个节&lt;br&gt;点，向它的所有祖先连边（如果这条边不存在的话）。例如，下图是一个4-超&lt;br&gt;级树的例子：&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="3-1-描述"><a href="#3-1-描述" class="headerlink" title="3.1 描述"></a>3.1 描述</h3><p>一棵k-超级树可按如下方法得到：取一棵深度为k的满二叉树，对每个节<br>点，向它的所有祖先连边（如果这条边不存在的话）。例如，下图是一个4-超<br>级树的例子：<br><a id="more"></a><br><img src="https://i.loli.net/2017/09/15/59bbb7efc36c1.gif" alt="tree.gif"><br>现在你的任务是统计一棵k-超级树中有多少条每个节点最多经过一次的不<br>同有向路径。两条路径被认为不同，当且仅当它们经过的节点的集合不同，或<br>经过的节点的顺序不同。由于答案可能很大，请输出总路径数对mod取模后的<br>结果。</p><h3 id="3-2-输入"><a href="#3-2-输入" class="headerlink" title="3.2 输入"></a>3.2 输入</h3><p>一行两个整数k、mod，意义见上。  </p><h3 id="3-3-输出"><a href="#3-3-输出" class="headerlink" title="3.3 输出"></a>3.3 输出</h3><p>一行一个整数，代表答案</p><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><table><thead><tr><th style="text-align:center">输入</th><th style="text-align:center">输出</th></tr></thead><tbody><tr><td style="text-align:center">2 100</td><td style="text-align:center">9</td></tr><tr><td style="text-align:center">3 1000</td><td style="text-align:center">245</td></tr><tr><td style="text-align:center">20 998244353</td><td style="text-align:center">450500168</td></tr></tbody></table><p>样例解释：对第一组样例，将节点如图编号，共有9条不同的路径：1, 2, 3, 1−<br>2, 2 − 1, 1 − 3, 3 − 1, 2 − 1 − 3, 3 − 1 − 2。<br><img src="https://i.loli.net/2017/09/15/59bbb8a0e55bc.png" alt="tree1.png"></p><h3 id="限制与约定"><a href="#限制与约定" class="headerlink" title="限制与约定"></a>限制与约定</h3><p>对于10%的数据，k ≤ 4。<br>对于40%的数据，k ≤ 10。<br>对于60%的数据，k ≤ 100。<br>另有10%的数据，mod = 998244353。<br>对于所有数据，1 ≤ k ≤ 300，1 ≤ mod ≤ 109。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑dp[i][j]表示一棵i-超级树，有j条点不重复的路径的方案数。<br>对于第二维表示有j条路径他们不相交的方案数<br>这记num=dp[i][l]*dp[i][r]  </p><pre><code>dp[i+1][l+r]+=num  dp[i+1][l+r+1]+=num  dp[i+1][l+r]+=2*num*(l+r)  dp[i+1][l+r-1]+=2*num*l*r  dp[i+1][l+r-1]+=num*(l*(l-1)+r*(r-1))  </code></pre><p>dp[1][0]=dp[1][1]=1<br>答案为dp[k][1]  </p><p>因为我们发现每次转移的时候j最多会减1<br>所以我们只需要前k-i+1个状态<br>只DP这些状态就可以了</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;long long f[305][305];int MOD;int main(){    int k;    scanf(&quot;%d%d&quot;, &amp;k, &amp;MOD);    f[1][0] = f[1][1] = 1 % MOD;    for (int i = 1; i &lt; k; i++)    {        for (int l = 0; l &lt;= k - i + 1; l++)            for (int r = 0; r &lt;= k - i + 1; r++)            {                long long num = f[i][l] * f[i][r] % MOD;                if (r + l &lt;= k - i)                {                    f[i + 1][r + l] = (f[i + 1][r + l] + num) % MOD;                    f[i + 1][r + l] = (f[i + 1][r + l] + 2 * num * (l + r) % MOD) % MOD;                }                if (r + l + 1 &lt;= k - i)                    f[i + 1][r + l + 1] = (f[i + 1][r + l + 1] + num) % MOD;                if (r + l - 1 &lt;= k - i)                {                    f[i + 1][r + l - 1] = (f[i + 1][r + l - 1] + 2 * num * l * r % MOD) % MOD;                    f[i + 1][r + l - 1] = (f[i + 1][r + l - 1] + num * (l * (l - 1) + r * (r - 1)) % MOD) % MOD;                }            }    }    printf(&quot;%lld&quot;, f[k][1]);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/09/15/106/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[ZJOI2007]矩阵游戏</title>
      <link>https://blog.wildrage.xyz/2017/08/22/105/</link>
      <guid>https://blog.wildrage.xyz/2017/08/22/105/</guid>
      <pubDate>Tue, 22 Aug 2017 09:12:21 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;　　小Q是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏——矩阵游戏。矩阵游戏在一个N&lt;br&gt;*N黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：行交换操作：选择&lt;br&gt;矩阵的任意两行，交换这两行（即交换对应格子的颜色）列交换操作：选择矩阵的任意行列，交换这两列（即交换&lt;br&gt;对应格子的颜色）&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>　　小Q是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏——矩阵游戏。矩阵游戏在一个N<br>*N黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：行交换操作：选择<br>矩阵的任意两行，交换这两行（即交换对应格子的颜色）列交换操作：选择矩阵的任意行列，交换这两列（即交换<br>对应格子的颜色）<br><a id="more"></a><br>游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑<br>色。对于某些关卡，小Q百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！！于是小Q决定写一个程<br>序来判断这些关卡是否有解。</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>　　第一行包含一个整数T，表示数据的组数。接下来包含T组数据，每组数据第一行为一个整数N，表示方阵的大<br>小；接下来N行为一个N*N的01矩阵（0表示白色，1表示黑色）。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>　　输出文件应包含T行。对于每一组数据，如果该关卡有解，输出一行Yes；否则输出一行No。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>2<br>2<br>0 0<br>0 1<br>3<br>0 0 1<br>0 1 0<br>1 0 0  </p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>No<br>Yes  </p></blockquote><h3 id="【数据规模】"><a href="#【数据规模】" class="headerlink" title="【数据规模】"></a>【数据规模】</h3><p>对于100%的数据，N ≤ 200</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>我们发现在同一行或同一列的一直在同一行或同一列。<br>所以这道题就是要求是否能找到不同行列的一个匹配覆盖n个点  </p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct edge{    int END, next;}v[40005];int first[205],p;void add(int a,int b){    v[p].END = b;    v[p].next = first[a];    first[a] = p++;}int link[205];bool vis[205];int find(int x){    for (int i = first[x]; i != -1; i = v[i].next)    {        if(!vis[v[i].END])        {            vis[v[i].END] = 1;            if(link[v[i].END]==-1||find(link[v[i].END]))            {                link[v[i].END] = x;                return 1;             }        }    }    return 0;}int main(){    int T, a;    scanf(&quot;%d&quot;, &amp;T);    while (T--)    {        memset(first, -1, sizeof(first));        p = 0;        memset(link, -1, sizeof(link));        int n;        scanf(&quot;%d&quot;, &amp;n);        for (int i = 1; i &lt;= n; i++)            for (int j = 1; j &lt;= n; j++)            {                scanf(&quot;%d&quot;, &amp;a);                if (a)                    add(i, j);            }        int ans = 0;        for (int i = 1; i &lt;= n; i++)        {            memset(vis, 0, sizeof(vis));            if (find(i))                ans++;        }        if(ans == n)            printf(&quot;Yes\n&quot;);        else            printf(&quot;No\n&quot;);    }}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/22/105/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[HNOI2012]矿场搭建</title>
      <link>https://blog.wildrage.xyz/2017/08/22/104/</link>
      <guid>https://blog.wildrage.xyz/2017/08/22/104/</guid>
      <pubDate>Tue, 22 Aug 2017 09:08:30 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;煤矿工地可以看成是由隧道连接挖煤点组成的无向图。为安全起见，希望在工地发生事故时所有挖煤点的工人都能有一条出路逃到救援出口处。于是矿主决定在某些挖煤点设立救援出口，使得无论哪一个挖煤点坍塌之后，其他挖煤点的工人都有一条道路通向救援出口。请写一个程序，用来计算至少需要设置几个救援出口，以及不同最少救援出口的设置方案总数。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>煤矿工地可以看成是由隧道连接挖煤点组成的无向图。为安全起见，希望在工地发生事故时所有挖煤点的工人都能有一条出路逃到救援出口处。于是矿主决定在某些挖煤点设立救援出口，使得无论哪一个挖煤点坍塌之后，其他挖煤点的工人都有一条道路通向救援出口。请写一个程序，用来计算至少需要设置几个救援出口，以及不同最少救援出口的设置方案总数。</p><a id="more"></a><p>输入<br>输入文件有若干组数据，每组数据的第一行是一个正整数 N（N≤500），表示工地的隧道数，接下来的 N 行每行是用空格隔开的两个整数 S 和 T，表示挖S 与挖煤点 T 由隧道直接连接。输入数据以 0 结尾。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输入文件中有多少组数据，输出文件 output.txt 中就有多少行。每行对应一组输入数据的 结果。其中第 i 行以 Case i: 开始（注意大小写，Case 与 i 之间有空格，i 与:之间无空格，: 之后有空格），其后是用空格隔开的两个正整数，第一个正整数表示对于第 i 组输入数据至少需 要设置几个救援出口，第二个正整数表示对于第 i 组输入数据不同最少救援出口的设置方案总 数。输入数据保证答案小于 2^64。输出格式参照以下输入输出样例。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>9<br>1  3<br>4  1<br>3  5<br>1  2<br>2  6<br>1  5<br>6  3<br>1  6<br>3  2<br>6<br>1  2<br>1  3<br>2  4<br>2  5<br>3  6<br>3  7<br>0    </p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>Case 1: 2 4<br>Case 2: 4 1  </p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>可也看出如果塌在割点才有影响<br>所以先跑出所以割点，然后删去割点跑联通块<br>如果一个块有两个割点那么无所谓。<br>否则建一个方案为点数 </p><p>最后如果只要一个联通块，那么就要两个点。方案数为n*（n-1）/2</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct edge{    int END, next;} v[10005];int first[500], p;void add(int a, int b){    v[p].END = b;    v[p].next = first[a];    first[a] = p++;}int dfn[500], low[500], Index;bool iscut[500];void Tarjan(int x, int fa){    low[x] = dfn[x] = ++Index;    int S = 0;    for (int i = first[x]; i != -1; i = v[i].next)    {        if (!dfn[v[i].END])        {            S++;            Tarjan(v[i].END, x);            low[x] = min(low[v[i].END], low[x]);            if (low[v[i].END] &gt;= dfn[x])                iscut[x] = 1;        }        else            low[x] = min(low[x], dfn[v[i].END]);    }    if (fa &lt; 0 &amp;&amp; S == 1)        iscut[x] = 0;}bool vis[500];int T, size, num;int color[500];void dfs(int x){    vis[x] = 1;    size++;    for (int i = first[x]; i != -1; i = v[i].next)    {        if (!vis[v[i].END])        {            if (!iscut[v[i].END])                dfs(v[i].END);            else            {                if (color[v[i].END] != T)                    color[v[i].END] = T, num++;            }        }    }}int main(){    //freopen(&quot;bzoj_2730.in&quot;,&quot;r&quot;,stdin);    //freopen(&quot;bzoj_2730.out&quot;,&quot;w&quot;,stdout);    int P1 = 0;    while (1)    {        memset(vis, 0, sizeof(vis));        memset(dfn, 0, sizeof(dfn));        memset(low, 0, sizeof(low));        memset(iscut, 0, sizeof(iscut));        memset(first, -1, sizeof(first));        memset(color, 0, sizeof(color));        p = 0;        Index = 0;        P1++;        int n = 0, a, b, m;        scanf(&quot;%d&quot;, &amp;m);        if (m == 0)            break;        for (int i = 1; i &lt;= m; i++)        {            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);            n = max(a, n);            n = max(b, n);            add(a, b);            add(b, a);        }        for (int i = 1; i &lt;= n; i++)            if (!dfn[i])                Tarjan(i, -1);        int ans1 = 0;        long long ans2 = 1;        T = 0;        for (int i = 1; i &lt;= n; i++)        {            if (!vis[i] &amp;&amp; !iscut[i])            {                T++, size = 0, num = 0;                dfs(i);                if (num == 1)                    ans1++, ans2 *= size;            }        }        if (T == 1)            ans1 = 2, ans2 = n * (n - 1) / 2;        printf(&quot;Case %d: %d %lld\n&quot;, P1, ans1, ans2);    }}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/22/104/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[NOI2014]魔法森林</title>
      <link>https://blog.wildrage.xyz/2017/08/22/103/</link>
      <guid>https://blog.wildrage.xyz/2017/08/22/103/</guid>
      <pubDate>Tue, 22 Aug 2017 08:59:12 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;为了得到书法大家的真传，小E同学下定决心去拜访住在魔法森林中的隐士。魔法森林可以被看成一个包含个N节点M条边的无向图，节点标号为1..N，边标号为1..M。初始时小E同学在号节点1，隐士则住在号节点N。小E需要通过这一片魔法森林，才能够拜访到隐士。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>为了得到书法大家的真传，小E同学下定决心去拜访住在魔法森林中的隐士。魔法森林可以被看成一个包含个N节点M条边的无向图，节点标号为1..N，边标号为1..M。初始时小E同学在号节点1，隐士则住在号节点N。小E需要通过这一片魔法森林，才能够拜访到隐士。<br><a id="more"></a><br>魔法森林中居住了一些妖怪。每当有人经过一条边的时候，这条边上的妖怪就会对其发起攻击。幸运的是，在号节点住着两种守护精灵：A型守护精灵与B型守护精灵。小E可以借助它们的力量，达到自己的目的。</p><p>只要小E带上足够多的守护精灵，妖怪们就不会发起攻击了。具体来说，无向图中的每一条边Ei包含两个权值Ai与Bi。若身上携带的A型守护精灵个数不少于Ai，且B型守护精灵个数不少于Bi，这条边上的妖怪就不会对通过这条边的人发起攻击。当且仅当通过这片魔法森林的过程中没有任意一条边的妖怪向小E发起攻击，他才能成功找到隐士。</p><p>由于携带守护精灵是一件非常麻烦的事，小E想要知道，要能够成功拜访到隐士，最少需要携带守护精灵的总个数。守护精灵的总个数为A型守护精灵的个数与B型守护精灵的个数之和。</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第1行包含两个整数N,M，表示无向图共有N个节点，M条边。 接下来M行，第行包含4个正整数Xi,Yi,Ai,Bi，描述第i条无向边。其中Xi与Yi为该边两个端点的标号，Ai与Bi的含义如题所述。 注意数据中可能包含重边与自环。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出一行一个整数：如果小E可以成功拜访到隐士，输出小E最少需要携带的守护精灵的总个数；如果无论如何小E都无法拜访到隐士，输出“-1”（不含引号）。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>【输入样例1】<br>4 5<br>1 2 19 1<br>2 3 8 12<br>2 4 12 15<br>1 3 17 8<br>3 4 1 17<br>【输入样例2】<br>3 1<br>1 2 1 1  </p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>【输出样例1】<br>32<br>【样例说明1】<br>如果小E走路径1→2→4，需要携带19+15=34个守护精灵；<br>如果小E走路径1→3→4，需要携带17+17=34个守护精灵；<br>如果小E走路径1→2→3→4，需要携带19+17=36个守护精灵；<br>如果小E走路径1→3→2→4，需要携带17+15=32个守护精灵。<br>综上所述，小E最少需要携带32个守护精灵。<br>【输出样例2】<br>-1<br>【样例说明2】<br>小E无法从1号节点到达3号节点，故输出-1。   </p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>对一个权值排序<br>从小到大逐渐加边维护答案  </p><pre><code class="c++">#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;struct data{    int s, e, a, b;    bool operator&lt;(const data &amp;c) const    {        return a &lt; c.a;    }} a[100005];struct edge{    int END, v, next;} v[200005];int first[50005], p;void add(int s, int e, int c){    v[p].END = e;    v[p].v = c;    v[p].next = first[s];    first[s] = p++;}bool flag[50005];queue&lt;int&gt; Q;int dis[50005];void spfa(){    while (!Q.empty())    {        int k = Q.front();        Q.pop();        flag[k] = 0;        for (int i = first[k]; i != -1; i = v[i].next)        {            if (dis[v[i].END] &gt; max(dis[k], v[i].v))            {                dis[v[i].END] = max(dis[k], v[i].v);                if (!flag[v[i].END])                {                    flag[v[i].END] = 1;                    Q.push(v[i].END);                }            }        }    }}int main(){    memset(first, -1, sizeof(first));    int n, m;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= m; i++)    {        scanf(&quot;%d%d%d%d&quot;, &amp;a[i].s, &amp;a[i].e, &amp;a[i].a, &amp;a[i].b);    }    sort(a + 1, a + m + 1);    memset(dis, 0x3f, sizeof(dis));    dis[1] = 0;    int ans = 0x3f3f3f3f;    for (int i = 1; i &lt;= m; i++)    {        add(a[i].s, a[i].e, a[i].b);        add(a[i].e, a[i].s, a[i].b);        if (!flag[a[i].s])        {            Q.push(a[i].s);            flag[a[i].s] = 1;        }        if (!flag[a[i].e])        {            Q.push(a[i].e);            flag[a[i].e] = 1;        }        if (a[i + 1].a != a[i].a)            spfa();        ans = min(ans, a[i].a + dis[n]);    }    if (ans == 0x3f3f3f3f)        puts(&quot;-1&quot;);    else        printf(&quot;%d\n&quot;,ans);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/22/103/#disqus_thread</comments>
    </item>
    
    <item>
      <title>生日有感</title>
      <link>https://blog.wildrage.xyz/2017/08/21/102/</link>
      <guid>https://blog.wildrage.xyz/2017/08/21/102/</guid>
      <pubDate>Mon, 21 Aug 2017 07:44:30 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;生日有感&quot;&gt;&lt;a href=&quot;#生日有感&quot; class=&quot;headerlink&quot; title=&quot;生日有感&quot;&gt;&lt;/a&gt;生日有感&lt;/h2&gt;&lt;p&gt;其实这是我在这个学校过的第二个生日了，&lt;br&gt;只有两句祝福，但也让我很是高兴。  &lt;/p&gt;
&lt;p&gt;心中略有一丝伤感但更多的是
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="生日有感"><a href="#生日有感" class="headerlink" title="生日有感"></a>生日有感</h2><p>其实这是我在这个学校过的第二个生日了，<br>只有两句祝福，但也让我很是高兴。  </p><p>心中略有一丝伤感但更多的是希望，<br>我只希望：<br>下一次，就下一次，我的生日，能在家过。</p><p>感谢亲爱的爸爸妈妈 和 关心我的同学们。</p>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/21/102/#disqus_thread</comments>
    </item>
    
    <item>
      <title>约会</title>
      <link>https://blog.wildrage.xyz/2017/08/15/99/</link>
      <guid>https://blog.wildrage.xyz/2017/08/15/99/</guid>
      <pubDate>Tue, 15 Aug 2017 12:41:52 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2017/08/15/5992ec3e4b26c.jpg&quot; alt=&quot;20170813082855_58428.jpg&quot;&gt;&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://i.loli.net/2017/08/15/5992ec3e4b26c.jpg" alt="20170813082855_58428.jpg"><br><a id="more"></a></p><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p><img src="https://i.loli.net/2017/08/15/5992ec6af30e1.jpg" alt="20170813082918_26068.jpg"></p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>4<br>1 2<br>1 3<br>2 4<br>1<br>2 3  </p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>1  </p></blockquote><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p><img src="https://i.loli.net/2017/08/15/5992ec9ab7a7d.jpg" alt="20170813083005_18558.jpg"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先建出树来，顺便求出每个节点所在子树的size    </p><p>然后对于每一个询问我们先跑LCA<br>然后通过树上倍增求出他们的中点<br>如果他是LCA那么ans = n - size(有起点的儿子) - size(有终点的儿子)<br>否则 ans = size（mid） - size（有起点的儿子） - size（有终点的儿子）</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct edge{    int END, next;} v[200005];int first[100005], p, n;void add(int a, int b){    v[p].END = b;    v[p].next = first[a];    first[a] = p++;}int size[100005];int f[100005][30];int dep[100005];void dfs(int rt, int fa, int dp){    dep[rt] = dp;    f[rt][0] = fa;    for (int i = 1; i &lt;= 20; i++)        f[rt][i] = f[f[rt][i - 1]][i - 1];    size[rt] = 1;    for (int i = first[rt]; i != -1; i = v[i].next)        if (v[i].END != fa)        {            dfs(v[i].END, rt, dp + 1);            size[rt] += size[v[i].END];        }}int LCA(int a, int b){    if (dep[a] &lt; dep[b])        swap(a, b);    int t = dep[a] - dep[b];    for (int i = 20; i &gt;= 0; i--)        if (t &amp; (1 &lt;&lt; i))            a = f[a][i];    if (a == b)        return a;    for (int i = 20; i &gt;= 0; i--)        if (f[a][i] != f[b][i])            a = f[a][i], b = f[b][i];    return f[a][0];}int Query(int a, int b){    if (a == b)        return n;    if (dep[a] &lt; dep[b])        swap(a, b);    int Lca = LCA(a, b);    int l = dep[a] - dep[Lca];    int r = dep[b] - dep[Lca];    if ((l + r) &amp; 1)        return 0;    int mid = l + r &gt;&gt; 1;    int k = a;    for (int i = 20; i &gt;= 0; i--)        if (mid &amp; (1 &lt;&lt; i))            k = f[k][i];    if (k == Lca)    {        int t = dep[a] - dep[Lca] - 1;        for (int i = 20; i &gt;= 0; i--)            if (t &amp; (1 &lt;&lt; i))                a = f[a][i], b = f[b][i];        return n - size[a] - size[b];    }    else    {        int t = dep[a] - dep[k] - 1;        for (int i = 20; i &gt;= 0; i--)            if (t &amp; (1 &lt;&lt; i))                a = f[a][i];        return size[k] - size[a];    }}int main(int argc, char const *argv[]){    memset(first,-1,sizeof(first));    int a, b;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt; n; i++)    {        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);        add(a, b);        add(b, a);    }    dfs(1, 0, 0);    int m;    scanf(&quot;%d&quot;,&amp;m);    for (int i = 1; i &lt;= m; i++)    {        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);        printf(&quot;%d\n&quot;, Query(a, b));    }    return 0;}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/15/99/#disqus_thread</comments>
    </item>
    
    <item>
      <title>中值滤波</title>
      <link>https://blog.wildrage.xyz/2017/08/15/98/</link>
      <guid>https://blog.wildrage.xyz/2017/08/15/98/</guid>
      <pubDate>Tue, 15 Aug 2017 12:35:36 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2017/08/15/5992eafa9664e.jpg&quot; alt=&quot;20170813082609_40094.jpg&quot;&gt;&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://i.loli.net/2017/08/15/5992eafa9664e.jpg" alt="20170813082609_40094.jpg"><br><a id="more"></a></p><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p><img src="https://i.loli.net/2017/08/15/5992eb25abd31.jpg" alt="20170813082630_74802.jpg"></p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>3<br>0 1 0  </p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>1<br>0 0 0   </p></blockquote><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p><img src="https://i.loli.net/2017/08/15/5992eb7e84c7e.jpg" alt="20170813082722_12263.jpg"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先打表   </p><p>会发现规律然后我们按照规律模拟就可以了</p><p>具体的可以看代码</p><pre><code class="c++">#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int a[500005], b[500005];int main(){    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i++)        scanf(&quot;%d&quot;, &amp;a[i]);    a[n+1]=a[n];    int i = 1, l, r;    int ans = 0;    while (i &lt;= n)    {        while (i &lt;= n &amp;&amp; a[i] == a[i + 1])        {            b[i] = a[i];            i++;        }        l = i;        while (i &lt;= n &amp;&amp; a[i] != a[i + 1])            i++;        r = i;        int len = (r - l + 1);        if (len &amp; 1)            for (int j = l; j &lt;= r; j++)                b[j] = a[l];        else            for (int j = 1; j * 2 &lt;= len; j++)                b[l + j - 1] = a[l], b[r - j + 1] = a[r];        ans = max(ans, (len - 1) / 2);    }    printf(&quot;%d\n&quot;, ans);    for (int i = 1; i &lt;= n; i++)        printf(&quot;%d &quot;, b[i]);    //while(1);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/15/98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>最长上升子串</title>
      <link>https://blog.wildrage.xyz/2017/08/15/97/</link>
      <guid>https://blog.wildrage.xyz/2017/08/15/97/</guid>
      <pubDate>Tue, 15 Aug 2017 12:31:52 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2017/08/15/5992e9d597a7f.jpg&quot; alt=&quot;20170813082258_37990.jpg&quot;&gt;&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://i.loli.net/2017/08/15/5992e9d597a7f.jpg" alt="20170813082258_37990.jpg"><br><a id="more"></a></p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><blockquote><p>6<br>7 2 3 1 5 6  </p></blockquote><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><blockquote><p>5  </p></blockquote><p><img src="https://i.loli.net/2017/08/15/5992e9d596d0d.jpg" alt="20170813082405_16233.jpg"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>直接DP就可以了<br>很水了<br>打的有点傻  </p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int f[300005][2][2], a[300005];bool change[300005];int main(){    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i++)        scanf(&quot;%d&quot;, a + i);    a[0] = -1;    int ans = 0;    f[1][0][0] = 1;    f[1][0][1] = 0;    f[1][1][1] = 1;    f[1][1][0] = 0;    for (int i = 2; i &lt;= n; i++)    {        f[i][0][0] = 1;        f[i][0][1] = 1;        f[i][1][1] = 1;        f[i][1][0] = 0;        if (a[i] &gt; a[i - 1])        {            f[i][0][0] = f[i - 1][0][0] + 1;            f[i][0][1] = f[i - 1][0][1] + 1;        }        if (f[i - 1][1][1] == f[i - 2][0][0] + 1)        {            if(a[i] &gt; a[i - 2] + 1)            {                f[i][0][1] = max(f[i][0][1], f[i - 1][1][1] + 1);            }        }        else        {            f[i][0][1] = max(f[i][0][1], f[i - 1][1][1]);        }        f[i][1][1] = max(f[i][1][1], f[i - 1][0][0] + 1);        ans = max(ans,max(f[i][0][0],max(f[i][0][1],f[i][1][1])));    }    printf(&quot;%d&quot;,ans);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/15/97/#disqus_thread</comments>
    </item>
    
    <item>
      <title>便</title>
      <link>https://blog.wildrage.xyz/2017/08/15/101/</link>
      <guid>https://blog.wildrage.xyz/2017/08/15/101/</guid>
      <pubDate>Tue, 15 Aug 2017 12:15:35 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给出一个R*C的棋盘.共有R行C列,R*C个格子.现要在每个格子都填一个非负整数.使得任意一个2*2的正方形区域都满足这样的性质:左上角的数字+右下角的数字=左下角的数字+右上角的数字.有些格子已经确定,你不能更改其中的数字.其他格子的数字由你决定.&lt;br&gt;这是一个符合要求的3*3的棋盘:&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一个R*C的棋盘.共有R行C列,R*C个格子.现要在每个格子都填一个非负整数.使得任意一个2*2的正方形区域都满足这样的性质:左上角的数字+右下角的数字=左下角的数字+右上角的数字.有些格子已经确定,你不能更改其中的数字.其他格子的数字由你决定.<br>这是一个符合要求的3*3的棋盘:<br><a id="more"></a><br>||||<br>|:-:|:-:|:-:|<br>|1|2|3|<br>|2|3|4|<br>|4|5|6|</p><p>不难验证每个2*2的区域都是符合要求的.<br>Orbitingflea想要知道一个可行的填充棋盘的方案.但是这个方案可能很大.所以你只需对给定的棋盘判定是否存在至少一种可行的填充棋盘的方案.</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第一行输入一个T，表示数据组数。接下来T组数据。</p><p>每组数据的第1行2个整数R,C表示棋盘的大小.</p><p>第2行1个整数n表示已经被填好数字的格子的数目.</p><p>接下来n行每行3个整数ri,ci,ai,表示第ri行ci列的格子被填上了数字ai.</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>T行.第i行是第i组数据的答案.有合法方案时输出一行Yes,没有时输出一行No.</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>6<br>2 2 3<br>1 1 0<br>1 2 10<br>2 1 20<br>2 3 5<br>1 1 0<br>1 2 10<br>1 3 20<br>2 1 30<br>2 3 40<br>2 2 3<br>1 1 20<br>1 2 10<br>2 1 0<br>3 3 4<br>1 1 0<br>1 3 10<br>3 1 10<br>3 3 20<br>2 2 4<br>1 1 0<br>1 2 10<br>2 1 30<br>2 2 20<br>1 1 1<br>1 1 -1  </p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>Yes<br>No<br>No<br>Yes<br>No<br>No  </p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>每一列差分后得到的结果相同.每一行差分后的<br>结果也相同.于是我们对行列分别用带权并查集维护行之间,列之间的差分关系.如果差分关系出现矛盾(两行之间的差<br>值可以推导出两种可能)则无解.如果差分关系没有矛盾,则需要求出整个矩阵中能推导出的最小值判断是否小于0.</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int fa1[1000005], fa2[1000005];long long w1[1000005], w2[1000005];long long Min1[1000005], Min2[1000005];struct Point{    int x, y, v;} a[1000005];bool cmpx(const Point &amp;A, const Point &amp;B){    return A.x &lt; B.x;}bool cmpy(const Point &amp;A, const Point &amp;B){    return A.y &lt; B.y;}int find1(int x){    if (x == fa1[x])        return x;    int rt = find1(fa1[x]);    w1[x] += w1[fa1[x]];    return fa1[x] = rt;}int find2(int x){    if (x == fa2[x])        return x;    int rt = find2(fa2[x]);    w2[x] += w2[fa2[x]];    return fa2[x] = rt;}bool link1(int a, int b, int w){    if (find1(a) != find1(b))    {        int fa = find1(a), fb = find1(b);        fa1[fa] = fa1[fb];        w1[fa] = w + w1[b] - w1[a];        return 1;    }    else        return w1[a] == w + w1[b];}bool link2(int a, int b, int w){    if (find2(a) != find2(b))    {        int fa = find2(a), fb = find2(b);        fa2[fa] = fa2[fb];        w2[fa] = w + w2[b] - w2[a];        return 1;    }    else        return w2[a] == w + w2[b];}int main(){    int T;    scanf(&quot;%d&quot;, &amp;T);    while (T--)    {        bool flag = 1;        int R, C;        scanf(&quot;%d%d&quot;, &amp;R, &amp;C);        for (int i = 1; i &lt;= R; i++)        {            fa1[i] = i;            w1[i] = 0;        }        for (int i = 1; i &lt;= C; i++)        {            fa2[i] = i;            w2[i] = 0;        }        int n;        scanf(&quot;%d&quot;, &amp;n);        for (int i = 1; i &lt;= n; i++)            scanf(&quot;%d%d%d&quot;, &amp;a[i].x, &amp;a[i].y, &amp;a[i].v);        for (int i = 1; i &lt;= n; i++)            if (a[i].v &lt; 0)                flag = 0;        sort(a + 1, a + n + 1, cmpx);        for (int i = 1; i &lt; n; i++)            if (a[i].x == a[i + 1].x)                if (!link2(a[i].y, a[i + 1].y, a[i + 1].v - a[i].v))                    flag = false;        sort(a + 1, a + n + 1, cmpy);        for (int i = 1; i &lt; n; i++)            if (a[i].y == a[i + 1].y)                if (!link1(a[i].x, a[i + 1].x, a[i + 1].v - a[i].v))                    flag = false;        memset(Min1, 0x3f, sizeof(Min1));        memset(Min2, 0x3f, sizeof(Min2));        for (int i = 1; i &lt;= n; i++)        {            int rt = find1(a[i].x);            Min1[rt] = min(Min1[rt], a[i].v + w1[a[i].x]);        }        for (int i = 1; i &lt;= R; i++)        {            int rt = find1(i);            Min2[rt] = min(Min2[rt], -w1[i]);        }        for (int i = 1; i &lt;= R; i++)        {            if (fa1[i] == i &amp;&amp; Min1[i] + Min2[i] &lt; 0)                flag = 0;        }        if(flag)            puts(&quot;Yes&quot;);        else            puts(&quot;No&quot;);    }}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/15/101/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Haoi2016]字符合并</title>
      <link>https://blog.wildrage.xyz/2017/08/15/100/</link>
      <guid>https://blog.wildrage.xyz/2017/08/15/100/</guid>
      <pubDate>Tue, 15 Aug 2017 12:14:12 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;有一个长度为 n 的 01 串，你可以每次将相邻的 k 个字符合并，得到一个新的字符并获得一定分数。得到的新字&lt;br&gt;符和分数由这 k 个字符确定。你需要求出你能获得的最大分数。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个长度为 n 的 01 串，你可以每次将相邻的 k 个字符合并，得到一个新的字符并获得一定分数。得到的新字<br>符和分数由这 k 个字符确定。你需要求出你能获得的最大分数。<br><a id="more"></a></p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第一行两个整数n，k。接下来一行长度为n的01串，表示初始串。接下来2k行，每行一个字符ci和一个整数wi，ci<br>表示长度为k的01串连成二进制后按从小到大顺序得到的第i种合并方案得到的新字符,wi表示对应的第i种方案对应<br>获得的分数。1&lt;=n&lt;=300,0&lt;=ci&lt;=1,wi&gt;=1,k&lt;=8</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出一个整数表示答案</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>3 2<br>101<br>1 10<br>1 10<br>0 20<br>1 30  </p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>40</p></blockquote><p>//第3行到第6行表示长度为2的4种01串合并方案。00-&gt;1,得10分，01-&gt;1得10分，10-&gt;0得20分，11-&gt;1得30分。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>令f[i][j][S]表示将i~j这一段消到S这个状态能获得的最大得分。<br>f[i][j][S&lt;&lt;1]=max(f[i][j][S&lt;&lt;1],f[i][m−1][S]+f[m][j][0])<br>f[i][j][S&lt;&lt;1|1]=max(f[i][j][S&lt;&lt;1|1],f[i][m−1][S]+f[m][j][1])  </p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;bitset&gt;using namespace std;int a[400], c;int s[1 &lt;&lt; 8];long long w[1 &lt;&lt; 8], f[305][305][1 &lt;&lt; 8], INF, ans;int main(){    // freopen(&quot;merge.in&quot;,&quot;r&quot;,stdin);    // freopen(&quot;merge.out&quot;,&quot;w&quot;,stdout);    int n, k;    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);    for (int i = 1; i &lt;= n; i++)        scanf(&quot;%1d&quot;, &amp;a[i]);    for (int i = 0; i &lt; (1 &lt;&lt; k); i++)        scanf(&quot;%d%lld&quot;, &amp;s[i], &amp;w[i]);    memset(f, 0x80, sizeof(f));    memset(&amp;INF, 0x80, sizeof(INF));    for (int i = 1; i &lt;= n; i++)        f[i][i][a[i]] = 0;    for (int l = 2; l &lt;= n; l++)    {        for (int i = 1; i &lt;= n - l + 1; i++)        {            int j = i + l - 1;            int len = j - i;            while (len &gt;= k)                len -= k - 1;            for (int m = j; m &gt; i; m -= k - 1)            {                for (int S = 0; S &lt; (1 &lt;&lt; len); S++)                {                    if (f[i][m - 1][S] != INF)                    {                        if (f[m][j][0] != INF)                            f[i][j][S &lt;&lt; 1] = max(f[i][j][S &lt;&lt; 1], f[i][m - 1][S] + f[m][j][0]);                        if (f[m][j][1] != INF)                            f[i][j][S &lt;&lt; 1 | 1] = max(f[i][j][S &lt;&lt; 1 | 1], f[i][m - 1][S] + f[m][j][1]);                    }                }            }            if (len == k - 1)            {                long long g[2];                g[0] = g[1] = INF;                for (int S = 0; S &lt; (1 &lt;&lt; k); S++)                    if (f[i][j][S] != INF)                        g[s[S]] = max(g[s[S]], f[i][j][S] + w[S]);                f[i][j][0] = g[0];                f[i][j][1] = g[1];            }        }    }    for (int i = 0; i &lt; (1 &lt;&lt; k); i++)        ans = max(ans, f[1][n][i]);    printf(&quot;%lld\n&quot;, ans);    //while(1);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/15/100/#disqus_thread</comments>
    </item>
    
    <item>
      <title>从N方到NlogN的转变——FFT</title>
      <link>https://blog.wildrage.xyz/2017/08/14/96/</link>
      <guid>https://blog.wildrage.xyz/2017/08/14/96/</guid>
      <pubDate>Mon, 14 Aug 2017 13:24:58 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;1-Why&quot;&gt;&lt;a href=&quot;#1-Why&quot; class=&quot;headerlink&quot; title=&quot;1.Why&quot;&gt;&lt;/a&gt;1.Why&lt;/h2&gt;&lt;p&gt;为什么我们信息学竞赛要用到FFT&lt;br&gt;因为我们要优化卷积啊&lt;br&gt;将n边为log是一个非常大的优化啊&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="1-Why"><a href="#1-Why" class="headerlink" title="1.Why"></a>1.Why</h2><p>为什么我们信息学竞赛要用到FFT<br>因为我们要优化卷积啊<br>将n边为log是一个非常大的优化啊<br><a id="more"></a></p><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>什么是FFT呢<br>在<a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2" target="_blank" rel="noopener">wiki</a>上是这么说的</p><blockquote><p>快速傅里叶变换（英语：Fast Fourier Transform, FFT），是计算序列的离散傅里叶变换（DFT）或其逆变换的一种算法。傅里叶分析将信号从原始域（通常是时间或空间）转换到频域的表示或者逆过来转换。FFT会通过把DFT矩阵分解为稀疏（大多为零）因子之积来快速计算此类变换。[1] 因此，它能够将计算DFT的复杂度从只用DFT定义计算需要的 $O(n^{2})$，降低到 $O(n\log n)$，其中 n 为数据大小。</p></blockquote><p>啥你说啥我听不懂（黑人问号?）</p><p>如果简单的说就是求两个多项式的乘积</p><h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>其实关于FFT的具体理论很复杂，我一篇博客肯定不能接受清楚<br>所以请有兴趣的人移步Google 或 baidu  </p><p>如果简单来说FFT用的分制的方法<br>所以才能有log啊  </p><p>将一个多项式按奇偶分开<br>但如果我们直接找值去计算时间复杂度还是$O(n^2)$的  </p><p>所以出现了一个特殊的东西他叫做n次单位根</p><p>然后利用他的性质就可以搞了</p><p>先贴两个板子</p><p>UOJ 34 多项式乘法</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 1 &lt;&lt; 18 | 5;namespace FFT{const double pi = acos(-1.0);struct Complex{    double x, y;    Complex operator+(const Complex &amp;a)    {        return (Complex){x + a.x, y + a.y};    }    Complex operator-(const Complex &amp;a)    {        return (Complex){x - a.x, y - a.y};    }    Complex operator*(const Complex &amp;a)    {        return (Complex){x * a.x - y * a.y, x * a.y + y * a.x};    }    Complex operator*(const double &amp;a)    {        return (Complex){x * a, y * a};    }    Complex Get()    {        return (Complex){x, -y};    }} c[maxn], c1[maxn], V = (Complex){0.5, 0} * (Complex){0, -0.5};int rev[maxn], N, FU;double Inv;void FFt(Complex *a, int op){    Complex w, wn, t;    for (int i = 0; i &lt; N; i++)        if (i &lt; rev[i])            swap(a[i], a[rev[i]]);    for (int k = 2; k &lt;= N; k &lt;&lt;= 1)    {        wn = (Complex){cos(op * 2 * pi / k), sin(op * 2 * pi / k)};        for (int j = 0; j &lt; N; j += k)        {            w = (Complex){1, 0};            for (int i = 0; i &lt; (k &gt;&gt; 1); i++, w = w * wn)            {                t = a[i + j + (k &gt;&gt; 1)] * w;                a[i + j + (k &gt;&gt; 1)] = a[i + j] - t;                a[i + j] = a[i + j] + t;            }        }    }    if (op == -1)        for (int i = 0; i &lt; N; i++)            a[i] = a[i] * Inv;}void FFt(int *a, int *b, int *res, int n){    int j;    N = 1;    while (N &lt; n)        N &lt;&lt;= 1;    FU = N - 1;    Inv = 1. / N;    for (int i = 0; i &lt; N; i++)        if (i &amp; 1)            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | (N &gt;&gt; 1);        else            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1);    for (int i = 0; i &lt; N; i++)        c[i].x = a[i], c[i].y = b[i];    FFt(c, 1);    for (int i = 0; i &lt; N; i++)        j = (N - i) &amp; FU, c1[i] = (c[i] + c[j].Get()) * (c[i] - c[j].Get()) * V;    FFt(c1, -1);    for (int i = 0; i &lt; N; i++)        res[i] = round(c1[i].x);}} // FFTint main(int argc, char const *argv[]){    static int a[maxn],b[maxn];    int n1, n2, m;    scanf(&quot;%d%d&quot;, &amp;n1, &amp;n2);    m = n1 + n2 + 1;    for (int i = 0; i &lt;= n1; i++)        scanf(&quot;%d&quot;, &amp;a[i]);    for (int i = 0; i &lt;= n2; i++)        scanf(&quot;%d&quot;, &amp;b[i]);    FFT::FFt(a, b, a, m);    for (int i = 0; i &lt; m; i++)        printf(&quot;%d &quot;, a[i]);    return 0;}</code></pre><p>COGS 1473. 很强的乘法问题</p><pre><code class="c++">#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;const double pi = acos(-1.);struct Complex{    double x, y;    Complex() { ; }    Complex(double a, double b) : x(a), y(b) {}    Complex operator+(const Complex &amp;a) { return Complex(x + a.x, y + a.y); }    Complex operator-(const Complex &amp;a) { return Complex(x - a.x, y - a.y); }    Complex operator*(const Complex &amp;a) { return Complex(x * a.x - y * a.y, x * a.y + y * a.x); }    Complex operator*(const double a) { return Complex(x * a, y * a); }    Complex Get() { return Complex(x, -y); }} A[150005 &lt;&lt; 3], B[150005 &lt;&lt; 3];int rev[150005 &lt;&lt; 3], N, FU;double INV;void FFt(Complex *a, int op){    Complex w, wn, t;    for (int i = 0; i &lt; N; i++)        if (i &lt; rev[i])            std::swap(a[i], a[rev[i]]);    for (int k = 2; k &lt;= N; k &lt;&lt;= 1)    {        wn = Complex(cos(op * 2 * pi / k), sin(op * 2 * pi / k));        for (int j = 0; j &lt; N; j += k)        {            w = Complex(1, 0);            for (int i = 0; i &lt; (k &gt;&gt; 1); i++, w = w * wn)            {                t = a[i + j + (k &gt;&gt; 1)] * w;                a[i + j + (k &gt;&gt; 1)] = a[i + j] - t;                a[i + j] = a[i + j] + t;            }        }    }    if (op == -1)        for (int i = 0; i &lt; N; i++)            a[i] = a[i] * INV;}void FFt(const int *a, const int *b, int *res, int n){    N = 1;    while (N &lt; n)        N &lt;&lt;= 1;    INV = 1. / N;    for (int i = 0; i &lt; N; i++)        if (i &amp; 1)            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | (N &gt;&gt; 1);        else            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1);    for (int i = 0; i &lt; N; i++)        A[i].x = a[i], B[i].x = b[i];    FFt(A, 1), FFt(B, 1);    for (int i = 0; i &lt; N; i++)        A[i] = A[i] * B[i];    FFt(A, -1);    for (int i = 0; i &lt; N; i++)        res[i] = round(A[i].x);}char s[150005 &lt;&lt; 2];struct BigNum{    int len;    int a[1000005];    void read()    {        scanf(&quot;%s&quot;, s);        len = strlen(s);        for (int i = len - 1, j = 0; i &gt;= 0; i--, j++)            a[j] = s[i] - &#39;0&#39;;    }    BigNum operator*(const BigNum &amp;b)    {        BigNum ans;        ans.len = len + b.len - 1;        FFt(a, b.a, ans.a, ans.len + 1);        for (int i = 0; i &lt;= ans.len + 2; i++)        {            if (ans.a[i] &gt; 9)            {                ans.a[i + 1] += ans.a[i] / 10;                ans.a[i] %= 10;            }        }        while (ans.a[ans.len])            ans.len++;        return ans;    }    void print()    {        for (int i = len - 1; i &gt;= 0; i--)            printf(&quot;%d&quot;, a[i]);        printf(&quot;\n&quot;);    }} a, b;int main(){    freopen(&quot;bettermul.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;bettermul.out&quot;,&quot;w&quot;,stdout);    a.read();    b.read();    (a * b).print();    //while (1)        ;}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/14/96/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 3529 [Sdoi2014] 数表</title>
      <link>https://blog.wildrage.xyz/2017/08/14/95/</link>
      <guid>https://blog.wildrage.xyz/2017/08/14/95/</guid>
      <pubDate>Mon, 14 Aug 2017 13:19:20 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;有一张N×m的数表，其第i行第j列（1 &amp;lt; =i &amp;lt; =N，1 &amp;lt; =j &amp;lt; =m）的数值为&lt;br&gt;能同时整除i和j的所有自然数之和。给定a，计算数表中不大于a的数之和。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>有一张N×m的数表，其第i行第j列（1 &lt; =i &lt; =N，1 &lt; =j &lt; =m）的数值为<br>能同时整除i和j的所有自然数之和。给定a，计算数表中不大于a的数之和。</p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入包含多组数据。<br>输入的第一行一个整数Q表示测试点内的数据组数，接下来Q行，每行三个整数n，m，a(|a| &lt; =10^9)描述一组数据。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对每组数据，输出一行一个整数，表示答案模2^31的值。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>2<br>4 4 3<br>10 10 5  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>20<br>148  </p></blockquote><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>1 &lt; =N．m &lt; =10^5 ，1 &lt; =Q &lt;=2×10^4</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先推试子  </p><p>先不考虑a</p><p>设$F(i)$为i的约数和<br>设$g(i)=\sum_{i|d}{\mu(\frac{d}{i})\lfloor \frac{n}{d} \rfloor \lfloor \frac{m}{d} \rfloor}$<br>可以轻松的得<br>$$ \sum_{i=1}^{n}{F(i)g(i)} = \sum_{d=1}^{n}{\lfloor \frac{n}{d} \rfloor \lfloor \frac{m}{d} \rfloor \sum_{i|d}{F(i)\mu(\frac{d}{i})}} $$  </p><p>对于$\sum_{i|d}{F(i)\mu(\frac{d}{i})}$想怎么求就怎么求  </p><p>而如果有a<br>那么我们可以离线，树状数组维护就可以  </p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define LL long longusing namespace std;unsigned int tmp1[100005], tmp2[100005], s[100005];int prime[100005], tot;int mu[100005];bool isnprime[100005];int a[100005];int N = 100000;int comp(const int &amp;c, const int &amp;b){    return s[c] &lt; s[b];}void Get_Fun(){    s[1] = mu[1] = 1;    tmp1[1] = tmp2[1] = 0;    for (int i = 2; i &lt;= N; i++)    {        if (!isnprime[i])        {            prime[++tot] = i;            mu[i] = -1;            tmp1[i] = i + 1, tmp2[i] = i;            s[i] = i + 1;        }        for (int j = 1; j &lt;= tot; j++)        {            if (i * prime[j] &gt; N)                break;            isnprime[i * prime[j]] = 1;            if (i % prime[j] == 0)            {                mu[i * prime[j]] = 0;                s[i * prime[j]] = s[i] / tmp1[i] * (tmp1[i] + tmp2[i] * prime[j]);                tmp1[i * prime[j]] = tmp1[i] + tmp2[i] * prime[j];                tmp2[i * prime[j]] = tmp2[i] * prime[j];                break;            }            mu[i*prime[j]] = -mu[i];            s[i * prime[j]] = s[i] * s[prime[j]];            tmp1[i * prime[j]] = prime[j] + 1;            tmp2[i * prime[j]] = prime[j];        }    }    for (int i = 1; i &lt;= N; i++)        a[i] = i;    sort(a + 1, a + N + 1, comp);}unsigned int Sum[100005];#define lowbit(_) ((_) &amp; (-_))void add(int a, int b){    for (int i = a; i &lt;= N; i += lowbit(i))        Sum[i] += b;}unsigned int Query(int a){    unsigned int ans = 0;    for (int i = a; i &gt; 0; i -= lowbit(i))        ans += Sum[i];    return ans;}struct data{    int n, m, a, ID;    bool operator&lt;(const data &amp;b) const    {        return a &lt; b.a;    }} Q[20005];unsigned int ans[20005];unsigned int Query(data S){    if (S.n &gt; S.m)        swap(S.n, S.m);    unsigned int ans = 0,last;    for (int i = 1; i &lt;= S.n; i = last + 1)    {        last = min(S.n / (S.n / i), S.m / (S.m / i));        ans += (Query(last) - Query(i - 1)) * (S.n / i) * (S.m / i);    }    return ans;}int main(int argc, char const *argv[]){    freopen(&quot;sdoi2014shb.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;sdoi2014shb.out&quot;,&quot;w&quot;,stdout);    int T;    Get_Fun();    scanf(&quot;%d&quot;, &amp;T);    for (int i = 1; i &lt;= T; i++)        scanf(&quot;%d%d%d&quot;, &amp;Q[i].n, &amp;Q[i].m, &amp;Q[i].a), Q[i].ID = i;    sort(Q + 1, Q + T + 1);    for (int i = 1, j = 1; i &lt;= T; i++)    {        while (s[a[j]] &lt;= Q[i].a &amp;&amp; j &lt;= N)        {            for (int k = 1; k * a[j] &lt;= N; k++)                add(k * a[j], s[a[j]] * mu[k]);            j++;        }        ans[Q[i].ID] = Query(Q[i]);    }    for (int i = 1; i &lt;= T; i++)    {        printf(&quot;%d\n&quot;,((ans[i]&lt;&lt;1)&gt;&gt;1));    }    return 0;}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/14/95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 4407 于神之怒加强版</title>
      <link>https://blog.wildrage.xyz/2017/08/13/93/</link>
      <guid>https://blog.wildrage.xyz/2017/08/13/93/</guid>
      <pubDate>Sun, 13 Aug 2017 13:11:37 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;【题目描述】&quot;&gt;&lt;a href=&quot;#【题目描述】&quot; class=&quot;headerlink&quot; title=&quot;【题目描述】&quot;&gt;&lt;/a&gt;【题目描述】&lt;/h3&gt;&lt;p&gt;给定n,m,k,计算 $\sum_{i=1}^{n}{\sum_{j=1}^{m}{gcd(i,j)^k}}$ 对1000000007取模的结果&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定n,m,k,计算 $\sum_{i=1}^{n}{\sum_{j=1}^{m}{gcd(i,j)^k}}$ 对1000000007取模的结果<br><a id="more"></a></p><h3 id="【输入格式】"><a href="#【输入格式】" class="headerlink" title="【输入格式】"></a>【输入格式】</h3><p>多组数据。<br>第一行是两个数T,K;<br>之后的T行，每行两个整数n，m；</p><h3 id="【输出格式】"><a href="#【输出格式】" class="headerlink" title="【输出格式】"></a>【输出格式】</h3><p>K行，每行一个结果</p><h3 id="【样例输入】"><a href="#【样例输入】" class="headerlink" title="【样例输入】"></a>【样例输入】</h3><blockquote><p>1 2<br>3 3   </p></blockquote><h3 id="【样例输出】"><a href="#【样例输出】" class="headerlink" title="【样例输出】"></a>【样例输出】</h3><blockquote><p>20  </p></blockquote><h3 id="【提示】"><a href="#【提示】" class="headerlink" title="【提示】"></a>【提示】</h3><p>T&lt;=2000,1&lt;=N,M,K&lt;=5000000</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>第一步推式子</p><p>$\sum_{i=1}^{n}{\sum_{j=1}^{m}{gcd(i,j)^k}}$<br>$=\sum_{d=1}^{n}{d^k\sum_{i=1}^{n}{\sum_{j=1}^{m}{[gcd(i,j)==d]}}}$<br>$=\sum_{d=1}^{n}{d^k\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}{\sum_{j=1}^{\lfloor \frac{m}{d} \rfloor}{[gcd(i,j)==1]}}}$<br>$=\sum_{d=1}^{n}{d^k\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}{\sum_{j=1}^{\lfloor \frac{m}{d} \rfloor}{\sum_{c|i,c|j}{\mu{c}}}}}$<br>另$T = dc$<br>$=\sum_{T=1}^{n}{\sum_{d|T}{d^k \mu{\frac{T}{d}} \lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor}}$<br>$=\sum_{T=1}^{n}{\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor \sum_{d|T}{d^k \mu{\frac{T}{d}}}}$  </p><p>然后我们需要线性筛出$\sum_{d|T}{d^k \mu{\frac{T}{d}}}$就可以了<br>设$g(T) = \sum_{d|T}{d^k \mu{\frac{T}{d}}}$<br>显然是积性函数<br>别问我怎么知道的<br>当互质时 $g(T<em>P) = g(T) </em> g(p)$<br>当不互质时<br>又要推狮子<br>根据$\mu$函数的定义<br>当且仅当不含平方因子时不为零<br>所以质因子只有选和不选两种状态，有用的状态数是不变的<br>每一个有用的$\mu$ 都乘了一个p^k;<br>所以$ g(T<em>p) = g(T) </em> p^k $</p><pre><code class="c++">#define LL long long#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int prime[500005], tot;const int MOD = 1000000007;bool isnprime[5000005];LL g[5000005];LL primeK[500005], n, k, m;LL N = 5000000;LL pow_mod(LL a, LL b){    LL ans = 1;    while (b)    {        if (b &amp; 1)            ans = ans * a % MOD;        b &gt;&gt;= 1;        a = a * a % MOD;    }    return ans;}void Get_g(){    g[1] = 1;    for (int i = 2; i &lt;= N; i++)    {        if (!isnprime[i])        {            prime[++tot] = i;            g[i] = (primeK[tot] = pow_mod(i, k)) - 1;        }        for (int j = 1; j &lt;= tot; j++)        {            if (i * prime[j] &gt; N)                break;            isnprime[i * prime[j]] = 1;            if (i % prime[j] == 0)            {                g[i * prime[j]] = g[i] * primeK[j] % MOD;                break;            }            g[i * prime[j]] = g[i] * g[prime[j]] % MOD;        }    }    for (int i = 2; i &lt;= N; i++)        g[i] += g[i - 1], g[i] %= MOD;}int main(){    freopen(&quot;bzoj_4407.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;bzoj_4407.out&quot;,&quot;w&quot;,stdout);    int t;    scanf(&quot;%d%lld&quot;, &amp;t, &amp;k);    Get_g();    while (t--)    {        scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);        int last;        LL ret = 0;        if (n &gt; m)            swap(n, m);        for (int i = 1; i &lt;= n; i = last + 1)        {            last = min(n / (n / i), m / (m / i));            (ret += (n / i) * (m / i) % MOD * (g[last] - g[i - 1] + MOD) % MOD)%=MOD;        }        printf(&quot;%lld\n&quot;, ret);    }}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/13/93/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 4173 数学</title>
      <link>https://blog.wildrage.xyz/2017/08/12/92/</link>
      <guid>https://blog.wildrage.xyz/2017/08/12/92/</guid>
      <pubDate>Sat, 12 Aug 2017 22:13:24 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2017/08/13/598f8195c1e7e.jpg&quot; alt=&quot;ff.jpg&quot;&gt;&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p><img src="https://i.loli.net/2017/08/13/598f8195c1e7e.jpg" alt="ff.jpg"><br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入文件的第一行输入两个正整数 。 </p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>如题</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>5 6  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>240  </p></blockquote><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>N,M&lt;=10^15</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>简单来说就是找规律</p><p>答案为a*b*phi(a)*phi(b)</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const long long MOD = 998244353;long long phi(long long x){    double ans = x;    int i = 2;    int Sqrt = ceil(sqrt(x));    while (x != 1)    {        if (i &gt; Sqrt)        {            ans *= (1 - (double)1 / x);            break;        }        if (x % i == 0)        {            ans *= (1 - (double)1 / i);            while (x % i == 0)                x /= i;        }        i++;    }    return (long long)ans;}int main(){    long long a,b;    scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b);    printf(&quot;%lld&quot;,((((a%MOD)*(b%MOD)%MOD)*(phi(a)%MOD)%MOD)*(phi(b)%MOD))%MOD);    //while(1);}﻿</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/12/92/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 3505 [Cqoi2014]数三角形</title>
      <link>https://blog.wildrage.xyz/2017/08/12/91/</link>
      <guid>https://blog.wildrage.xyz/2017/08/12/91/</guid>
      <pubDate>Sat, 12 Aug 2017 13:28:54 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;给定一个nxm的网格，请计算三点都在格点上的三角形共有多少个。下图为4x4的网格上的一个三角形。&lt;br&gt;注意三角形的三点不能共线。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给定一个nxm的网格，请计算三点都在格点上的三角形共有多少个。下图为4x4的网格上的一个三角形。<br>注意三角形的三点不能共线。<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入一行，包含两个空格分隔的正整数m和n。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一个正整数，为所求三角形数量。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>2 2</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>76</p></blockquote><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1&lt;=m,n&lt;=1000</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先用组合数算出所有的可能  </p><p>在 Gcd 去掉在一条线上的就可以了</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;long long c[1000005][4];long long gcd(long long a, long long b){    return b == 0 ? a : gcd(b, a % b);}int main(){    long long n, m;    scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);    n++, m++;    c[0][0] = 1;    for (long long i = 1; i &lt;= n * m; i++)    {        c[i][0] = 1;        for (long long j = 1; j &lt;= 3; j++)            c[i][j] = c[i - 1][j - 1] + c[i - 1][j];    }    long long ans = c[n * m][3];    ans -= c[n][3] * m;    ans -= c[m][3] * n;    for (long long i = 1; i &lt; n; i++)    {        for (long long j = 1; j &lt; m; j++)        {            long long Gcd = gcd(i, j);            if (Gcd &gt; 1)                ans -= 2 * (Gcd - 1) * (n - i) * (m - j);        }    }    printf(&quot;%lld&quot;, ans);}﻿</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/12/91/#disqus_thread</comments>
    </item>
    
    <item>
      <title>改造二叉树</title>
      <link>https://blog.wildrage.xyz/2017/08/12/90/</link>
      <guid>https://blog.wildrage.xyz/2017/08/12/90/</guid>
      <pubDate>Sat, 12 Aug 2017 13:09:24 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2017/08/12/598efe05d2ae0.png&quot; alt=&quot;20170812080419_23272.png&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="https://i.loli.net/2017/08/12/598efe05d2ae0.png" alt="20170812080419_23272.png"></p><a id="more"></a><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><blockquote><p>3<br>2 2 2<br>1 0<br>1 1  </p></blockquote><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><blockquote><p>2  </p></blockquote><p><img src="https://i.loli.net/2017/08/12/598f0119dabfa.png" alt="20170812080428_12682.png"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先中序遍历<br>然后按a[i] - i 跑 最长不降子序列</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct Tree{    int ch[2];    int v;} Node[100005];int a[100005], Ind, val[100005], c[100005];void dfs(int rt){    if (rt)    {        dfs(Node[rt].ch[0]);        a[++Ind] = Node[rt].v;        dfs(Node[rt].ch[1]);    }}int f[100005], Max[100005];int tot;inline int lowbit(int x) { return x &amp; (-x); }void Update(int x, int val){    for (int i = x; i &lt;= tot; i += lowbit(i))        Max[i] = max(Max[i], val);    return;}int Query(int x){    int ans = 0;    for (int i = x; i; i -= lowbit(i))        ans = max(ans, Max[i]);    return ans;}int main(){    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i++)    {        scanf(&quot;%d&quot;, &amp;Node[i].v);    }    int fa, d;    for (int i = 2; i &lt;= n; i++)    {        scanf(&quot;%d%d&quot;, &amp;fa, &amp;d);        Node[fa].ch[d] = i;    }    dfs(1);    //memset(f, 0x7f, sizeof(f));    for (int i = 1; i &lt;= n; i++)    {        a[i] = a[i] - i;        c[i] = a[i];    }    int ans = 0;    sort(a + 1, a + n + 1);    tot = unique(a + 1, a + n + 1) - a - 1;    for (int i = 1; i &lt;= n; i++)    {        int now = lower_bound(a + 1, a + tot + 1, c[i]) - a;        f[i] = Query(now) + 1;        Update(now, f[i]);        ans = max(ans, f[i]);    }    printf(&quot;%d&quot;, n - ans);    //while(1);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/12/90/#disqus_thread</comments>
    </item>
    
    <item>
      <title>序列</title>
      <link>https://blog.wildrage.xyz/2017/08/12/89/</link>
      <guid>https://blog.wildrage.xyz/2017/08/12/89/</guid>
      <pubDate>Sat, 12 Aug 2017 12:38:23 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2017/08/12/598ef6e160efc.png&quot; alt=&quot;20170812080316_85064.png&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="https://i.loli.net/2017/08/12/598ef6e160efc.png" alt="20170812080316_85064.png"></p><a id="more"></a><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><blockquote><p>5 3<br>2 4 2 3 4  </p></blockquote><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><blockquote><p>39  </p></blockquote><p><img src="https://i.loli.net/2017/08/12/598ef7763147d.png" alt="20170812080326_67661.png"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>从比他小的中找<br>组合数一搞就行  </p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define LL long longconst LL P = 1e9 + 7;LL F[100005];void Init(){    F[0] = 1;    for (int i = 1; i &lt;= 100000; i++)        F[i] = i * F[i - 1] % P;}LL pow_mod(LL a, int b){    LL ans = 1;    while (b)    {        if (b &amp; 1)            ans = ans * a % P;        b &gt;&gt;= 1;        a = a * a % P;    }    return ans;}LL C(int n, int m){    if (m &gt; n || m &lt; 0)        return 0;    return F[n] * pow_mod(F[m] * F[n - m] % P, P - 2) % P;}LL a[100005], Has[100005];int Sum[100005], n;#define lowbit(_) ((_) &amp; (-_))void add(int x, int c){    for (int i = x; i &lt;= n; i += lowbit(i))        Sum[i] += c;}int Query(int x){    int ans = 0;    for (int i = x; i &gt; 0; i -= lowbit(i))        ans += Sum[i];    return ans;}int fron[100005], nxt[100005];int main(){    Init();    int K;    scanf(&quot;%d%d&quot;, &amp;n, &amp;K);    for (int i = 1; i &lt;= n; i++)    {        scanf(&quot;%lld&quot;, &amp;a[i]);    }    sort(a + 1, a + n + 1);    LL ans = 0;    for (int i = 1; i &lt;= n; i++)    {        ans = (ans + a[i] * C(i - 1, K - 1)) % P;    }    printf(&quot;%lld\n&quot;, ans);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/12/89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>灌水</title>
      <link>https://blog.wildrage.xyz/2017/08/12/88/</link>
      <guid>https://blog.wildrage.xyz/2017/08/12/88/</guid>
      <pubDate>Sat, 12 Aug 2017 12:19:27 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2017/08/12/598ef4efe3fdf.png&quot; alt=&quot;20170812080054_73383.png&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="https://i.loli.net/2017/08/12/598ef4efe3fdf.png" alt="20170812080054_73383.png"></p><a id="more"></a><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><blockquote><p>样例输入1：<br>3 1<br>样例输出1：<br>3 1 2<br>样例输入2：<br>4 1<br>样例输出2：<br>4 3 1 2<br>样例输入3：<br>8 17<br>样例输出3：<br>6 2 3 1 8 4 5 7  </p></blockquote><p>提示</p><p><img src="https://i.loli.net/2017/08/12/598ef5a148e72.png" alt="20170812080119_26860.png"></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先找规律然后瞎搞就可以了</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define LL long longLL Sum[1000005];LL x;int ans[1000005];int main(){    int n;    scanf(&quot;%d%lld&quot;, &amp;n, &amp;x);    for (int i = n - 2; i &gt;= 0; i--)        Sum[i] = Sum[i + 1] + i;    if (Sum[0] &lt; x)    {        puts(&quot;-1&quot;);        return 0;    }    int k, i, j;    for (k = 1; k &lt;= n - 2; k++)        if (x &gt; Sum[k])            break;    x = x - Sum[k];    for (i = n - k, j = 1; i &lt;= n - 1; i++, j++)        ans[j] = i;    for (i = 1; i &lt;= n - k - 1; i++, j++)        ans[j] = i;    ans[n] = n;    i = 1;    while (x--)    {        swap(ans[i], ans[i + 1]);        i++;    }    for (i = 1; i &lt; n; i++)        printf(&quot;%d &quot;, ans[i]);    printf(&quot;%d\n&quot;, ans[n]);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/12/88/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[JLOI2011]飞行路线</title>
      <link>https://blog.wildrage.xyz/2017/08/10/87/</link>
      <guid>https://blog.wildrage.xyz/2017/08/10/87/</guid>
      <pubDate>Thu, 10 Aug 2017 13:17:13 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Alice和Bob现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在n个城市设有业务，设这些城市分别标记为0到n-1，一共有m种航线，每种航线连接两个城市，并且航线有一定的价格。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Alice和Bob现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在n个城市设有业务，设这些城市分别标记为0到n-1，一共有m种航线，每种航线连接两个城市，并且航线有一定的价格。</p><a id="more"></a><p>Alice和Bob现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多k种航线上搭乘飞机。那么Alice和Bob这次出行最少花费多少？</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>数据的第一行有三个整数，n,m,k，分别表示城市数，航线数和免费乘坐次数。<br>第二行有两个整数，s,t，分别表示他们出行的起点城市编号和终点城市编号。(0&lt;=s,t&lt;n)<br>接下来有m行，每行三个整数，a,b,c，表示存在一种航线，能从城市a到达城市b，或从城市b到达城市a，价格为c。(0&lt;=a,b&lt;n,a与b不相等，0&lt;=c&lt;=1000)</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>只有一行，包含一个整数，为最少花费。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>5 6 1<br>0 4<br>0 1 5<br>1 2 5<br>2 3 5<br>3 4 5<br>2 3 3<br>0 2 100  </p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>8  </p></blockquote><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>对于30%的数据,2&lt;=n&lt;=50,1&lt;=m&lt;=300,k=0;<br>对于50%的数据,2&lt;=n&lt;=600,1&lt;=m&lt;=6000,0&lt;=k&lt;=1;<br>对于100%的数据,2&lt;=n&lt;=10000,1&lt;=m&lt;=50000,0&lt;=k&lt;=10.</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>二维SPFA优化一下</p><pre><code class="c++">#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;struct edge{    int END, next, v;} v[100005];int first[10005], p;void add(int a, int b, int c){    v[p].END = b;    v[p].next = first[a];    v[p].v = c;    first[a] = p++;}int dis[10005][11];bool flag[10005][11];int Top;struct data{    int k, tmp;    bool operator&lt;(const data &amp;a) const    {        return dis[k][tmp] &gt; dis[a.k][a.tmp];    }};int Spfa(int S, int T){    memset(dis, 0x3f, sizeof(dis));    flag[S][0] = 1;    priority_queue&lt;data&gt; Q;    Q.push((data){S, 0});    dis[S][0] = 0;    while (!Q.empty())    {        int k = Q.top().k;        int tmp = Q.top().tmp;        flag[k][tmp] = 0;        Q.pop();        for (int i = first[k]; i != -1; i = v[i].next)        {            if (dis[v[i].END][tmp] &gt; dis[k][tmp] + v[i].v)            {                dis[v[i].END][tmp] = dis[k][tmp] + v[i].v;                if (!flag[v[i].END][tmp])                {                    flag[v[i].END][tmp] = 1;                    Q.push((data){v[i].END, tmp});                }            }            if (dis[v[i].END][tmp + 1] &gt; dis[k][tmp] &amp;&amp; tmp + 1 &lt;= Top)            {                dis[v[i].END][tmp + 1] = dis[k][tmp];                if (!flag[v[i].END][tmp + 1])                {                    flag[v[i].END][tmp + 1] = 1;                    Q.push((data){v[i].END, tmp + 1});                }            }        }    }    int ans = 0x7fffffff;    for (int i = 0; i &lt;= Top; i++)        ans = min(ans, dis[T][i]);    return ans;}int main(int argc, char const *argv[]){    memset(first, -1, sizeof(first));    int n, m;    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;Top);    int S, T;    scanf(&quot;%d%d&quot;, &amp;S, &amp;T);    S++, T++;    int a, b, c;    for (int i = 1; i &lt;= m; i++)    {        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);        add(a + 1, b + 1, c);        add(b + 1, a + 1, c);    }    printf(&quot;%d&quot;, Spfa(S, T));    return 0;}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/10/87/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Function</title>
      <link>https://blog.wildrage.xyz/2017/08/10/86/</link>
      <guid>https://blog.wildrage.xyz/2017/08/10/86/</guid>
      <pubDate>Thu, 10 Aug 2017 13:16:58 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;https://moetu.fastmirror.org/images/2017/08/10/20170810100243_44388428d5.png&quot; alt=&quot;20170810100243_44388428d5.png&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="https://moetu.fastmirror.org/images/2017/08/10/20170810100243_44388428d5.png" alt="20170810100243_44388428d5.png"></p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>暴力搞就可以<br>先预处理出所有范围内的函数值<br>卡卡常<a href="https://raw.githubusercontent.com/HZOI/Share/master/%E8%AF%BE%E4%BB%B6/wys-full.pdf" target="_blank" rel="noopener">-Owys</a></p><p>直接O(1) 查询就可以了</p><pre><code class="c++">/********************************************************************************* @file Function* @author   WildRage* @version v 1.0* @date 2017-8-10 10:57:28* @brief *******************************************************************************/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define LL long longLL a[1005], b[1005], c[1005];LL Max[200005];int fix = 100001;int main(){    memset(Max, 0x80, sizeof(Max));    int n, q;    scanf(&quot;%d%d&quot;, &amp;n, &amp;q);    for (int i = 1; i &lt;= n; i++)    {        scanf(&quot;%lld%lld%lld&quot;, &amp;a[i], &amp;b[i], &amp;c[i]);    }    LL u;    for (int i = -100000; i &lt;= 100000; i++)    {        for (int j = 1; j &lt;= n; j++)        {            Max[i + fix] = max(Max[i + fix], a[j] * i * i + b[j] * i + c[j]);        }    }    while (q--)    {        scanf(&quot;%lld&quot;, &amp;u);        printf(&quot;%lld\n&quot;, Max[u + fix]);    }    return 0;}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/10/86/#disqus_thread</comments>
    </item>
    
    <item>
      <title>公主的朋友</title>
      <link>https://blog.wildrage.xyz/2017/08/10/85/</link>
      <guid>https://blog.wildrage.xyz/2017/08/10/85/</guid>
      <pubDate>Thu, 10 Aug 2017 13:08:31 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;由于 Wulala 在上个问题中的精彩表现，公主认为 Wulala 是一个很棒的人，就把 Wulala 留在了 X 国。这时正好公主的一位传教士朋友来拜访公主，于是想找 wulala 帮忙X 国如同一条直线，其中有 n 个城市,从东向西分别编号为 1~n。而他的国家中有 m 种宗教，每个城市一定会有一种信仰的宗教。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>由于 Wulala 在上个问题中的精彩表现，公主认为 Wulala 是一个很棒的人，就把 Wulala 留在了 X 国。这时正好公主的一位传教士朋友来拜访公主，于是想找 wulala 帮忙X 国如同一条直线，其中有 n 个城市,从东向西分别编号为 1~n。而他的国家中有 m 种宗教，每个城市一定会有一种信仰的宗教。<br><a id="more"></a><br>有时候有些城市为了获得更多的认可，会派出信仰本城市宗教的传教士前往其他国家。X 国<br>的传教士都十分厉害，只要是他途经的地方都会改信他所传播的宗教。<br>传教士们在路上碰到自己宗教的城市自然就不用传教了，可以停下来看看里番啥的，所以每<br>一个传教士在旅行前都会计算自己可以在多少城市停下来(不包括起始的城市)。<br>而传教士们都是文科僧，数学是很差的，所以他希望 Wulala 能帮他计算。可 Wulala 数学也不好，但他又不想在公主面前丢脸，你能帮帮他吗？</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第一行两个整数 n，m<br>第二行 n 个整数第 i 个整数代表第 i 各城市信仰的宗教<br>第三行一个整数 T 代表传教士的个数<br>接下来 T 行每行两个整数 x，y 代表 x 城向 y 城派遣了一个传教士(保证 x &lt; y)</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出 T 行，第 i 行代表第 i 个传教士询问的答案</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>2 2<br>1 2<br>2<br>1 2<br>1 2  </p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>0<br>1  </p></blockquote><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>对于 30%的数据 n &lt;= 100000, m &lt;= 10, T &lt;= 100<br>对于 60%的数据 n &lt;= 100000, m &lt;= 10, T &lt;= 100000<br>对于 100%的数据 n &lt;= 100000, m &lt;= 300, T &lt;= 100000</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>分块直接维护就可以了<br>原来分块也可以是正解</p><pre><code class="c++">/********************************************************************************* @file Wulala* @author   WildRage* @version v 0.9* @date 2017-8-10 10:58:12* @brief *******************************************************************************/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100001, M = 301;int a[N], in[N], n, m;int Sum[500][305], Change[500];int block;int lp[500], rp[500];int Query(int l, int r){    int L = in[l], R = in[r];    int ans = 0;    bool flag = 0;    if (L == R)    {        if (Change[L])            return r - l;        for (int i = l + 1; i &lt;= r; i++)        {            if (a[i] == a[l])                ans++;            a[i] = a[l];        }        for (int i = lp[L]; i &lt; l; i++)            if (a[i] != a[l])            {                flag = 1;                break;            }        if (flag == 1)            return ans;        for (int i = r + 1; i &lt;= rp[R]; i++)        {            if (a[i] != a[l])            {                flag = 1;                break;            }        }        if (flag == 0)            Change[L] = a[l];        return ans;    }    else    {        if (Change[L] == a[l])            ans += (rp[L] - l);        else        {            flag = 0;            for (int i = l + 1; i &lt;= rp[L]; i++)            {                if (a[i] == a[l])                    ans++;                a[i] = a[l];            }            for (int i = lp[L]; i &lt; l; i++)                if (a[i] != a[l])                {                    flag = 1;                    break;                }            if (!flag)                Change[L] = a[l];        }        if (Change[R])        {            if (Change[R] == a[l])                ans += (r - lp[R] + 1);            else            {                for (int i = lp[R]; i &lt;= r; i++)                    a[i] = a[l];                Change[R] = 0;            }        }        else        {            flag = 0;            for (int i = lp[R]; i &lt;= r; i++)            {                if (a[i] == a[l])                    ans++;                a[i] = a[l];            }            for (int i = r + 1; i &lt;= rp[R]; i++)                if (a[i] != a[l])                {                    flag = 1;                    break;                }            if (!flag)                Change[R] = a[l];        }        for (int i = L + 1; i &lt; R; i++)        {            if (Change[i])            {                if (Change[i] == a[l])                    ans += block;                else                {                    for (int j = lp[i]; j &lt;= rp[i]; j++)                        a[j] = a[l];                    Change[i] = a[l];                }            }            else            {                for(int j = lp[i];j&lt;=rp[i];j++)                {                    if(a[j]==a[l])                        ans++;                    a[j] = a[l];                }                Change[i] = a[l];            }        }        return ans;    }}int main(){    int c, b;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    block = 316;    for (int i = 1; i &lt;= n; i++)    {        scanf(&quot;%d&quot;, &amp;a[i]);        in[i] = (i - 1) / block + 1;        Sum[in[i]][a[i]]++;    }    for (int i = 1; i &lt;= in[n]; i++)        lp[i] = (i - 1) * block + 1, rp[i] = min(n, i * block);    int T;    scanf(&quot;%d&quot;, &amp;T);    while (T--)    {        scanf(&quot;%d%d&quot;, &amp;c, &amp;b);        int ans = Query(c, b);        printf(&quot;%d\n&quot;, ans);    }}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/10/85/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Evensgn 剪树枝</title>
      <link>https://blog.wildrage.xyz/2017/08/10/84/</link>
      <guid>https://blog.wildrage.xyz/2017/08/10/84/</guid>
      <pubDate>Thu, 10 Aug 2017 13:04:03 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;繁华中学有一棵苹果树。苹果树有 n 个节点（也就是苹果），n − 1 条边（也就&lt;br&gt;是树枝）。调皮的 Evensgn 爬到苹果树上。他发现这棵苹果树上的苹果有两种：一&lt;br&gt;种是黑苹果，一种是红苹果。Evensgn 想要剪掉 k 条树枝，将整棵树分成 k + 1 个&lt;br&gt;部分。他想要保证每个部分里面有且仅有一个黑苹果。请问他一共有多少种剪树枝&lt;br&gt;的方案？&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>繁华中学有一棵苹果树。苹果树有 n 个节点（也就是苹果），n − 1 条边（也就<br>是树枝）。调皮的 Evensgn 爬到苹果树上。他发现这棵苹果树上的苹果有两种：一<br>种是黑苹果，一种是红苹果。Evensgn 想要剪掉 k 条树枝，将整棵树分成 k + 1 个<br>部分。他想要保证每个部分里面有且仅有一个黑苹果。请问他一共有多少种剪树枝<br>的方案？<br><a id="more"></a></p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第一行一个数字 n，表示苹果树的节点（苹果）个数。<br>第二行一共 n − 1 个数字 p0, p1, p2, p3, …, pn−2，pi 表示第 i + 1 个节点和 pi 节<br>点之间有一条边。注意，点的编号是 0 到 n − 1。<br>第三行一共 n 个数字 x0, x1, x2, x3, …, xn−1。如果 xi 是 1，表示 i 号节点是黑<br>苹果；如果 xi 是 0，表示 i 号节点是红苹果。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出一个数字，表示总方案数。答案对 109 + 7 取模。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>样例输入 1<br>3<br>0 0<br>0 1 1<br>样例输入 2<br>6<br>0 1 1 0 4<br>1 1 0 0 1 0<br>样例输入 3<br>10<br>0 1 2 1 4 4 4 0 8<br>0 0 0 1 0 1 1 0 0 1  </p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>样例输出 1<br>2<br>样例输出 2<br>1<br>样例输出 3<br>27  </p></blockquote><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>数据范围<br>对于 30% 的数据，1 ≤ n ≤ 10。<br>对于 60% 的数据，1 ≤ n ≤ 100。<br>对于 80% 的数据，1 ≤ n ≤ 1000。<br>对于 100% 的数据，1 ≤ n ≤ 105。<br>对于所有数据点，都有 0 ≤ pi ≤ n − 1，xi = 0 或 xi = 1。<br>特别地，60% 中、80% 中、100% 中各有一个点，树的形态是一条链。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题解链接<a href="http://blog.csdn.net/ren_ivan/article/details/77053836" target="_blank" rel="noopener">Evensgn 剪树枝 树规 Ivan</a></p><p>f[x][0]表示与其父边相连的连通块内没有黑苹果的方案数，<br>f[x][1]则表示有黑苹果，<br>如果父边被切断，相当于没有黑苹果<br>初始化时，假设切掉父边，f[x][0]=1,f[x][1]=0;<br>递归回时转移,每递归回一个子树,f[x][1]=f[x][1]*f[v][0]+f[x][0]*f[v][1],f[x][0]=f[x][0]*f[v][0];<br>最后处理完每个子树时,若其为黑苹果f[x][1]=f[x][0],否则f[x][0]=f[x][0]+f[x][1]（可以切掉）  </p><p>Mycode</p><pre><code class="c++">/********************************************************************************* @file Evensgn* @author WildRage* @version v 1.0* @date  2017-5-10 10:55:23* @brief *******************************************************************************/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;const int P = 1e9 + 7;namespace Mine_WorkSpace{struct data{    struct edge    {        int END, next;    } v[200005];    int first[100005], p;    data()    {        memset(first, -1, sizeof(first));        p = 0;    }    void add(int a, int b)    {        v[p].END = b;        v[p].next = first[a];        first[a] = p++;    }} Edge;bool color[100005];long long f[100005][2];void  DP(int rt, int fa){    f[rt][0] = 1;    f[rt][1] = 0;    for (int i = Edge.first[rt]; i != -1; i = Edge.v[i].next)    {        if (fa != Edge.v[i].END)        {            DP(Edge.v[i].END, rt);            f[rt][1] = (f[rt][1] * f[Edge.v[i].END][0]) % P;            f[rt][1] = (f[rt][1] + f[Edge.v[i].END][1] * f[rt][0]) % P;            f[rt][0] = (f[rt][0] * f[Edge.v[i].END][0]) % P;        }    }    if (color[rt])        f[rt][1] = f[rt][0];    else        f[rt][0] = (f[rt][1] + f[rt][0]) % P;}int Main(){    int n;    scanf(&quot;%d&quot;, &amp;n);    int a, b;    for (int i = 1; i &lt; n; i++)    {        scanf(&quot;%d&quot;, &amp;b);        Edge.add(i + 1, b + 1), Edge.add(b + 1, i + 1);    }    for (int i = 1; i &lt;= n; i++)    {        scanf(&quot;%d&quot;, &amp;a);        if (a)            color[i] = 1;    }    DP(1,0);    printf(&quot;%lld\n&quot;, f[1][1]);    // Print_tree(1);    // while(1);}}int main() { Mine_WorkSpace::Main(); }</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/10/84/#disqus_thread</comments>
    </item>
    
    <item>
      <title> [NOI2017] 蚯蚓排队</title>
      <link>https://blog.wildrage.xyz/2017/08/09/82/</link>
      <guid>https://blog.wildrage.xyz/2017/08/09/82/</guid>
      <pubDate>Wed, 09 Aug 2017 13:24:05 GMT</pubDate>
      <description>
      
        &lt;p&gt;题目描述&lt;br&gt;蚯蚓幼儿园有nnn只蚯蚓。幼儿园园长神刀手为了管理方便，时常让这些蚯蚓们列队表演。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>题目描述<br>蚯蚓幼儿园有nnn只蚯蚓。幼儿园园长神刀手为了管理方便，时常让这些蚯蚓们列队表演。<br><a id="more"></a><br>所有蚯蚓用从 1 到 n 的连续正整数编号。每只蚯蚓的长度可以用一个正整数表示，根据入园要求，所有蚯蚓的长度都不超过 6 。神刀手希望这些蚯蚓排成若干个队伍，初始时，每只蚯蚓各自排成一个仅有一只蚯蚓的队伍，该蚯蚓既在队首，也在队尾。</p><p>神刀手将会依次进行 m 次操作，每个操作都是以下三种操作中的一种：</p><p>给出 i 和 j ，令 i 号蚯蚓与 j 号蚯蚓所在的两个队伍合并为一个队伍，具体来说，令 j 号蚯蚓紧挨在 i 号蚯蚓之后，其余蚯蚓保持队伍的前后关系不变。<br>给出 i ，令 i 号蚯蚓与紧挨其后的一只蚯蚓分离为两个队伍，具体来说，在分离之后， i 号蚯蚓在其中一个队伍的队尾，原本紧挨其后的那一只蚯蚓在另一个队伍的队首，其余蚯蚓保持队伍的前后关系不变。<br>给出一个正整数 k 和一个长度至少为 k 的数字串 s ，对于 s 的每个长度为 k 的连续子串 t （这样的子串共有 ∣s∣−k+1 个，其中 ∣s∣|s|∣s∣ 为 s 的长度），定义函数 f(t) ，询问所有这些f(t)的乘积对 998244353 取模后的结果。其中f(t)的定义如下：<br>对于当前的蚯蚓队伍，定义某个蚯蚓的向后 k 数字串为：从该蚯蚓出发，沿队伍的向后方向，寻找最近的 k 只蚯蚓（包括其自身），将这些蚯蚓的长度视作字符连接而成的数字串；如果这样找到的蚯蚓不足 k 只，则其没有向后k数字串。例如蚯蚓的队伍为 10 号蚯蚓在队首，其后是 22 号蚯蚓，其后是 3 号蚯蚓（为队尾），这些蚯蚓的长度分别为 4 、 5 、 6 ，则 10 号蚯蚓的向后 3 数字串为456， 22 号蚯蚓没有向后 3 数字串，但其向后 2 数字串为56，其向后 1 数字串为5。</p><p>而 f(t) 表示所有蚯蚓中，向后 k 数字串恰好为 t 的蚯蚓只数。<br>输入格式<br>从标准输入读入数据。</p><p>输入文件的第一行有两个正整数 n,m ，分别表示蚯蚓的只数与操作次数。</p><p>第二行包含 n 个不超过 6 的正整数，依次表示编号为<br>1,2,…,n的蚯蚓的长度。</p><p>!!!</p><h3 id="不想粘题了"><a href="#不想粘题了" class="headerlink" title="不想粘题了"></a>不想粘题了</h3><p>好气</p><p>链接<a href="https://loj.ac/problem/2303" target="_blank" rel="noopener">LOJ</a>  </p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>哈希能过<br>但要注意一下</p><p>每合并一次就相当于增加了50^2种情况<br>合并和拆分是一样的<br>然后查询的时候硬跑就可以了</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define LL unsigned long longconst int N = 300010, M = 15000010, L = 20000010;const LL P = 23333333, p = 1000007, mod = 998244353;int head[P], next[L], cnt[L], E, Next[N], Pre[N], a[N];LL w[L], Pow[60];int n, m;char str[L];void Insert(LL x, int y){    LL now = x % P;    bool flag = 0;    for (int i = head[now]; i; i = next[i])        if (w[i] == x)        {            cnt[i] += y;            flag = 1;            break;        }    if (!flag)    {        next[++E] = head[now];        head[now] = E;        cnt[E] = 1;        w[E] = x;    }}int Query(LL x){    LL now = x % P;    for (int i = head[now]; i; i = next[i])        if (w[i] == x)            return cnt[i];    return 0;}void Change(int x, int y){    int now = x;    for (int k = 1; k &lt;= 50; k++)    {        int ret = now;        LL Hash = a[now];        for (int j = 1; j &lt;= k; j++)        {            ret = Next[ret];            Hash = Hash * p + a[ret];        }        for (int l = k + 1; l &lt;= 50; l++)        {            Insert(Hash, y);            ret = Next[ret];            if (!ret)                break;            Hash = Hash * p + a[ret];        }        now = Pre[now];        if (!now)            break;    }}int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i++)    {        scanf(&quot;%d&quot;, &amp;a[i]);        Insert(a[i], 1);    }    Pow[0] = 1;    for (int i = 1; i &lt;= 50; i++)    {        Pow[i] = Pow[i - 1] * p;    }    int op;    int x, y;    for (int i = 1; i &lt;= m; i++)    {        scanf(&quot;%d&quot;, &amp;op);        if (op == 1)        {            scanf(&quot;%d%d&quot;, &amp;x, &amp;y);            Next[x] = y;            Pre[y] = x;            Change(x, 1);        }        else if (op == 2)        {            scanf(&quot;%d&quot;, &amp;x);            Change(x, -1);            Pre[Next[x]] = 0, Next[x] = 0;        }        else        {            scanf(&quot;%s&quot;, str + 1);            scanf(&quot;%d&quot;, &amp;x);            LL ret = 0;            for (int i = 1; i &lt;= x; i++)                ret = ret * p + str[i] - &#39;0&#39;;            LL ans = Query(ret);            LL len = strlen(str + 1);            for (int i = x + 1; i &lt;= len; i++)            {                ret = ret - (str[i - x] - &#39;0&#39;) * Pow[x - 1];                ret = ret * p + (str[i] - &#39;0&#39;);                ans = ans * Query(ret) % mod;            }            printf(&quot;%lld\n&quot;, ans);        }    }}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/09/82/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 4299 Codechef FRBSUM</title>
      <link>https://blog.wildrage.xyz/2017/08/09/83/</link>
      <guid>https://blog.wildrage.xyz/2017/08/09/83/</guid>
      <pubDate>Wed, 09 Aug 2017 13:24:05 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;数集S的ForbiddenSum定义为无法用S的某个子集（可以为空）的和表示的最小的非负整数。&lt;br&gt;例如，S={1,1,3,7}，则它的子集和中包含0(S’=∅)，1(S’={1})，2(S’={1,1})，3(S’={3})，4(S’={1,3})，5(S’ = {1, 1, 3})，但是它无法得到6。因此S的ForbiddenSum为6。&lt;br&gt;给定一个序列A，你的任务是回答该数列的一些子区间所形成的数集的ForbiddenSum是多少。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>数集S的ForbiddenSum定义为无法用S的某个子集（可以为空）的和表示的最小的非负整数。<br>例如，S={1,1,3,7}，则它的子集和中包含0(S’=∅)，1(S’={1})，2(S’={1,1})，3(S’={3})，4(S’={1,3})，5(S’ = {1, 1, 3})，但是它无法得到6。因此S的ForbiddenSum为6。<br>给定一个序列A，你的任务是回答该数列的一些子区间所形成的数集的ForbiddenSum是多少。<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入数据的第一行包含一个整数N，表示序列的长度。<br>接下来一行包含N个数，表示给定的序列A（从1标号）。<br>接下来一行包含一个整数M，表示询问的组数。<br>接下来M行，每行一对整数，表示一组询问。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每组询问，输出一行表示对应的答案。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>5<br>1 2 4 9 10<br>5<br>1 1<br>1 2<br>1 3<br>1 4<br>1 5  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>2<br>4<br>8<br>8<br>8  </p></blockquote><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>对于100%的数据，1≤N,M≤100000,1≤A_i≤10^9，1≤A_1+A_2+…+A_N≤10^9。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>可以看出</p><p>如果一个区间能组出1~n的数而且有一个数小于等于n+1<br>则这个区间一定能构造出 n+1</p><p>然后就可以了</p><p>用主席树维护一下就可以了</p><p>复习一下主席树</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 1e9;struct Seg_Node{    int l, r;    Seg_Node *ch[2];    int Sum;} * root[100005], *null;int a[100005];Seg_Node *NewSeg_Node(){    Seg_Node *S = new Seg_Node();    S-&gt;ch[0] = S-&gt;ch[1] = null;    return S;}void copy(Seg_Node *&amp;a, Seg_Node *b){    if (b == null)        a = null;    else        a = NewSeg_Node(), *a = *b;}void Update(int v, int l, int r, Seg_Node *&amp;rt1, Seg_Node *rt2){    copy(rt1, rt2);    if(rt1==null)        rt1=NewSeg_Node();    rt1-&gt;Sum += v;    rt1-&gt;l = l, rt1-&gt;r = r;    if (l == r)        return;    int m = l + r &gt;&gt; 1;    if (v &lt;= m)    {        Update(v, l, m, rt1-&gt;ch[0], rt2-&gt;ch[0]);    }    else    {        Update(v, m + 1, r, rt1-&gt;ch[1], rt2-&gt;ch[1]);    }}int Query(int R, int l, int r, Seg_Node *rt1, Seg_Node *rt2){    if (R &gt;= r)        return rt1-&gt;Sum - rt2-&gt;Sum;    int m = l + r &gt;&gt; 1;    if (R &lt;= m)        return Query(R, l, m, rt1-&gt;ch[0], rt2-&gt;ch[0]);    return Query(R, l, m, rt1-&gt;ch[0], rt2-&gt;ch[0]) + Query(R, m + 1, r, rt1-&gt;ch[1], rt2-&gt;ch[1]);}int main(){    null = new Seg_Node();    null-&gt;ch[0] = null-&gt;ch[1] = null;    root[0] = null;    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i++)        scanf(&quot;%d&quot;, &amp;a[i]);    for (int i = 1; i &lt;= n; i++)    {        Update(a[i], 1, 1e9, root[i], root[i - 1]);    }    int m;    scanf(&quot;%d&quot;, &amp;m);    int a, b, ans;    while (m--)    {        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);        int res = 1;        ans = min(INF, Query(res, 1, 1e9, root[b], root[a - 1]));        while (ans &gt;= res &amp;&amp; res &lt; 1e9)        {            res = ans + 1;            ans = min(INF, Query(res, 1, 1e9, root[b], root[a - 1]));        }        printf(&quot;%d\n&quot;, ans + 1);    }}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/09/83/#disqus_thread</comments>
    </item>
    
    <item>
      <title>permutation</title>
      <link>https://blog.wildrage.xyz/2017/08/09/81/</link>
      <guid>https://blog.wildrage.xyz/2017/08/09/81/</guid>
      <pubDate>Wed, 09 Aug 2017 12:45:13 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;3-1-题目描述&quot;&gt;&lt;a href=&quot;#3-1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;3.1 题目描述&quot;&gt;&lt;/a&gt;3.1 题目描述&lt;/h3&gt;&lt;p&gt;一个长度为n 的排列p[1..n]&lt;br&gt;把排列的每个循环拿出来，写成标准循环，再做一次排序&lt;br&gt;比如[4, 1, 6, 2, 5, 3]，有3 个循环(421)(63)(5)&lt;br&gt;其中第一个循环就是4 要到2 的位置，2 要到1 的位置，1 要到4 的位置&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="3-1-题目描述"><a href="#3-1-题目描述" class="headerlink" title="3.1 题目描述"></a>3.1 题目描述</h3><p>一个长度为n 的排列p[1..n]<br>把排列的每个循环拿出来，写成标准循环，再做一次排序<br>比如[4, 1, 6, 2, 5, 3]，有3 个循环(421)(63)(5)<br>其中第一个循环就是4 要到2 的位置，2 要到1 的位置，1 要到4 的位置<br><a id="more"></a><br>每个循环从任意一个位置开始读都是一样的<br>比如(412) 也是(124),(241)。n 个循环就一共n 个表达法<br>我们规定一个标准循环是以循环内最大的数字开头<br>循环之间排序的关键字就是第一个数字的大小<br>如(421)(63)(5) 排序后是(421)(5)(63)<br>如果排序后的拍列和原排列一样，那么就是可行排列<br>求n 个数的字典序第k 大的排列</p><h3 id="3-2-输入格式"><a href="#3-2-输入格式" class="headerlink" title="3.2 输入格式"></a>3.2 输入格式</h3><p>两个整数，n，k 保证k 在long long 范围内，保证有解</p><h3 id="3-3-输出格式"><a href="#3-3-输出格式" class="headerlink" title="3.3 输出格式"></a>3.3 输出格式</h3><p>n 个整数，表示满足条件的排列</p><h3 id="3-4-Sample-Input1"><a href="#3-4-Sample-Input1" class="headerlink" title="3.4 Sample Input1"></a>3.4 Sample Input1</h3><blockquote><p>4 3  </p></blockquote><h3 id="3-5-Sample-Output1"><a href="#3-5-Sample-Output1" class="headerlink" title="3.5 Sample Output1"></a>3.5 Sample Output1</h3><p>1 3 2 4  </p><h3 id="3-6-Sample-Input2"><a href="#3-6-Sample-Input2" class="headerlink" title="3.6 Sample Input2"></a>3.6 Sample Input2</h3><p>10 1  </p><h3 id="3-7-Sample-Output2"><a href="#3-7-Sample-Output2" class="headerlink" title="3.7 Sample Output2"></a>3.7 Sample Output2</h3><p>1 2 3 4 5 6 7 8 9 10  </p><h3 id="3-8-数据范围及约定"><a href="#3-8-数据范围及约定" class="headerlink" title="3.8 数据范围及约定"></a>3.8 数据范围及约定</h3><p>对于30% 的数据满足：1 &lt;= n &lt;= 10<br>对于100% 的数据满足，1 &lt;= n &lt;= 50</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>不要被卡读题  </p><p>什么是循环  </p><p>比如说 题目中的例子</p><p>4本应在的位置为2在的位置<br>2本应在的位置为1在的位置<br>1本应在的位置为4在的位置<br>这就是一个循环  </p><p>然后先打一个表找规律</p><p>我们会惊讶的发现他好像和斐波那契有关  </p><p>而且只会有相邻的两个数调换</p><p>然后按照规律跑就可以了  </p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;using namespace std;#define LL long longLL f[55], Sum[55];int a[55];bool mark[55];int main(){    LL n, k;    scanf(&quot;%lld%lld&quot;, &amp;n, &amp;k);    f[0] = f[1] = f[2] = 1;    Sum[0] = 1, Sum[1] = 2, Sum[2] = 3;    for (int i = 3; i &lt;= n; i++)    {        f[i] = f[i - 1] + f[i - 2];        Sum[i] = Sum[i - 1] + f[i];    }    for (int i = 1; i &lt;= n; i++)        a[i] = i;    while (k &gt; 1)    {        int j = lower_bound(Sum, Sum + n + 1, k) - Sum -1;        k -= Sum[j];        mark[n - j - 1] = mark[n - j] = 1;    }    for (int i = 1; i &lt;= n; i++)        if (mark[i] &amp;&amp; mark[i + 1])            mark[i] = mark[i + 1] = 0, swap(a[i], a[i + 1]);    for (int i = 1; i &lt;= n; i++)        printf(&quot;%d &quot;, a[i]);    //while (1)    ;}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/09/81/#disqus_thread</comments>
    </item>
    
    <item>
      <title>beautiful</title>
      <link>https://blog.wildrage.xyz/2017/08/09/80/</link>
      <guid>https://blog.wildrage.xyz/2017/08/09/80/</guid>
      <pubDate>Wed, 09 Aug 2017 12:37:20 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;2-1-题目描述&quot;&gt;&lt;a href=&quot;#2-1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;2.1 题目描述&quot;&gt;&lt;/a&gt;2.1 题目描述&lt;/h3&gt;&lt;p&gt;Mavis 有一个序列（不必在乎这些细节），对于每个数都有一个在序列中的优美值，这个优&lt;br&gt;美值的定义是：找到序列中最长的一段，满足包含这个数并且这个数是这一段的中位数（以数&lt;br&gt;值为第一关键字，下标为第二关键字排序, 这样的话这一段的长度只有可能是奇数），那么这一&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h3><p>Mavis 有一个序列（不必在乎这些细节），对于每个数都有一个在序列中的优美值，这个优<br>美值的定义是：找到序列中最长的一段，满足包含这个数并且这个数是这一段的中位数（以数<br>值为第一关键字，下标为第二关键字排序, 这样的话这一段的长度只有可能是奇数），那么这一<br><a id="more"></a><br>段的长度就是它的优美值。Mavis 说：“对于我每次手贱点出的左右端点[l, r]，我都要找到[l,<br>r] 中的所有数中，最大的优美值”<br>但是Mavis 只会喊口号，不能解决问题，所以这个问题就交给你了</p><h3 id="2-2-输入格式"><a href="#2-2-输入格式" class="headerlink" title="2.2 输入格式"></a>2.2 输入格式</h3><p>第一行输入n 接下来n 个整数，代表ai 接下来Q，代表有Q 个区间接下来Q 行，每行<br>两个整数l, r(l &lt;= r)，表示区间的左右端点</p><h3 id="2-3-输出格式"><a href="#2-3-输出格式" class="headerlink" title="2.3 输出格式"></a>2.3 输出格式</h3><p>对于每个区间的询问，输出答案</p><h3 id="2-4-Sample-Input"><a href="#2-4-Sample-Input" class="headerlink" title="2.4 Sample Input"></a>2.4 Sample Input</h3><blockquote><p>8<br>16 19 7 8 9 11 20 16<br>8<br>3 8<br>1 4<br>2 3<br>1 1<br>5 5<br>1 2<br>2 8<br>7 8  </p></blockquote><h3 id="2-5-Sample-Output"><a href="#2-5-Sample-Output" class="headerlink" title="2.5 Sample Output"></a>2.5 Sample Output</h3><blockquote><p>7<br>3<br>1<br>3<br>5<br>3<br>7<br>3  </p></blockquote><h3 id="2-6-数据范围及约定"><a href="#2-6-数据范围及约定" class="headerlink" title="2.6 数据范围及约定"></a>2.6 数据范围及约定</h3><p>对于30% 的数据满足：1 &lt;= n;Q &lt;= 50<br>对于70% 的数据满足：1 &lt;= n;Q &lt; 2000<br>对于100% 的数据满足，1 &lt;= n &lt;= 2000, 1 &lt;= Q &lt;= 100000, 1 &lt;= ai &lt;= 200</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>可以先预处理出一个数的最大的优美值<br>然后就查询就可以了，，区间最大  </p><p>关键是预处理<br>可以用可持久化Trie N^2logN 求出每个区间的中位数<br>然后这个问题就解决了</p><p>先sort一遍在标号</p><pre><code class="c++">#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;struct data{    int a, pos;    bool operator&lt;(const data &amp;b) const    {        return a == b.a ? pos &lt; b.pos : a &lt; b.a;    }} a[2005];int comp(const data &amp;a, const data &amp;b){    return a.pos &lt; b.pos;}int full = 13;struct Trie{    struct Trie_Node    {        Trie_Node *ch[2];        int s;        Trie_Node()        {            ch[0] = ch[1] = NULL;            s = 0;        }    } * root[2005], *null;    Trie()    {        null = new Trie_Node();        null-&gt;ch[0] = null-&gt;ch[1] = null;        root[0] = new Trie_Node();        root[0]-&gt;ch[1] = root[0]-&gt;ch[0] = null;    }    Trie_Node *NewNode()    {        Trie_Node *rt = new Trie_Node();        rt-&gt;ch[0] = rt-&gt;ch[1] = null;        return rt;    }    void copy(Trie_Node *&amp;a, Trie_Node *b)    {        if (b == null)            a = null;        else            a = NewNode(), *a = *b;    }    void Insert(int x, int cnt)    {        copy(root[cnt], root[cnt - 1]);        Trie_Node *rt1 = root[cnt], *rt2 = root[cnt - 1];        for (int i = full; i &gt;= 0; i--)        {            int k = (x &gt;&gt; i) &amp; 1;            copy(rt1-&gt;ch[k], rt2-&gt;ch[k]);            if (rt1-&gt;ch[k] == null)                rt1-&gt;ch[k] = NewNode();            rt1 = rt1-&gt;ch[k], rt2 = rt2-&gt;ch[k];            rt1-&gt;s++;        }    }    int kth(int k, int l, int r)    {        int res = 0;        Trie_Node *rt1 = root[r], *rt2 = root[l - 1];        for (int i = full; i &gt;= 0; i--)        {            if (k &gt; rt1-&gt;ch[0]-&gt;s - rt2-&gt;ch[0]-&gt;s)            {                k -= (rt1-&gt;ch[0]-&gt;s - rt2-&gt;ch[0]-&gt;s);                res |= (1 &lt;&lt; i);                rt1 = rt1-&gt;ch[1], rt2 = rt2-&gt;ch[1];            }            else            {                rt1 = rt1-&gt;ch[0], rt2 = rt2-&gt;ch[0];            }        }        return res;    }} root;int pos[2005];int Maxn[2005 &lt;&lt; 2];int Max[2005 &lt;&lt; 2];#define lch l, m, rt &lt;&lt; 1#define rch m + 1, r, rt &lt;&lt; 1 | 1void Update(int rt){    Max[rt] = max(Max[rt &lt;&lt; 1], Max[rt &lt;&lt; 1 | 1]);}void buildtree(int l, int r, int rt){    if (l == r)    {        Max[rt] = Maxn[l];        return;    }    int m = l + r &gt;&gt; 1;    buildtree(lch);    buildtree(rch);    Update(rt);}int Query(int L, int R, int l, int r, int rt){    if (L &lt;= l &amp;&amp; R &gt;= r)        return Max[rt];    int m = l + r &gt;&gt; 1;    int MAX = 0;    if (L &lt;= m)        MAX = max(MAX, Query(L, R, lch));    if (R &gt; m)        MAX = max(MAX, Query(L, R, rch));    return MAX;}int main(){    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i++)    {        scanf(&quot;%d&quot;, &amp;a[i].a);        a[i].pos = i;    }    sort(a + 1, a + n + 1);    for (int i = 1; i &lt;= n; i++)    {        a[i].a = i;        pos[a[i].a] = a[i].pos;    }    sort(a + 1, a + n + 1, comp);    for (int i = 1; i &lt;= n; i++)        root.Insert(a[i].a, i);    for (int i = 1; i &lt;= n; i++)    {        for (int j = 1; j &lt;= i; j++)        {            if ((i - j + 1) &amp; 1)            {                int k = pos[root.kth((i - j + 1) / 2 + 1, j, i)];                Maxn[k] = max(Maxn[k], (i - j + 1));            }        }    }    buildtree(1, n, 1);    int Q, l, r;    scanf(&quot;%d&quot;, &amp;Q);    while (Q--)    {        scanf(&quot;%d%d&quot;, &amp;l, &amp;r);        printf(&quot;%d\n&quot;, Query(l, r, 1, n, 1));    }}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/09/80/#disqus_thread</comments>
    </item>
    
    <item>
      <title>calc</title>
      <link>https://blog.wildrage.xyz/2017/08/09/79/</link>
      <guid>https://blog.wildrage.xyz/2017/08/09/79/</guid>
      <pubDate>Wed, 09 Aug 2017 12:34:24 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;1-1-题目描述&quot;&gt;&lt;a href=&quot;#1-1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.1 题目描述&quot;&gt;&lt;/a&gt;1.1 题目描述&lt;/h3&gt;&lt;p&gt;给定一个序列a，a 中任意两个元素都不等。如果i&amp;lt;j, 且a[i]&amp;lt;a[j]，则我们称a[i],a[j] 为一&lt;br&gt;个顺序对，这个顺序对的值是指a[i+1],a[i+2]…….a[j-1] 中比a[i] 大，且比a[j] 小的数的个数。&lt;br&gt;求一个序列中所有顺序对的值的和。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><p>给定一个序列a，a 中任意两个元素都不等。如果i&lt;j, 且a[i]&lt;a[j]，则我们称a[i],a[j] 为一<br>个顺序对，这个顺序对的值是指a[i+1],a[i+2]…….a[j-1] 中比a[i] 大，且比a[j] 小的数的个数。<br>求一个序列中所有顺序对的值的和。</p><a id="more"></a><h3 id="1-2-输入格式"><a href="#1-2-输入格式" class="headerlink" title="1.2 输入格式"></a>1.2 输入格式</h3><p>第一行n 然后n 个整数表示ai</p><h3 id="1-3-输出格式"><a href="#1-3-输出格式" class="headerlink" title="1.3 输出格式"></a>1.3 输出格式</h3><p>一个整数，表示答案</p><h3 id="1-4-Sample-Input"><a href="#1-4-Sample-Input" class="headerlink" title="1.4 Sample Input"></a>1.4 Sample Input</h3><blockquote><p>5<br>1 5 3 4 2  </p></blockquote><h3 id="1-5-Sample-Output"><a href="#1-5-Sample-Output" class="headerlink" title="1.5 Sample Output"></a>1.5 Sample Output</h3><blockquote><p>1   </p></blockquote><h3 id="1-6-数据范围及约定"><a href="#1-6-数据范围及约定" class="headerlink" title="1.6 数据范围及约定"></a>1.6 数据范围及约定</h3><p>对于30% 的数据满足：1 &lt;= n &lt;= 300<br>对于另外30% 的数据满足：1 &lt;= n &lt;= 3000<br>对于100% 的数据满足，1 &lt;= n &lt;= 300000, 1 &lt;= ai &lt;= 10^9</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>反正挺伤心的没有想到正确的方向</p><p>对于每一个数他对后面的数所造成的贡献就是<br>他前面比他小的数的个数</p><p>然后树状数组维护一下就可以了</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;long long Sum[2][300005];#define lowbit(_) ((_) &amp; (-_))int n;void add(int p, int x, int w){    for (int i = x; i &lt;= n; i += lowbit(i))        Sum[p][i] += w;}long long Gsum(int p, int x){    long long ans = 0;    for (int i = x; i; i -= lowbit(i))        ans += Sum[p][i];    return ans;}int a[300005], Hash[300005];int main(){    scanf(&quot;%d&quot;, &amp;n);    long long ans = 0;    for (int i = 1; i &lt;= n; i++)    {        scanf(&quot;%d&quot;, &amp;a[i]);        Hash[i] = a[i];    }    sort(Hash + 1, Hash + n + 1);    int tot = unique(Hash + 1, Hash + n + 1) - Hash - 1;    for (int i = 1; i &lt;= n; i++)        a[i] = lower_bound(Hash + 1, Hash + tot + 1,a[i]) - Hash;    for (int i = 1; i &lt;= n; i++)    {        int x = Gsum(0, a[i] - 1);        add(0, a[i], 1);        ans += Gsum(1, a[i] - 1);        add(1, a[i], x);    }    printf(&quot;%lld\n&quot;, ans);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/09/79/#disqus_thread</comments>
    </item>
    
    <item>
      <title>与非</title>
      <link>https://blog.wildrage.xyz/2017/08/08/78/</link>
      <guid>https://blog.wildrage.xyz/2017/08/08/78/</guid>
      <pubDate>Tue, 08 Aug 2017 12:13:12 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;作为一名新世纪共产主义的接班人，你认识到了资本主义的软弱性与妥协性，决定全面根除资本主义，跑步迈入共产主义。但是当你即将跨入共产主义大门的时候，遇到了万恶的资本家留下的与非电路封印，经过千辛万苦的研究，你终于把复杂的破解转变成了以下问题：&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>作为一名新世纪共产主义的接班人，你认识到了资本主义的软弱性与妥协性，决定全面根除资本主义，跑步迈入共产主义。但是当你即将跨入共产主义大门的时候，遇到了万恶的资本家留下的与非电路封印，经过千辛万苦的研究，你终于把复杂的破解转变成了以下问题：<br><a id="more"></a><br>初始时你有一个空序列，之后有N个操作。</p><p>操作分为一下两种：</p><p>1 x：在序列末尾插入一个元素x(x=0或1)。</p><p>2 L R：定义nand[L,R]为序列第L个元素到第R个元素的与非和，询问nand[L,L]^nand[L,L+1]^nand[L,L+2]^……^nand[L,R]。</p><p>Nand就是先与，再取反</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>从文件nand.in中读入数据。</p><p>输入第一行一个正整数N，表示操作个数。</p><p>接下来N行表示N个操作。</p><p>为了体现程序的在线性，记lastans为上一次操作二的回答，初始lastans=0,。对于操作1，你需要对x异或lastans。对于操作二，设现在序列中的元素个数为M，如果lastans=1，那么你需要作如下操作：L=M-L+1,R=M-R+1,swap(L,R)</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出到nand.out中。</p><p>输出有多行。为对于每一个操作二的回答。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>6<br>1 1<br>1 1<br>1 0<br>2 1 2<br>2 1 3<br>2 2 3  </p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>1<br>0<br>0  </p></blockquote><h3 id="【数据规模和约定】"><a href="#【数据规模和约定】" class="headerlink" title="【数据规模和约定】"></a>【数据规模和约定】</h3><p>数据点    N的规模 操作一的个数M1 操作二的个数M2</p><p>1    N&lt;=1000    M1&lt;=500    M2&lt;=500<br>2    N&lt;=1000    M1&lt;=500    M2&lt;=500<br>3    N&lt;=200000    M1&lt;=100000    M2&lt;=100000<br>4    N&lt;=200000    M1&lt;=100000    M2&lt;=100000<br>5    N&lt;=1000000    M1&lt;=900000    M2&lt;=100000<br>N&lt;=4000000 M1&lt;=3900000    M2&lt;=100000</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>想了好久  也没想出来<br>最后放弃了</p><p>其实可以分类讨论</p><p>最后会发现一个结论</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;using namespace std;inline int read(){    int s = 0, k = 1;    char ch = getchar();    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;)        k = ch == &#39;-&#39; ? -1 : k, ch = getchar();    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)        s = s * 10 + (ch ^ 48), ch = getchar();    return s * k;}int n;bool Sum[4000005];bool f[4000005];bool a[4000005];int main(){    n = read();    int t = 0, op, l, r;    int lastans = 0;    while (n--)    {        op = read();        if (op == 1)        {            l = read() ^ lastans;            t++;            a[t] = l;            if (t == 1)                f[t] = a[t];            else                f[t] = !(f[t - 1] &amp; l);            Sum[t] = Sum[t - 1] ^ f[t];        }        else        {            l = read(), r = read();            if (lastans)            {                l = t - l + 1;                r = t - r + 1;                swap(l, r);            }            lastans = a[l];            int i = l, now = !(a[l] &amp; a[l + 1]);            while (now != f[i + 1] &amp;&amp; i &lt; r)            {                lastans ^= now;                i++;                now = !(now &amp; a[i + 1]);            }            if (i &lt; r)            {                lastans ^= Sum[r] ^ Sum[i];            }            printf(&quot;%d\n&quot;, lastans);        }    }    //while (1);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/08/78/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Number</title>
      <link>https://blog.wildrage.xyz/2017/08/08/77/</link>
      <guid>https://blog.wildrage.xyz/2017/08/08/77/</guid>
      <pubDate>Tue, 08 Aug 2017 12:07:55 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;一个排列，求出了 a 数组，其中 ai 表示第 i 个数左边有多少个数比它小&lt;/p&gt;
&lt;p&gt;计算出原来的排列&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个排列，求出了 a 数组，其中 ai 表示第 i 个数左边有多少个数比它小</p><p>计算出原来的排列<br><a id="more"></a></p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第一行输入 n 接下来 n - 1 个整数 ai，下标从 2 开始</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出 n 个整数表示原排列</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>5<br>1<br>2<br>1<br>0  </p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>2<br>4<br>5<br>3<br>1  </p></blockquote><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>对于 20% 的数据满足：1 ≤ n ≤ 10<br>对于 50% 的数据满足：1 ≤ n ≤ 1000<br>对于 100% 的数据满足，1 ≤ n ≤ 100000<br>保证解存在</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>输入的树就是按顺序插入时比他小的数的数量<br>用一颗平衡树维护就可以了</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;using namespace std;struct Node{    Node *ch[2];    int s, id, key;    Node(int x)    {        key = rand();        id = x;        s = 1;        ch[0] = ch[1] = NULL;    }#define size(_) ((_) ? (_)-&gt;s : 0)    void Update()    {        s = size(ch[1]) + size(ch[0]) + 1;    }} * root;Node *Merge(Node *A, Node *B){    if (!A)        return B;    if (!B)        return A;    if (A-&gt;key &lt; B-&gt;key)    {        A-&gt;ch[1] = Merge(A-&gt;ch[1], B);        A-&gt;Update();        return A;    }    else    {        B-&gt;ch[0] = Merge(A, B-&gt;ch[0]);        B-&gt;Update();        return B;    }}typedef pair&lt;Node *, Node *&gt; DNode;DNode Split(Node *rt, int k){    if (!rt)        return DNode(NULL, NULL);    DNode o;    if (size(rt-&gt;ch[0]) &gt;= k)    {        o = Split(rt-&gt;ch[0], k);        rt-&gt;ch[0] = o.second;        rt-&gt;Update();        o.second = rt;    }    else    {        o = Split(rt-&gt;ch[1], k - size(rt-&gt;ch[0]) - 1);        rt-&gt;ch[1] = o.first;        rt-&gt;Update();        o.first = rt;    }    return o;}void Insert(int x, int k){    DNode y = Split(root, k);    Node *n = new Node(x);    root = Merge(y.first, Merge(n, y.second));}int Ind = 0;int a[100005];void DFS(Node *rt){    if (rt)    {        DFS(rt-&gt;ch[0]);        a[rt-&gt;id] = ++Ind;        DFS(rt-&gt;ch[1]);    }}int main(){    int n;    scanf(&quot;%d&quot;, &amp;n);    int c;    Insert(1, 0);    for (int i = 2; i &lt;= n; i++)    {        scanf(&quot;%d&quot;, &amp;c);        Insert(i, c);    }    DFS(root);    for (int i = 1; i &lt;= n; i++)    {        printf(&quot;%d\n&quot;, a[i]);    }    //while(1);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/08/77/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Evensgn 的债务</title>
      <link>https://blog.wildrage.xyz/2017/08/08/76/</link>
      <guid>https://blog.wildrage.xyz/2017/08/08/76/</guid>
      <pubDate>Tue, 08 Aug 2017 11:58:44 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Evensgn 有一群好朋友，他们经常互相借钱。假如说有三个好朋友 A，B，C。&lt;/p&gt;
&lt;p&gt;A 欠 B 20 元，B 欠 C 20 元，总债务规模为 20+20=40 元。Evensgn 是个追求简约&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Evensgn 有一群好朋友，他们经常互相借钱。假如说有三个好朋友 A，B，C。</p><p>A 欠 B 20 元，B 欠 C 20 元，总债务规模为 20+20=40 元。Evensgn 是个追求简约<br><a id="more"></a><br>的人，他觉得这样的债务太繁杂了。他认为，上面的债务可以完全等价为 A 欠 C</p><p>20 元，B 既不欠别人，别人也不欠他。这样总债务规模就压缩到了 20 元。</p><p>现在给定 n 个人和 m 条债务关系。Evensgn 想找到一种新的债务方案，使得</p><p>每个人欠钱的总数不变，或被欠钱的总数不变（但是对象可以发生变化），并且使</p><p>得总债务规模最小。</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>输入文件第一行两个数字 n; m，含义如题目所述。</p><p>接下来 m 行，每行三个数字 ai; bi; ci，表示 ai 欠 bi 的钱数为 ci。</p><p>注意，数据中关于某两个人 A 和 B 的债务信息可能出现多次，将其累加即可。</p><p>如”A 欠 B 20 元”、”A 欠 B 30 元”、”B 欠 A 10 元”，其等价为”A 欠 B 40 元”。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出文件共一行，输出最小的总债务规模。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>样例输入 1<br>5 3<br>1 2 10<br>2 3 1<br>2 4 1<br>样例输入 2<br>4 3<br>1 2 1<br>2 3 1<br>3 1 1  </p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>样例输出 1<br>10<br>样例输出 2<br>0  </p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考试的时候想了想<br>发现可以理解为<br>每一个人将他的真正的需要交出的钱一起交出<br>然后就需要拿钱的人去拿<br>统计一下就可以了</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int in[1000005], out[1000005];long long Sum = 0;int main(){    int n, m, a, b, c;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= m; i++)    {        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);        out[a] += c;        in[b] += c;        Sum += c;    }    for (int i = 1; i &lt;= n; i++)    {        Sum -= min(out[i], in[i]);    }    printf(&quot;%lld\n&quot;, Sum);    //while (1)}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/08/76/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HDU1693 Eat the Trees &amp;&amp; BZOJ 1210 [HNOI2004] 邮递员</title>
      <link>https://blog.wildrage.xyz/2017/08/08/75/</link>
      <guid>https://blog.wildrage.xyz/2017/08/08/75/</guid>
      <pubDate>Tue, 08 Aug 2017 11:23:32 GMT</pubDate>
      <description>
      
        &lt;p&gt;先来一个最入门的&lt;br&gt;HDU 1693 &lt;/p&gt;
&lt;p&gt;哈密顿回路 多回路&lt;/p&gt;
&lt;h3 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description&quot;&gt;&lt;/a&gt;Problem Description&lt;/h3&gt;&lt;p&gt;Most of us know that in the game called DotA(Defense of the Ancient), Pudge is a strong hero in the first period of the game. When the game goes to end however, Pudge is not a strong hero any more.&lt;br&gt;So Pudge’s teammates give him a new assignment—Eat the Trees!&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>先来一个最入门的<br>HDU 1693 </p><p>哈密顿回路 多回路</p><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Most of us know that in the game called DotA(Defense of the Ancient), Pudge is a strong hero in the first period of the game. When the game goes to end however, Pudge is not a strong hero any more.<br>So Pudge’s teammates give him a new assignment—Eat the Trees!<br><a id="more"></a><br>The trees are in a rectangle N * M cells in size and each of the cells either has exactly one tree or has nothing at all. And what Pudge needs to do is to eat all trees that are in the cells.<br>There are several rules Pudge must follow:<br>I. Pudge must eat the trees by choosing a circuit and he then will eat all trees that are in the chosen circuit.<br>II. The cell that does not contain a tree is unreachable, e.g. each of the cells that is through the circuit which Pudge chooses must contain a tree and when the circuit is chosen, the trees which are in the cells on the circuit will disappear.<br>III. Pudge may choose one or more circuits to eat the trees.</p><p>Now Pudge has a question, how many ways are there to eat the trees?<br>At the picture below three samples are given for N = 6 and M = 3(gray square means no trees in the cell, and the bold black line means the chosen circuit(s))<br><img src="https://i.loli.net/2017/08/08/5989a4fbd2f53.jpg" alt="HDU1693"></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input consists of several test cases. The first line of the input is the number of the cases. There are no more than 10 cases.<br>For each case, the first line contains the integer numbers N and M, 1&lt;=N, M&lt;=11. Each of the next N lines contains M numbers (either 0 or 1) separated by a space. Number 0 means a cell which has no trees and number 1 means a cell that has exactly one tree.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each case, you should print the desired number of ways in one line. It is guaranteed, that it does not exceed 263 – 1. Use the format in the sample.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>2<br>6 3<br>1 1 1<br>1 0 1<br>1 1 1<br>1 1 1<br>1 0 1<br>1 1 1<br>2 4<br>1 1 1 1<br>1 1 1 1  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>Case 1: There are 3 ways to eat the trees.<br>Case 2: There are 2 ways to eat the trees.  </p></blockquote><p>本题就是一道最基础的求回路的题目<br>因为我们不需要 要求一条回路，所以只需记录是否有插头就可以了</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int Max = (1 &lt;&lt; 12) + 10;int n, m;int mp[12][12];long long DP[12][12][Max];void dp(){    memset(DP, 0, sizeof(DP));    DP[0][m][0] = 1;    int bit = 1 &lt;&lt; (m + 1);    for (int i = 1; i &lt;= n; i++)    {        for (int j = 0; j &lt; (bit &gt;&gt; 1); j++)        {            DP[i][0][j &lt;&lt; 1] = DP[i - 1][m][j];        }        for (int j = 1; j &lt;= m; j++)        {            for (int k = 0; k &lt; bit; k++)            {                int x = 1 &lt;&lt; (j - 1);                int y = 1 &lt;&lt; j;                if (mp[i][j])                {                    DP[i][j][k] += DP[i][j - 1][k ^ x ^ y];                    if ((k &amp; x) &amp;&amp; (k &amp; y))                        continue;                    if (!(k &amp; x) &amp;&amp; !(k &amp; y))                        continue;                    DP[i][j][k] += DP[i][j - 1][k];                }                else                {                    if (!(k &amp; x) &amp;&amp; !(k &amp; y))                        DP[i][j][k] = DP[i][j - 1][k];                    else                        DP[i][j][k] = 0;                }            }        }    }}int main(){    int t, num = 0;    scanf(&quot;%d&quot;, &amp;t);    while (t--)    {        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        for (int i = 1; i &lt;= n; i++)        {            for (int j = 1; j &lt;= m; j++)            {                scanf(&quot;%d&quot;, &amp;mp[i][j]);            }        }        dp();        printf(&quot;Case %d: There are %lld ways to eat the trees.\n&quot;, ++num, DP[n][m][0]);    }    //while(1);}</code></pre><p>然后是稍微复杂点的</p><p>单回路</p><p>【题目描述】</p><p>Smith在P市的邮政局工作，他每天的工作是从邮局出发，到自己所管辖的所有邮筒取信件，然后带回邮局。<br>他所管辖的邮筒非常巧地排成了一个m*n的点阵（点阵中的间距都是相等的）。左上角的邮筒恰好在邮局的门口。<br>Smith是一个非常标新立异的人，他希望每天都能走不同的路线，但是同时，他又不希望路线的长度增加，他想知道他有多少条不同的路线可走。</p><p>你的程序需要根据给定的输入，给出符合题意的输出：<br>l 输入包括点阵的m和n的值；<br>l 你需要根据给出的输入，计算出Smith可选的不同路线的总条数；</p><p>【输入格式】</p><p>输入文件postman.in只有一行。包括两个整数m, n(1 &lt;= m &lt;= 10, 1 &lt;= n &lt;= 20)，表示了Smith管辖内的邮筒排成的点阵。</p><p>【输出格式】</p><p>输出文件只有一行，只有一个整数，表示Smith可选的不同路线的条数。<br>【样例输入】</p><p>2 2 说明：该输入表示，Smith管辖了2*2的一个邮筒点阵。<br>【样例输出】</p><p>2<br>【提示】<br><img src="https://i.loli.net/2017/08/08/5989a54398a57.png" alt="COGS邮递员"></p><p>详情请看代码</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;using namespace std;#define LL long longconst int BA = 100000, SIZEN = 10, SIZEM = 20, BASE = 200000;int N, M;int H[BASE];class BigNum /**高精度 */{  public:    int n;    int s[50];    void operator=(int a)    {        n = 1;        memset(s, 0, sizeof(s));        s[0] = a;    }    void operator+=(BigNum a)    {        n = max(n, a.n) + 1;        for (int i = 0; i &lt;= n; i++)        {            s[i] += a.s[i];            s[i + 1] += s[i] / BA;            s[i] %= BA;        }        while (n &gt; 0 &amp;&amp; s[n - 1] == 0)        {            n--;        }    }    void operator*=(int a)    {        n++;        for (int i = 0; i &lt;= n; i++)            s[i] *= a;        for (int i = 0; i &lt;= n; i++)        {            s[i + 1] += s[i] / BA;            s[i] %= BA;        }        while (n &gt; 0 &amp;&amp; s[n - 1] == 0)        {            n--;        }    }    void print()    {        printf(&quot;%d&quot;, s[n - 1]);        for (int i = n - 2; i &gt;= 0; i--)            printf(&quot;%05d&quot;, s[i]);    }} ans;class Pair /**映射表 */{  public:    BigNum Sum;    LL Id;    Pair() {}    Pair(LL a, BigNum b)    {        Id = a;        Sum = b;    }};deque&lt;Pair&gt; f[2]; /**循环数组 */void read()       /**read */{    scanf(&quot;%d%d&quot;, &amp;N, &amp;M);    if (N &lt; M)        swap(N, M);}int Get(int x, int j) /**取4进制的操作 */{    x &gt;&gt;= 2 * (j - 1);    x &amp;= 3;    return x;}int Change(int x, int j, int t) /**把x的第j位改成t */{    int tmp = x &gt;&gt; (2 * (j - 1));    x -= tmp &lt;&lt; (j - 1) * 2;    tmp &gt;&gt;= 2;    x += tmp &lt;&lt; 2 * j;    x += t &lt;&lt; ((j - 1) * 2);    return x;}int Find(int x, int j, int dat) /**找与他相连的括号 */{    int now = dat, k = j;    while (k &gt;= 1 &amp;&amp; k &lt;= M + 1)    {        k += now;        int tmp = Get(x, k);        if (tmp == 1)            dat++;        if (tmp == 2)            dat--;        if (dat == 0)            return k;    }}void Push(int k, int Id, BigNum Sum) /**插入hash表 */{    int now = Id % BASE;    while (H[now]) /**如果有 */    {        if (f[k][H[now]].Id == Id) /**且就是这个状态 */        {            f[k][H[now]].Sum += Sum; /**加值，和并答案 */            return;        }        now++; /**找自己的状态 */        if (now == BASE)            now = 0;    }    H[now] = f[k].size(); /**如果第一次出现 */    f[k].push_back(Pair(Id, Sum));}/** * 1为左括号 * 2为右括号 * 0为无括号 */void DP(){    int k = 0;    BigNum p;    p = 1; /**初始化状态 */    f[k].push_back(Pair(0, p));    for (int i = 1; i &lt;= N; i++)    {        for (int j = 1; j &lt;= M; j++)        {            k ^= 1;                  /**滚动数组 */            f[k].clear();            /**清空本维 */            memset(H, 0, sizeof(H)); /**hash 数组 */            for (int m = 0; m &lt; f[k ^ 1].size(); m++)            {                int Id = f[k ^ 1][m].Id;       /**取状态 */                BigNum date = f[k ^ 1][m].Sum; /**取值 */                int L = Get(Id, j), U = Get(Id, j + 1);                /**                 * L:左面的 ，U: 右面的                 */                int tmp;      /**分类讨论开始 */                if (!L &amp;&amp; !U) /**两个插头都是无插头状态 */                {                    if (i != N &amp;&amp; j != M) /**如果不是最后一个 */                    {                        tmp = Change(Id, j, 1); /**构造一组新的括号 */                        tmp = Change(tmp, j + 1, 2);                        Push(k, tmp, date); /**插入Hash */                    }                }                else if (!L &amp;&amp; U) /**左面的没有 */                {                    if (j != M)            /**向右转移 */                        Push(k, Id, date); /**延续状态 当j==M事不能向右动*/                    if (i != N)            /**向下转移 */                    {                        /**将L,U位置的 状态互换 转移*/                        tmp = Change(Id, j, U);                        tmp = Change(tmp, j + 1, 0);                        Push(k, tmp, date);                    }                }                else if (L &amp;&amp; !U) /**上面的没有 */                {                    if (i != N) /**向下 */                        Push(k, Id, date);                    if (j != M) /**向右 */                    {                        /**于上同理 */                        tmp = Change(Id, j, 0);                        tmp = Change(tmp, j + 1, L);                        Push(k, tmp, date);                    }                }                else if (L == 1 &amp;&amp; U == 1) /**两个都是左括号 */                {                    tmp = Change(Id, Find(Id, j + 1, 1), 1); /**将与上面相连的右括号转为左括号 */                    tmp = Change(tmp, j, 0);                 /**这两位都制为无括号 */                    tmp = Change(tmp, j + 1, 0);                    Push(k, tmp, date);                }                else if (L == 2 &amp;&amp; U == 2)                /**两个都是右括号 */                {                                         /**与上面对称 */                    tmp = Change(Id, Find(Id, j, -1), 2); /**将与左面相连的左括号制为右括号 */                    tmp = Change(tmp, j, 0);               /**这两位都为无括号 */                    tmp = Change(tmp, j + 1, 0);                    Push(k, tmp, date);                }                else if (L == 2 &amp;&amp; U == 1) /**左插头为右括号 上插头为左括号 */                {                          /**都制为无 */                    tmp = Change(Id, j, 0);                    tmp = Change(tmp, j + 1, 0);                    Push(k, tmp, date);                }                else if (L == 1 &amp;&amp; U == 2)                {                    if (i == N &amp;&amp; j == M)                        ans += date;                }            }        }        for (int km = 0; km &lt; f[k].size(); km++) /**提前换行准备为下一行使用 */            f[k][km].Id &lt;&lt;= 2;    }    ans *= 2;    ans.print();}int main(){    //freopen(&quot;postman.in&quot;, &quot;r&quot;, stdin);    //freopen(&quot;postman.out&quot;, &quot;w&quot;, stdout);    read();    if (M == 1)    {        printf(&quot;1&quot;);        return 0;    }    DP();    return 0;}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/08/75/#disqus_thread</comments>
    </item>
    
    <item>
      <title>书</title>
      <link>https://blog.wildrage.xyz/2017/08/08/74/</link>
      <guid>https://blog.wildrage.xyz/2017/08/08/74/</guid>
      <pubDate>Tue, 08 Aug 2017 05:10:59 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Hazel有n本书，编号1为n到 ，叠成一堆。当她每次抽出一本书的时候，上方的书会因重力而下落，这本被取出的书则会被放置在书堆顶。&lt;br&gt;每次有pi的概率抽取编号为i的书。她每次抽书所消耗的体力与这本书在这堆中是第几本成正比。具体地，抽取堆顶的书所耗费体力值为1 ，抽取第二本耗费体力值为2 ，以此类推。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Hazel有n本书，编号1为n到 ，叠成一堆。当她每次抽出一本书的时候，上方的书会因重力而下落，这本被取出的书则会被放置在书堆顶。<br>每次有pi的概率抽取编号为i的书。她每次抽书所消耗的体力与这本书在这堆中是第几本成正比。具体地，抽取堆顶的书所耗费体力值为1 ，抽取第二本耗费体力值为2 ，以此类推。<br><a id="more"></a><br>现在 想知道，在很久很久以后（可以认为几乎是无穷的），她每次抽书所耗费的体力的期望值是多少。<br>最终的答案显然可以表示成a/b的形式，请输出a*(b^-1)模1e9+7的值。</p><h3 id="【输入格式】"><a href="#【输入格式】" class="headerlink" title="【输入格式】"></a>【输入格式】</h3><p>第一行一个整数n<br>接下来n行，每行两个整数ai，bi，代表抽取第i本书的概率是ai/bi<br>保证所有书的概率和等于1</p><h3 id="【输出格式】"><a href="#【输出格式】" class="headerlink" title="【输出格式】"></a>【输出格式】</h3><p>输出一行一个整数，代表期望值</p><h3 id="【输入样例1】"><a href="#【输入样例1】" class="headerlink" title="【输入样例1】"></a>【输入样例1】</h3><blockquote><p>2<br>227494 333333<br>105839 333333  </p></blockquote><h3 id="【输出样例1】"><a href="#【输出样例1】" class="headerlink" title="【输出样例1】"></a>【输出样例1】</h3><blockquote><p>432679642</p></blockquote><p>【输入样例2】</p><blockquote><p>10<br>159073 999999<br>1493 142857<br>3422 333333<br>4945 37037<br>2227 111111<br>196276 999999<br>190882 999999<br>142721 999999<br>34858 999999<br>101914 999999  </p></blockquote><h3 id="【输出样例2】"><a href="#【输出样例2】" class="headerlink" title="【输出样例2】"></a>【输出样例2】</h3><blockquote><p>871435606</p></blockquote><h3 id="【数据规模与约定】"><a href="#【数据规模与约定】" class="headerlink" title="【数据规模与约定】"></a>【数据规模与约定】</h3><p>对于30%的数据，1&lt;=n&lt;=10。<br>对于100%的数据，1&lt;=n&lt;=1000,0&lt;=ai&lt;=bi,bi!=0。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>期望DP</p><p>P表示概率<br>E表示期望体力</p><p>$$ Ans = \sum_{i=1}^{n}{P_i<em>E_i} $$<br>$$ = \sum_{i=1}^{n}{P_i</em>(1+\sum_{j=1且就i!=j}^{n}{P_{抽到j比i晚}})}$$<br>$$ = \sum_{i=1}^{n}{P_i*(1+\sum_{j=1且j!=i}^{n}{\frac{P_j}{P_i+P_j}})}$$</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define LL long longconst LL P = 1e9 + 7;LL pow_mod(LL a, int b){    LL ans = 1;    while (b)    {        if (b &amp; 1)            ans = ans * a % P;        b &gt;&gt;= 1;        a = a * a % P;    }    return ans;}LL q[1005];int main(){    int n;    scanf(&quot;%d&quot;, &amp;n);    LL a, b;    for (int i = 1; i &lt;= n; i++)    {        scanf(&quot;%lld%lld&quot;, &amp;a, &amp;b);        q[i] = a * pow_mod(b, P - 2) % P;    }    LL ans = 0;    for (int i = 1; i &lt;= n; i++)    {        LL sum = 0;        for (int j = 1; j &lt;= n; j++)        {            if (j == i)                continue;            sum = (sum + q[j] * pow_mod(q[i] + q[j], P - 2) % P) % P;        }        ans = (ans + (1 + sum) * q[i]) % P;    }    printf(&quot;%lld&quot;, ans);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/08/74/#disqus_thread</comments>
    </item>
    
    <item>
      <title>就</title>
      <link>https://blog.wildrage.xyz/2017/08/08/73/</link>
      <guid>https://blog.wildrage.xyz/2017/08/08/73/</guid>
      <pubDate>Tue, 08 Aug 2017 04:53:42 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;【背景描述】&quot;&gt;&lt;a href=&quot;#【背景描述】&quot; class=&quot;headerlink&quot; title=&quot;【背景描述】&quot;&gt;&lt;/a&gt;【背景描述】&lt;/h3&gt;&lt;p&gt;一排 N 个数， 第 i 个数是 Ai ， 你要找出 K 个不相邻的数， 使得他们的和最大。&lt;br&gt;请求出这个最大和。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="【背景描述】"><a href="#【背景描述】" class="headerlink" title="【背景描述】"></a>【背景描述】</h3><p>一排 N 个数， 第 i 个数是 Ai ， 你要找出 K 个不相邻的数， 使得他们的和最大。<br>请求出这个最大和。<br><a id="more"></a></p><h3 id="【输入格式】"><a href="#【输入格式】" class="headerlink" title="【输入格式】"></a>【输入格式】</h3><p>第一行两个整数 N 和 K。<br>接下来一行 N 个整数， 第 i 个整数表示 Ai 。</p><h3 id="【输出格式】"><a href="#【输出格式】" class="headerlink" title="【输出格式】"></a>【输出格式】</h3><p>一行一个整数表示最大和， 请注意答案可能会超过 int 范围</p><h3 id="【样例输入】"><a href="#【样例输入】" class="headerlink" title="【样例输入】"></a>【样例输入】</h3><blockquote><p>3 2<br>4 5 3  </p></blockquote><h3 id="【样例输出】"><a href="#【样例输出】" class="headerlink" title="【样例输出】"></a>【样例输出】</h3><blockquote><p>7  </p></blockquote><h3 id="【数据范围】"><a href="#【数据范围】" class="headerlink" title="【数据范围】"></a>【数据范围】</h3><p>对于 20% 的数据， N, K ≤ 20 。<br>对于 40% 的数据， N, K ≤ 1000 。<br>对于 60% 的数据， N, K ≤ 10000 。<br>对于 100% 的数据， N, K ≤ 100000 ， 1 ≤ Ai ≤ 1000000000。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>贪心，每次用一个堆维护最大值<br>每次都找最大的和他两边的合并，其实是一个可反悔的贪心</p><p>主要边界处理</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;list&gt;using namespace std;#define LL long longstruct data{    LL Num;    int pos;    bool operator&lt;(const data &amp;a) const    {        return Num == a.Num ? pos &lt; a.pos : Num &gt; a.Num;    }};set&lt;data&gt; st;LL a[100005];int nex[100005], fre[100005];LL Merge(){    int A = st.begin()-&gt;pos;    LL ans = a[A];    a[A] = -a[A];    a[A] += a[fre[A]], a[A] += a[nex[A]];    st.erase(st.begin());    st.erase((data){a[fre[A]], fre[A]});    st.erase((data){a[nex[A]], nex[A]});    st.insert((data){a[A], A});    if (fre[fre[A]])        nex[fre[fre[A]]] = A;    if (nex[nex[A]])        fre[nex[nex[A]]] = A;    fre[A] = fre[fre[A]];    nex[A] = nex[nex[A]];    return ans;}int main(){    int n, k;    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);    for (int i = 1; i &lt;= n; i++)    {        scanf(&quot;%lld&quot;, &amp;a[i]);        fre[i] = i - 1;        nex[i] = i + 1;        st.insert((data){a[i], i});    }    nex[n] = 0;    a[0] = 0x8080808080808080ll;    LL ans = 0;    while (k--)    {        ans += Merge();    }    printf(&quot;%lld&quot;, ans);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/08/73/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Passward</title>
      <link>https://blog.wildrage.xyz/2017/08/08/72/</link>
      <guid>https://blog.wildrage.xyz/2017/08/08/72/</guid>
      <pubDate>Tue, 08 Aug 2017 04:52:32 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;你来到了一个庙前，庙牌上有一个仅包含小写字母的字符串 s。&lt;br&gt;传说打开庙门的密码是这个字符串的一个子串 t，并且 t 既是 s 的前缀又是 s 的后缀并且还在 s 的中间位置出现过一次。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>你来到了一个庙前，庙牌上有一个仅包含小写字母的字符串 s。<br>传说打开庙门的密码是这个字符串的一个子串 t，并且 t 既是 s 的前缀又是 s 的后缀并且还在 s 的中间位置出现过一次。<br><a id="more"></a><br>如果存在这样的串，请你输出这个串，如有多个满足条件的串，输出最长的那一个。<br>如果不存在这样的串，输出”Just a legend”(去掉引号)。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>仅一行，字符串 s。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>如题所述</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>fixprefixsuffix  </p></blockquote><h3 id="样例输出："><a href="#样例输出：" class="headerlink" title="样例输出："></a>样例输出：</h3><blockquote><p>fix</p></blockquote><h3 id="数据范围："><a href="#数据范围：" class="headerlink" title="数据范围："></a>数据范围：</h3><p>对于 60%的数据， s 的长度&lt;=100<br>对于 100%的数据， s 的长度&lt;=100000</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>hash 淼之</p><pre><code class="c++">#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;char s[2000005];unsigned long long base = 31;unsigned long long has[2000005];unsigned long long Pow(unsigned long long b,int i){    unsigned long long ans = 1;    while(i)    {        if(i &amp; 1)            ans = ans * b;        i &gt;&gt;= 1;        b = b * b;    }    return ans;}int main(){    freopen(&quot;fool.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;fool.out&quot;,&quot;w&quot;,stdout);    int q;    scanf(&quot;%d&quot;,&amp;q);    while(q--){        scanf(&quot;%s&quot;, s + 1);        int len = strlen(s + 1);        for (int i = 1; i &lt;= len; i++)        {            has[i] = has[i - 1] * base + s[i];        }        int ans = 0;        for (int i = 1; i &lt;= len; i++)        {            unsigned long long T = Pow(base, i);             if( has[i] == has[len] - has[len - i] * T)            {                for(int j = 2; j &lt; len - i; j++)                {                    if(has[j + i] - has[j] * T == has[i])                    {                        ans = i;                        break;                    }                }                if(ans != i)                    break;            }        }        if(ans)        {            for(int i = 1; i &lt;= ans; i++)            {                printf(&quot;%c&quot;, s[i]);            }            printf(&quot;\n&quot;);        }        else             puts(&quot;---\n&quot;);    }}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/08/72/#disqus_thread</comments>
    </item>
    
    <item>
      <title>K-D 树</title>
      <link>https://blog.wildrage.xyz/2017/08/07/71/</link>
      <guid>https://blog.wildrage.xyz/2017/08/07/71/</guid>
      <pubDate>Mon, 07 Aug 2017 07:04:53 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;维护K维的点&quot;&gt;&lt;a href=&quot;#维护K维的点&quot; class=&quot;headerlink&quot; title=&quot;维护K维的点&quot;&gt;&lt;/a&gt;维护K维的点&lt;/h2&gt;&lt;p&gt;线段树相当于一颗1-D树&lt;/p&gt;
&lt;h2 id=&quot;建树&quot;&gt;&lt;a href=&quot;#建树&quot; class=&quot;head
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="维护K维的点"><a href="#维护K维的点" class="headerlink" title="维护K维的点"></a>维护K维的点</h2><p>线段树相当于一颗1-D树</p><h2 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h2><ol><li>循环建树</li><li>最大方差建树</li></ol><h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/07/71/#disqus_thread</comments>
    </item>
    
    <item>
      <title>计算几何初步</title>
      <link>https://blog.wildrage.xyz/2017/08/06/70/</link>
      <guid>https://blog.wildrage.xyz/2017/08/06/70/</guid>
      <pubDate>Sun, 06 Aug 2017 12:53:59 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;1-什么是计算几何&quot;&gt;&lt;a href=&quot;#1-什么是计算几何&quot; class=&quot;headerlink&quot; title=&quot;1.什么是计算几何&quot;&gt;&lt;/a&gt;1.什么是计算几何&lt;/h2&gt;&lt;p&gt;维基百科&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;计算几何&lt;/a&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;计算几何是一门兴起于二十世纪七十年代末的计算机科学的一个分支，主要研究解决几何问题的算法。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="1-什么是计算几何"><a href="#1-什么是计算几何" class="headerlink" title="1.什么是计算几何"></a>1.什么是计算几何</h2><p>维基百科<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95" target="_blank" rel="noopener">计算几何</a>  </p><blockquote><p>计算几何是一门兴起于二十世纪七十年代末的计算机科学的一个分支，主要研究解决几何问题的算法。<br><a id="more"></a><br>简单来说就是用计算机算解析几何</p></blockquote><h2 id="2-计算几何的恶心之处"><a href="#2-计算几何的恶心之处" class="headerlink" title="2.计算几何的恶心之处"></a>2.计算几何的恶心之处</h2><ul><li>有精度误差<a href="在计算几何问题时很多时候用到复杂的浮点运算和三角函数运算，这样就会产生精度问题">^1</a></li><li>需要讨论各种边界情况</li><li><p>代码长（看一看NOI2017D2T3的标称就知道了）</p><p>  解决精度问题<br>  设$\epsilon$为非常小的量</p><ul><li>$a=b \Leftrightarrow |a-b|&lt; \epsilon$</li><li>$a&lt; b \Leftrightarrow a-b &lt; -\epsilon$</li><li>$a\leq b \Leftrightarrow a - b &lt; \epsilon$</li></ul></li></ul><h2 id="3-二维矢量"><a href="#3-二维矢量" class="headerlink" title="3.二维矢量"></a>3.二维矢量</h2><h4 id="矢量"><a href="#矢量" class="headerlink" title="矢量"></a>矢量</h4><ul><li>既有大小又有方向的量</li><li>又称为向量</li></ul><h4 id="矢量的表示"><a href="#矢量的表示" class="headerlink" title="矢量的表示"></a>矢量的表示</h4><ul><li>在n维空间下，矢量经常被表示为 $\vec{a}=(a_1,a_2,\ldots,a_n)$</li><li>在二维空间中则以$(x,y)$来表述</li></ul><h4 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h4><p>$(a_1,a_2,\ldots,a_n)\cdot(b_1,b_2,\ldots,b_n) = a_1 b_1 + a_2 b_2+\cdots+ a_n b_n$</p><h4 id="矢量的模"><a href="#矢量的模" class="headerlink" title="矢量的模"></a>矢量的模</h4><p>矢量的长度</p><h3 id="二维叉积"><a href="#二维叉积" class="headerlink" title="! 二维叉积"></a>! 二维叉积</h3><p>$(x_1,y_1)\times(x_2,y_2) = x_1 y_2 - x_2 y_1$</p><p>二维叉积满足<a href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E4%BA%A4%E6%8F%9B%E5%BE%8B" target="_blank" rel="noopener">逆交换律</a>: $\vec{a}\times\vec{b} = - \vec{b}\times\vec{a}$</p><h4 id="有向面积"><a href="#有向面积" class="headerlink" title="有向面积"></a>有向面积</h4><ul><li>由$\vec{a}$和$\vec{b}$所成的平行四边形的面积为$|\vec{a}\times\vec{b}|$ 的值</li><li>去掉绝对值二维叉积定义为有向面积</li></ul><h4 id="有向面积的符号"><a href="#有向面积的符号" class="headerlink" title="有向面积的符号"></a>有向面积的符号</h4><p>伸出右手将四指由$\vec{a}$沿小于平角转到$\vec{b}$ 若拇指指向纸面上方则$\vec{a}\times\vec{b}$ 为正否则为负</p><h4 id="二维矢量的旋转"><a href="#二维矢量的旋转" class="headerlink" title="二维矢量的旋转"></a>二维矢量的旋转</h4><p>将矢量$\vec{a}$逆时针旋转$\theta$后为$ \begin{pmatrix} \cos\theta &amp; -\sin\theta \\ \sin\theta &amp; \cos\theta \\ \end{pmatrix} \vec{a} $</p><h4 id="二维矢量的极角"><a href="#二维矢量的极角" class="headerlink" title="二维矢量的极角"></a>二维矢量的极角</h4><p>极角指示矢量的方向，以x轴正半轴逆时针转过的角度来指示<br>矢量$(x,y)$的极角为$atan2(y,x)$</p><h4 id="直线"><a href="#直线" class="headerlink" title="直线"></a>直线</h4><p>用两个相异点来表示<br>$\forall\lambda \in R,\lambda A +(1-\lambda)B$<br>表示直线上任意一点</p><h4 id="点到直线的距离"><a href="#点到直线的距离" class="headerlink" title="点到直线的距离"></a>点到直线的距离</h4><p>点$P$到直线$AB$的距离<br>即$|\vec{AP}-\vec{AB}\frac{\vec{AB}\cdot\vec{AP}}{\vec{AB}^2}|$</p><h4 id="分点"><a href="#分点" class="headerlink" title="分点"></a>分点</h4><p>若A,B,C共线，且$\frac{|\vec{AC}|}{\vec{CB}} =\frac{\lambda_1}{\lambda_2}$<br>则$C=\frac{\lambda_2 A + \lambda_1 B}{\lambda_1 + \lambda_2}$</p><h4 id="三角形的面积"><a href="#三角形的面积" class="headerlink" title="三角形的面积"></a>三角形的面积</h4><p>$ S(\Delta ABC) = \frac{|\vec{AB}\times\vec{AC}|}{2}$</p><h4 id="两直线交点"><a href="#两直线交点" class="headerlink" title="两直线交点"></a>两直线交点</h4><p>$\frac{|\vec{AO}|}{|\vec{OB}|} = \frac{S(\Delta ADC)}{S(\Delta BCD)} = \frac {\vec{AD}\times\vec{AC}}{\vec{BC}\times\vec{BD}}$</p><h2 id="为完待续…-2017-8-6"><a href="#为完待续…-2017-8-6" class="headerlink" title="为完待续…..(2017-8-6)"></a>为完待续…..(2017-8-6)</h2>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/06/70/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[GDOI2014] 拯救莫莉斯</title>
      <link>https://blog.wildrage.xyz/2017/08/06/69/</link>
      <guid>https://blog.wildrage.xyz/2017/08/06/69/</guid>
      <pubDate>Sun, 06 Aug 2017 12:51:44 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;莫莉斯·乔是圣域里一个叱咤风云的人物，他凭借着自身超强的经济头脑，牢牢控制了圣域的石油市场。&lt;/p&gt;
&lt;p&gt;圣域的地图可以看成是一个n*m的矩阵。每个整数坐标点(x , y)表示一座城市（1&amp;lt;=x&amp;lt;= n, 1&amp;lt;=y&amp;lt;=m）。两座城市间相邻的定义为：对于城市$(A_x, A_y)$和城市$(B_x, B_y)$，满足$(A_x - B_x)^2 + (A_y - B_y)^2 = 1$。&lt;br&gt;由于圣域的石油贸易总量很大，莫莉斯意识到不能让每笔石油订购单都从同一个油库里发货。为了提高效率，莫莉斯·乔决定在其中一些城市里建造油库，最终使得每一个城市X都满足下列条件之一：&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>莫莉斯·乔是圣域里一个叱咤风云的人物，他凭借着自身超强的经济头脑，牢牢控制了圣域的石油市场。</p><p>圣域的地图可以看成是一个n*m的矩阵。每个整数坐标点(x , y)表示一座城市（1&lt;=x&lt;= n, 1&lt;=y&lt;=m）。两座城市间相邻的定义为：对于城市$(A_x, A_y)$和城市$(B_x, B_y)$，满足$(A_x - B_x)^2 + (A_y - B_y)^2 = 1$。<br>由于圣域的石油贸易总量很大，莫莉斯意识到不能让每笔石油订购单都从同一个油库里发货。为了提高效率，莫莉斯·乔决定在其中一些城市里建造油库，最终使得每一个城市X都满足下列条件之一：<br><a id="more"></a><br>1.该城市X内建有油库，</p><p>2.某城市Y内建有油库，且城市X与城市Y相邻。</p><p>与地球类似，圣域里不同城市间的地价可能也会有所不同，所以莫莉斯想让完成目标的总花费尽可能少。如果存在多组方案，为了方便管理，莫莉斯会选择建造较少的油库个数。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行两个正整数n,m ( n * m &lt;= 50 且m&lt;=n)，表示矩阵的大小。</p><p>接下来一个n行m列的矩阵F，Fi, j表示在城市(i,j)建造油库的代价。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出两个数，建造方案的油库个数和方案的总代价。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><blockquote><p>3 3<br>6 5 4<br>1 2 3<br>7 8 9  </p></blockquote><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><blockquote><p>3 6  </p></blockquote><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于30%数据满足 n * m &lt;= 25;<br>对于100%数据满足n * m &lt;= 50; 0 &lt;= Fi, j &lt;= 100000</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>按照题目的定义，第i行的状态，只会对i-1行至i+1行产生影响<br>F[i][j][k] 为对于前i行，第i-1行状态为j， 第i行的状态为k，并且对于任意一行x（x&lt;i），该行的所有城市满足题目的要求（附近城市里有油库）<br><!--more--><br>F[i][j][k]的值表示其所能达到的最小代价<br>（辅助数组G[i][j][k] 表示F[i][j][k]所对应方案里的油库数量）</p><p>F[i+1][k][X] = min(F[i][j][k] + cost[i+1][X]); (0 &lt;= X &lt;= 2m )</p><p>cost[i][j] 表示第i行，所取状态为j时所需要花费的代价。</p><p>转移方程中，X状态可取，需使第i行的所有城市满足要求，即：<br>(X|j|k|(k&lt;&lt;1)|(k&gt;&gt;1))&amp;(2^m-1)=2^m-1<br>答案：max(F[n+1][x][0])(0&lt;=X&lt;=2m)</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int F[52][(1 &lt;&lt; 8) + 1][(1 &lt;&lt; 8) + 1], G[52][(1 &lt;&lt; 8) + 1][(1 &lt;&lt; 8) + 1];int a[55][55], n, m, N;int check(int x, int S){    int ans = 0;    for (int i = 1; i &lt;= m; i++)    {        if (((1 &lt;&lt; (i - 1)) &amp; S))            ans += a[x][i];    }    return ans;}int Get_num(int x){    int ans = 0;    while (x)    {        if (x &amp; 1)            ans++;        x &gt;&gt;= 1;    }    return ans;}int main(){    //freopen(&quot;proj.in&quot;, &quot;r&quot;, stdin);    //freopen(&quot;proj.out&quot;, &quot;w&quot;, stdout);    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i++)        for (int j = 1; j &lt;= m; j++)            scanf(&quot;%d&quot;, &amp;a[i][j]);    memset(F, 0x3f, sizeof(F));    N = (1 &lt;&lt; m) - 1;    for (int i = 0; i &lt;= N; i++)    {        //if ((((i &gt;&gt; 1) | (i &lt;&lt; 1) | i) &amp; N) == N)        //{            int ans = check(1, i);            F[1][0][i] = ans;            G[1][0][i] = Get_num(i);        //}    }    for (int i = 1; i &lt;= n; i++)        for (int j = 0; j &lt;= N; j++)            for (int k = 0; k &lt;= N; k++)                for (int m = 0; m &lt;= N; m++)                    if (((j | k | m | (k &lt;&lt; 1) | (k &gt;&gt; 1)) &amp; (N)) == N)                    {                        if (F[i][j][k] + check(i + 1, m) &lt; F[i + 1][k][m])                        {                            F[i + 1][k][m] = F[i][j][k] + check(i + 1, m);                            G[i + 1][k][m] = G[i][j][k] + Get_num(m);                        }                    }    int ans = 0x3f3f3f4f, num = 0;    for (int i = 0; i &lt;= N; i++)    {        if (F[n + 1][i][0] &lt; ans)        {            ans = F[n + 1][i][0];            num = G[n + 1][i][0];        }        else if (F[n + 1][i][0] == ans)        {            if (num &gt; G[n + 1][i][0])                num = G[n + 1][i][0];        }    }    printf(&quot;%d %d&quot;, num, ans);    //while (1)    ;}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/06/69/#disqus_thread</comments>
    </item>
    
    <item>
      <title>选美</title>
      <link>https://blog.wildrage.xyz/2017/08/06/68/</link>
      <guid>https://blog.wildrage.xyz/2017/08/06/68/</guid>
      <pubDate>Sun, 06 Aug 2017 12:42:41 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;【题目描述】&quot;&gt;&lt;a href=&quot;#【题目描述】&quot; class=&quot;headerlink&quot; title=&quot;【题目描述】&quot;&gt;&lt;/a&gt;【题目描述】&lt;/h3&gt;&lt;p&gt;一年一度的星哥选美又拉开了帷幕&lt;/p&gt;
&lt;p&gt;N个人报名参加选拔，每个人都有着各自的相貌参数和身材参数（不大于 10000 的正整数）。你的任务是尽可能让更多人被星哥选中，而唯一要求就是，在这只队伍里面的每个人，都需满足以下不等式：&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>一年一度的星哥选美又拉开了帷幕</p><p>N个人报名参加选拔，每个人都有着各自的相貌参数和身材参数（不大于 10000 的正整数）。你的任务是尽可能让更多人被星哥选中，而唯一要求就是，在这只队伍里面的每个人，都需满足以下不等式：<br><a id="more"></a><br>$A (H− h) +B(W− w) ≤ C$</p><p>其中H和W为这个人的相貌和身材， h和w为选中者中的最小相貌参数和最小身材参数，而A、 B、 C为三个不大于 10000 的正的整型常数。</p><p>现在请计算星哥最多可以选中多少人。</p><h3 id="【输入格式】"><a href="#【输入格式】" class="headerlink" title="【输入格式】"></a>【输入格式】</h3><p>第一行：一个整数： N(0&lt;N&lt;=2000)</p><p>第二行：三个分开的整数： A,B和C</p><p>第三行到第N+ 2行：每行有两个用空格分开的整数，分别表示一个人的相貌参数和身材参数</p><h3 id="【输出格式】"><a href="#【输出格式】" class="headerlink" title="【输出格式】"></a>【输出格式】</h3><p>第一行：最多被选的人数</p><h3 id="【输入样例】"><a href="#【输入样例】" class="headerlink" title="【输入样例】"></a>【输入样例】</h3><blockquote><p>8<br>1 2 4<br>5 1<br>3 2<br>2 3<br>2 1<br>7 2<br>6 4<br>5 1<br>4 3  </p></blockquote><h3 id="【输出样例】"><a href="#【输出样例】" class="headerlink" title="【输出样例】"></a>【输出样例】</h3><blockquote><p>5  </p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>只有$n^2\log_2{n}$的算法</p><p>先按H排序  </p><p>枚举每一个h   </p><p>然后将他后面的部分再按w排序  </p><p>由树状树状维护前缀和就可以求出来了</p><pre><code class="c++">/* * @Author: WildRage  * @Date: 2017-08-06 17:57:21  * @Last Modified by: WildRage * @Last Modified time: 2017-08-07 19:11:10 */#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;struct data{    int h, w;} a[2005], b[2005];int n, A, B, C, m;int comp(const data &amp;a, const data &amp;b){    return a.h &lt; b.h;}int cmp(const data &amp;a, const data &amp;b){    return a.w &lt; b.w;}int c[2005];int lowbit(int x){    return x &amp; (-x);}void add(int x, int w){    for (int i = x; i &lt;= m; i += lowbit(i))        c[i] += w;}int sum(int x){    int s = 0;    for (int i = x; i; i -= lowbit(i))        s += c[i];    return s;}int ans = 0;void solve(int from){    int h_min = a[from].h, w_min;    int all;    memcpy(b, a, sizeof(b));    memset(c, 0, sizeof(c));    sort(b + from, b + n + 1, cmp);    int Sum[2005], Hash[2005];    for (int i = from; i &lt;= n; i++)        Hash[i] = Sum[i] = b[i].h * A + b[i].w * B;    sort(Hash + from, Hash + n + 1);    m = unique(Hash + from, Hash + n + 1) - Hash - 1;    for (int i = from; i &lt;= n; i++)    {        int x = upper_bound(Hash + from, Hash + m + 1, Sum[i]) - Hash - 1;        add(x, 1);    }    for (int i = from; i &lt;= n; i++)    {        w_min = b[i].w;        all = C + A * h_min + B * w_min;        int x = upper_bound(Hash + from, Hash + m + 1, all) - Hash - 1;        ans = max(ans, sum(x));        add(upper_bound(Hash + from, Hash + m + 1, Sum[i]) - Hash - 1, -1);    }}int main(){    //freopen(&quot;beauty.in&quot;, &quot;r&quot;, stdin);    //freopen(&quot;beauty.out&quot;, &quot;w&quot;, stdout);    scanf(&quot;%d&quot;, &amp;n);    scanf(&quot;%d%d%d&quot;, &amp;A, &amp;B, &amp;C);    for (int i = 1; i &lt;= n; i++)    {        scanf(&quot;%d%d&quot;, &amp;a[i].h, &amp;a[i].w);    }    sort(a + 1, a + n + 1, comp);    for (int i = 1; i &lt;= n; i++)        solve(i);    printf(&quot;%d&quot;, ans);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/06/68/#disqus_thread</comments>
    </item>
    
    <item>
      <title>天鹅会面</title>
      <link>https://blog.wildrage.xyz/2017/08/06/67/</link>
      <guid>https://blog.wildrage.xyz/2017/08/06/67/</guid>
      <pubDate>Sun, 06 Aug 2017 12:34:46 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;两头白天鹅生活在一个部分湖面结了冰的湖泊中，湖面的形状为一个长方形，并且被分割成R行C列的小方格，某些方格中结了冰，这样的方格称之为冰格，其余的方格称之为水格。冬天过去了，湖面上的冰渐渐开始溶解了，每一天与水相邻的冰格就将消融而转化为水格。所谓两个方格相邻是指它们在水平或垂直方向有公共边，两个呈对角的方格是不相邻的，下图给出样例数据的演化过程。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>两头白天鹅生活在一个部分湖面结了冰的湖泊中，湖面的形状为一个长方形，并且被分割成R行C列的小方格，某些方格中结了冰，这样的方格称之为冰格，其余的方格称之为水格。冬天过去了，湖面上的冰渐渐开始溶解了，每一天与水相邻的冰格就将消融而转化为水格。所谓两个方格相邻是指它们在水平或垂直方向有公共边，两个呈对角的方格是不相邻的，下图给出样例数据的演化过程。<br><a id="more"></a><br>白天鹅只能在水中沿水平或垂直方向游动，写一个程序判断多少天后两只白天鹅才能够相会。</p><h3 id="【输入格式】"><a href="#【输入格式】" class="headerlink" title="【输入格式】"></a>【输入格式】</h3><p>输入文件第一行包含两个用空格隔开的整数R和C，其中1 ≤ R, C ≤ 1500，接下来的R行每行包含C个字符，描述湖面的初始状态，‘·’表示水格，‘ X’表示冰格，‘ L’表示一只白天鹅。</p><h3 id="【输出格式】"><a href="#【输出格式】" class="headerlink" title="【输出格式】"></a>【输出格式】</h3><p>输出文件仅一行包含一个整数表示两只白天鹅等到相邻那一天所需的天数。</p><h3 id="【输入样例】"><a href="#【输入样例】" class="headerlink" title="【输入样例】"></a>【输入样例】</h3><blockquote><p>8 17<br>…XXXXXX..XX.XXX<br>….XXXXXXXXX.XXX<br>…XXXXXXXXXXXX..<br>..XXXXX.LXXXXXX..<br>.XXXXXX..XXXXXX..<br>XXXXXXX…XXXX…<br>..XXXXX…XXX….<br>….XXXXX.XXXL…  </p></blockquote><h3 id="【输出样例】"><a href="#【输出样例】" class="headerlink" title="【输出样例】"></a>【输出样例】</h3><blockquote><p>2</p></blockquote><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>30%数据1 ≤ R《400.1 ≤ C《300<br>100%其中1 ≤ R, C ≤ 1500</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>怎么说呢，本来和简单的一道题<br>结果因为一个知识点不熟<br>然后就没做出来<br>其实就是两遍DFS<br>第一遍求出每个点到他的最近的水的距离<br>然后一边dfs求出起点到终点的过程中的最小值</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;bool map[1505][1505];int dis[1505][1505];struct Point{    int x, y;} S, E, Q[20000000];int R, C;int movex[5] = {0, 0, 0, 1, -1},    movey[5] = {0, 1, -1, 0, 0};bool flag[1505][1505];void bfs_init(){    //memset(flag,0,sizeof(flag));    int l = 1, r = 0;    memset(dis, 0x3f, sizeof(dis));    for (int i = 1; i &lt;= R; i++)    {        for (int j = 1; j &lt;= C; j++)        {            if (!map[i][j])            {                Q[++r] = (Point){i, j};                dis[i][j] = 0;            }        }    }    while (l &lt;= r)    {        Point k = Q[l++];        for (int i = 1; i &lt;= 4; i++)        {            if (k.x + movex[i] &gt; R || k.x + movex[i] &lt; 1)                continue;            if (k.y + movey[i] &gt; C || k.y + movey[i] &lt; 1)                continue;            if (dis[k.x + movex[i]][k.y + movey[i]] &gt; dis[k.x][k.y] + 1)            {                dis[k.x + movex[i]][k.y + movey[i]] = dis[k.x][k.y] + 1;                Q[++r] = (Point) { k.x + movex[i], k.y + movey[i] };            }        }    }}int d[1505][1505];int SPFA(){    memset(d, 0x3f, sizeof(d));    d[S.x][S.y] = 0;    int l = 1, r = 0;    Q[++r] = S;    //flag[S.x][S.y] = 1;    while (l &lt;= r)    {        Point k = Q[l++];        //flag[k.x][k.y] = 0;        for (int i = 1; i &lt;= 4; i++)        {            if (k.x + movex[i] &gt; R || k.x + movex[i] &lt; 1)                continue;            if (k.y + movey[i] &gt; C || k.y + movey[i] &lt; 1)                continue;            if (d[k.x + movex[i]][k.y + movey[i]] &gt; max(d[k.x][k.y], dis[k.x + movex[i]][k.y + movey[i]]))            {                d[k.x + movex[i]][k.y + movey[i]] = max(d[k.x][k.y], dis[k.x + movex[i]][k.y + movey[i]]);                //if (!flag[k.x + movex[i]][k.y + movey[i]])                //{                    Q[++r] = (Point){k.x + movex[i], k.y + movey[i]};                    //flag[k.x + movex[i]][k.y + movey[i]] = 1;                //}            }        }    }    return d[E.x][E.y];}int main(){    //freopen(&quot;swan.in&quot;, &quot;r&quot;, stdin);    // freopen(&quot;swan.out&quot;, &quot;w&quot;, stdout);    char c;    scanf(&quot;%d%d&quot;, &amp;R, &amp;C);    bool flag = 0;    for (int i = 1; i &lt;= R; i++)    {        for (int j = 1; j &lt;= C; j++)        {            c = getchar();            while (c != &#39;.&#39; &amp;&amp; c != &#39;X&#39; &amp;&amp; c != &#39;L&#39;)                c = getchar();            if (c == &#39;X&#39;)                map[i][j] = 1;            else if (c == &#39;L&#39;)            {                if (flag)                    E = (Point){i, j};                else                {                    S = (Point){i, j};                    flag = 1;                }            }        }    }    bfs_init();    printf(&quot;%d&quot;, SPFA());    //while (1)    ;}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/06/67/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[BZOJ3166]: [Heoi2013] Alo</title>
      <link>https://blog.wildrage.xyz/2017/08/05/66/</link>
      <guid>https://blog.wildrage.xyz/2017/08/05/66/</guid>
      <pubDate>Sat, 05 Aug 2017 03:18:36 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;Welcome to ALO ( Arithmetic and Logistic Online)。这是一个VR MMORPG ，&lt;br&gt;如名字所见，到处充满了数学的谜题。&lt;br&gt;现在你拥有n颗宝石，每颗宝石有一个能量密度，记为ai，这些宝石的能量&lt;br&gt;密度两两不同。现在你可以选取连续的一些宝石（必须多于一个）进行融合，设为 ai, ai+1, …, a j，则融合而成的宝石的能量密度为这些宝石中能量密度的次大值&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Welcome to ALO ( Arithmetic and Logistic Online)。这是一个VR MMORPG ，<br>如名字所见，到处充满了数学的谜题。<br>现在你拥有n颗宝石，每颗宝石有一个能量密度，记为ai，这些宝石的能量<br>密度两两不同。现在你可以选取连续的一些宝石（必须多于一个）进行融合，设为 ai, ai+1, …, a j，则融合而成的宝石的能量密度为这些宝石中能量密度的次大值<br><a id="more"></a><br>与其他任意一颗宝石的能量密度按位异或的值，即，设该段宝石能量密度次大值<br>为k，则生成的宝石的能量密度为max{k xor ap | ap ≠ k , i ≤ p ≤ j}。<br>现在你需要知道你怎么选取需要融合的宝石，才能使生成的宝石能量密度最大。 </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行，一个整数 n，表示宝石个数。<br>第二行， n个整数，分别表示a1至an，表示每颗宝石的能量密度，保证对于i ≠ j有 ai ≠ aj。 </p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一行一个整数，表示最大能生成的宝石能量密度。 </p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>5<br>9 2 1 4 7</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>14  </p></blockquote><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>【样例解释】<br>选择区间[1,5]，最大值为 7 xor 9。<br>对于 100%的数据有 1 ≤ n ≤ 50000, 0 ≤ ai ≤ 10^9</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>如图由左右比他大的值得到了一个区间<br><img src="https://moetu.fastmirror.org/images/2017/08/05/1181169-20170803204801365-12244565356d7b7.png" alt="1181169-20170803204801365-12244565356d7b7.png"></p><p>我们用Set维护查排名比他大1的就可以了</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;set&gt;#include &lt;algorithm&gt;int n;const int INF = 1000000000;const int full = 30;struct Trie{    struct Trie_Node    {        Trie_Node *ch[2];        int s;        Trie_Node()        {            ch[0] = ch[1] = NULL;            s = 0;        }    } * root[100005], *null;    Trie()    {        null = new Trie_Node();        null-&gt;ch[0] = null-&gt;ch[1] = null;        root[0] = new Trie_Node();        root[0]-&gt;ch[1] = root[0]-&gt;ch[0] = null;    }    Trie_Node *NewNode()    {        Trie_Node *rt = new Trie_Node();        rt-&gt;ch[0] = rt-&gt;ch[1] = null;        return rt;    }    void copy(Trie_Node *&amp;a, Trie_Node *b)    {        if (b == null)            a = null;        else            a = NewNode(), *a = *b;    }    void Insert(int x, int cnt)    {        copy(root[cnt], root[cnt - 1]);        Trie_Node *rt1 = root[cnt], *rt2 = root[cnt - 1];        for (int i = full; i &gt;= 0; i--)        {            int k = (x &gt;&gt; i) &amp; 1;            copy(rt1-&gt;ch[k], rt2-&gt;ch[k]);            if (rt1-&gt;ch[k] == null)                rt1-&gt;ch[k] = NewNode();            rt1 = rt1-&gt;ch[k], rt2 = rt2-&gt;ch[k];            rt1-&gt;s++;        }    }    int Query(int val, int l, int r)    {        int res = 0;        Trie_Node *rt1 = root[r], *rt2 = root[l - 1];        for (int i = full; i &gt;= 0; i--)        {            int next = (val &gt;&gt; i) &amp; 1;            if (rt1-&gt;ch[next ^ 1]-&gt;s - rt2-&gt;ch[next ^ 1]-&gt;s)            {                rt1 = rt1-&gt;ch[next ^ 1], rt2 = rt2-&gt;ch[next ^ 1];                res |= (1 &lt;&lt; i);            }            else            {                rt1 = rt1-&gt;ch[next], rt2 = rt2-&gt;ch[next];            }        }        return res;    }} root;struct data{    int val, i;    bool operator &lt; (const data &amp;a)const     {        return val &gt; a.val;    }} a[50005];std::set&lt;int&gt; st;int main(){    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i++)    {        scanf(&quot;%d&quot;, &amp;a[i].val);        a[i].i = i;    }    for (int i = 1; i &lt;= n; ++i)    {        root.Insert(a[i].val, i);    }    st.insert(-1), st.insert(INF), st.insert(-2), st.insert(INF + 1);    std::sort(a + 1, a + n + 1);    st.insert(a[1].i);    int ans = 0;    for (int i = 2; i &lt;= n; i++)    {        int l = a[i].i, r = a[i].i;        std::set&lt;int&gt;::iterator T, P;        P = st.lower_bound(a[i].i);        T = P;        r = *T; T++; r = *T - 1;        l = *--P; P--;l = *P + 1;        l = std::max(1, l), r = std::min(r, n);        if (l != r)        {            ans = std::max(ans, root.Query(a[i].val, l, r));        }        st.insert(a[i].i);    }    printf(&quot;%d&quot;, ans);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/05/66/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[BZOJ2432][Noi2011]兔农 矩阵乘法+exgcd</title>
      <link>https://blog.wildrage.xyz/2017/08/05/65/</link>
      <guid>https://blog.wildrage.xyz/2017/08/05/65/</guid>
      <pubDate>Sat, 05 Aug 2017 00:57:32 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt; 农夫栋栋近年收入不景气，正在他发愁如何能多赚点钱时，他听到隔壁的小朋友在讨论兔子繁殖的问题。&lt;br&gt;问题是这样的：第一个月初有一对刚出生的小兔子，经过两个月长大后，这对兔子从第三个月开始，每个月初生一对小兔子。新出生的小兔子生长两个月后又能每个月生出一对小兔子。问第n个月有多少只兔子？&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p> 农夫栋栋近年收入不景气，正在他发愁如何能多赚点钱时，他听到隔壁的小朋友在讨论兔子繁殖的问题。<br>问题是这样的：第一个月初有一对刚出生的小兔子，经过两个月长大后，这对兔子从第三个月开始，每个月初生一对小兔子。新出生的小兔子生长两个月后又能每个月生出一对小兔子。问第n个月有多少只兔子？<br><a id="more"></a><br>聪明的你可能已经发现，第n个月的兔子数正好是第n个Fibonacci(斐波那契)数。栋栋不懂什么是Fibonacci数，但他也发现了规律：第i+2个月的兔子数等于第i个月的兔子数加上第i+1个月的兔子数。前几个月的兔子数依次为：<br>1 1 2 3 5 8 13 21 34 …<br>栋栋发现越到后面兔子数增长的越快，期待养兔子一定能赚大钱，于是栋栋在第一个月初买了一对小兔子开始饲养。<br>每天，栋栋都要给兔子们喂食，兔子们吃食时非常特别，总是每k对兔子围成一圈，最后剩下的不足k对的围成一圈，由于兔子特别害怕孤独，从第三个月开始，如果吃食时围成某一个圈的只有一对兔子，这对兔子就会很快死掉。<br>我们假设死去的总是刚出生的兔子，那么每个月的兔子数仍然是可以计算的。例如，当k=7时，前几个月的兔子数依次为：<br>1 1 2 3 5 7 12 19 31 49 80 …<br>给定n，你能帮助栋栋计算第n个月他有多少对兔子么？由于答案可能非常大，你只需要告诉栋栋第n个月的兔子对数除p的余数即可。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入一行，包含三个正整数n, k, p。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一行，包含一个整数，表示栋栋第n个月的兔子对数除p的余数。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>6 7 100</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>7</p></blockquote><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$1&lt;=N&lt;=10^18$<br>$2&lt;=K&lt;=10^6$<br>$2&lt;=P&lt;=10^9$</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>暴力75 暴力给的很足<br>可是后面的25分死一样难拿  </p><p>我们可以以%7为例打一个表<br>如果以 减1为0 为分界那么会出现这样的情况</p><p>1, 1, 2, 3, 5, 0,<br>5, 5, 3, 0,<br>3, 3, 6, 2, 0,<br>2, 2, 4, 6, 3, 2, 5, 0,<br>5, 5, 3, 0,<br>3, 3, 6, 2, 0,<br>·········</p><p>那么我们会发现他用2个性质</p><ol><li>我们发现，每段开头必为相同的两数，并且它们恰是上一段的最末一位非0数；由于总共只有k−1种余数，所以不超过k段就会出现循环（如果有的话）。</li><li>设开头的数为x 那么这个数列为%k意义下的斐波那契数列</li></ol><p>我们发现在最后一个数变为0前<br>$ x*f[len] \equiv 1 (mod k)$<br>那么f[len]为x在模k意义下的逆元<br>所以，我们可以通过exgcd或者扩展欧拉定理，来快速求出f[len]。<br>如果没有逆元直接斐波那契数列矩阵快速幂过去就可以了</p><p>然后我们需要len<br>其实这个我们可以预处理出来vis<br>每次查询即可  </p><p>最后由 $x*f[len-1]$ 得下一段的开头  </p><p>有一个很强的结论：斐波那契数列在模k意义下一定是以0 1 1……为开头的循环，并且循环节长度&lt;=6*k，所以暴力算vis就可以了  </p><p>然后我们需要行内的转移矩阵<br>$$ \begin{bmatrix} 1 &amp; 1 &amp; 0 \\ 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix} $$</p><p>行间的转移矩阵</p><p>$$ \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ -1 &amp; 0 &amp; 1 \end{bmatrix} $$</p><p>什么你问我代码？<br>我也没打出来啊。。。。。</p>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/05/65/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[NOIP2011] 聪明的质监员</title>
      <link>https://blog.wildrage.xyz/2017/08/05/64/</link>
      <guid>https://blog.wildrage.xyz/2017/08/05/64/</guid>
      <pubDate>Sat, 05 Aug 2017 00:36:01 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;【问题描述】&quot;&gt;&lt;a href=&quot;#【问题描述】&quot; class=&quot;headerlink&quot; title=&quot;【问题描述】&quot;&gt;&lt;/a&gt;【问题描述】&lt;/h3&gt;&lt;p&gt;小 T 是一名质量监督员，最近负责检验一批矿产的质量。这批矿产共有n个矿石，从 1 到n逐一编号，每个矿石都有自己的重量$w_i$以及价值$v_i$。检验矿产的流程是：&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="【问题描述】"><a href="#【问题描述】" class="headerlink" title="【问题描述】"></a>【问题描述】</h3><p>小 T 是一名质量监督员，最近负责检验一批矿产的质量。这批矿产共有n个矿石，从 1 到n逐一编号，每个矿石都有自己的重量$w_i$以及价值$v_i$。检验矿产的流程是：<br><a id="more"></a></p><ol><li>给定 m个区间$[L_i,R_i]$； </li><li>选出一个参数W； </li><li>对于一个区间$[L_i,R_i]$，计算矿石在这个区间上的检验值$Y_i$： </li></ol><p>$$ Y_i = \sum_{j}{1}*\sum_{j}{v_j},j \in [L_i,R_i] {且} w_j≥W,{j是矿石编号} $$<br>这批矿产的检验结果Y为各个区间的检验值之和。即：<br>$$ Y=\sum_{i=1}^{m}{Y_i} $$</p><p>若这批矿产的检验结果与所给标准值 S 相差太多，就需要再去检验另一批矿产。小 T 不想费时间去检验另一批矿产，所以他想通过调整参数 W 的值，让检验结果尽可能的靠近标准值 S，即使得S−Y的绝对值最小。请你帮忙求出这个最小值。 </p><h3 id="【输入】"><a href="#【输入】" class="headerlink" title="【输入】"></a>【输入】</h3><p>输入文件 qc.in。<br>第一行包含三个整数n，m，S，分别表示矿石的个数、区间的个数和标准值。<br>接下来的n 行，每行2 个整数，中间用空格隔开，第i+1 行表示i 号矿石的重量wi 和价值vi 。<br>接下来的m 行，表示区间，每行2 个整数，中间用空格隔开，第i+n+1 行表示区间$[L_i,R_i]$的两个端点$L_i$ 和$R_i$。注意：不同区间可能重合或相互重叠。</p><h3 id="【输出】"><a href="#【输出】" class="headerlink" title="【输出】"></a>【输出】</h3><p>输出文件名为qc.out。<br>输出只有一行，包含一个整数，表示所求的最小值。</p><h3 id="【输入输出样例】"><a href="#【输入输出样例】" class="headerlink" title="【输入输出样例】"></a>【输入输出样例】</h3><h4 id="qc-in"><a href="#qc-in" class="headerlink" title="qc.in"></a>qc.in</h4><blockquote><p>5 3 15<br>1 5<br>2 5<br>3 5<br>4 5<br>5 5<br>1 5<br>2 4<br>3 3 </p></blockquote><h4 id="qc-out"><a href="#qc-out" class="headerlink" title="qc.out"></a>qc.out</h4><blockquote><p>10  </p></blockquote><h3 id="【输入输出样例说明】"><a href="#【输入输出样例说明】" class="headerlink" title="【输入输出样例说明】"></a>【输入输出样例说明】</h3><p>当W 选4 的时候，三个区间上检验值分别为20、5、0，这批矿产的检验结果为25，此时与标准值S 相差最小为10。</p><h3 id="【数据范围】"><a href="#【数据范围】" class="headerlink" title="【数据范围】"></a>【数据范围】</h3><p>对于10%的数据，有$1≤n，m≤10$；<br>对于30%的数据，有$1≤n，m≤500$；<br>对于50%的数据，有$1≤n，m≤5,000$；<br>对于70%的数据，有$1≤n，m≤10,000$；<br>对于100%的数据，有$1≤n，m≤200,000,0 &lt; w_i, v_i≤10^6，0 &lt; S≤10^12，1≤L_i≤R_i≤n$。  </p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>三分W<br>$O(n+m)$ 求出Y<br>然后比较找最近的  </p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;#define LL long longint n, m;struct data{    int w, v;} a[200005];struct Data{    int l, r;} Q[200005];int Sumn[200005];LL Sumv[200005];LL check(int w){    Sumn[0] = 0;    Sumv[0] = 1;    for (int i = 1; i &lt;= n; i++)    {        Sumn[i] = Sumn[i - 1] + (a[i].w &gt; w);        Sumv[i] = Sumv[i - 1] + (a[i].w &gt; w ? a[i].v : 0);    }    LL Y = 0;    for (int i = 1; i &lt;= m; i++)    {        Y += (Sumn[Q[i].r] - Sumn[Q[i].l - 1]) * (Sumv[Q[i].r] - Sumv[Q[i].l - 1]);    }    return Y;}int main(){    freopen(&quot;qc.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;qc.out&quot;, &quot;w&quot;, stdout);    LL S;    scanf(&quot;%d%d%lld&quot;, &amp;n, &amp;m, &amp;S);    int Max = 0;    for (int i = 1; i &lt;= n; i++)    {        scanf(&quot;%d%d&quot;, &amp;a[i].w, &amp;a[i].v);        Max = max(Max, a[i].w);    }    for (int i = 1; i &lt;= m; i++)    {        scanf(&quot;%d%d&quot;, &amp;Q[i].l, &amp;Q[i].r);    }    LL l = 0, r = Max;    LL ans = 0x3fffffffffffffffLL;    while (l &lt; r)    {        LL mid = l + r &gt;&gt; 1;        LL t = check(mid);        if (t &lt; S)        {            ans = min(ans, abs(t - S));            r = mid;        }        else        {            ans = min(ans, abs(t - S));            l = mid + 1;        }    }    printf(&quot;%lld&quot;, ans);    //while (1);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/05/64/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[BZOJ 1124][POI 2008] 枪战 Maf</title>
      <link>https://blog.wildrage.xyz/2017/08/03/63/</link>
      <guid>https://blog.wildrage.xyz/2017/08/03/63/</guid>
      <pubDate>Thu, 03 Aug 2017 00:37:31 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;有n个人，每个人手里有一把手枪。一开始所有人都选定一个人瞄准（有可能瞄准自己）。然后他们按某个顺序开枪，且任意时刻只有一个人开枪。因此，对于不同的开枪顺序，最后死的人也不同。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>有n个人，每个人手里有一把手枪。一开始所有人都选定一个人瞄准（有可能瞄准自己）。然后他们按某个顺序开枪，且任意时刻只有一个人开枪。因此，对于不同的开枪顺序，最后死的人也不同。<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入n人数&lt;1000000 每个人的aim</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>你要求最后死亡数目的最小和最大可能</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>8<br>2 3 2 2 6 7 8 5  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>3 5  </p></blockquote><h2 id="我也不会啊"><a href="#我也不会啊" class="headerlink" title="我也不会啊"></a>我也不会啊</h2><p>树DP<a href="https://www.cnblogs.com/TSHugh/p/7273841.html" target="_blank" rel="noopener">TH_Hugh</a><br><a href="https://www.cnblogs.com/liu-runda/p/5940191.html" target="_blank" rel="noopener">liu_runda</a></p><p>贴代码</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;int a[1000005], Maxn, t, Min, Max;int times[1000005];bool die[1000005], nodie[1000005];int Q[1000005];int main(){    //freopen(&quot;maf.in&quot;, &quot;r&quot;, stdin);    //freopen(&quot;maf.out&quot;, &quot;w&quot;, stdout);    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i++)    {        scanf(&quot;%d&quot;, &amp;a[i]);        times[a[i]]++;    }    //Q.resize(1000001);    for (int i = 1; i &lt;= n; i++)    {        if (!times[i])        {            Max++;            Q[++Min] = i;        }    }    //printf(&quot;%d\n&quot;,Max);    //for (vector&lt;int&gt;::iterator it = Q.begin(); it != Q.end(); it++)    for (int i = 1; i &lt;= Min; i++)    {        //printf(&quot;%d---------%d=======\n&quot;,it-Q.begin(),*it);        int k = a[Q[i]];        if (die[k])            continue;        die[k] = 1;        nodie[a[k]] = 1;        --times[a[k]];        if (!times[a[k]])        {            Q[++Min]=a[k];         }    }    int sum;    bool All_NoDied;    for (int i = 1; i &lt;= n; i++)    {        if (times[i] &amp;&amp; !die[i])        {            sum = 0;            All_NoDied = 0;            for (int j = i; !die[j]; j = a[j])            {                die[j] = 1;                sum++;                All_NoDied |= nodie[j];            }            if (!All_NoDied &amp;&amp; sum &gt; 1)                Max++;            Min += sum / 2;        }    }    printf(&quot;%d %d\n&quot;, n - Min, n - Max);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/03/63/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[BZOJ 1647][USACO 2007 Open] Fliptile 翻格子游戏</title>
      <link>https://blog.wildrage.xyz/2017/08/03/62/</link>
      <guid>https://blog.wildrage.xyz/2017/08/03/62/</guid>
      <pubDate>Thu, 03 Aug 2017 00:36:56 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;Farmer John knows that an intellectually satisfied cow is a happy cow who will give more milk. He has arranged a brainy activity for cows in which they manipulate an M x N grid (1 &amp;lt;= M &amp;lt;= 15; 1 &amp;lt;= N &amp;lt;= 15) of square tiles, each of which is colored black on one side and white on the other side. As one would guess, when a single white tile is flipped, it changes to black;&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Farmer John knows that an intellectually satisfied cow is a happy cow who will give more milk. He has arranged a brainy activity for cows in which they manipulate an M x N grid (1 &lt;= M &lt;= 15; 1 &lt;= N &lt;= 15) of square tiles, each of which is colored black on one side and white on the other side. As one would guess, when a single white tile is flipped, it changes to black;<br><a id="more"></a><br>when a single black tile is flipped, it changes to white. The cows are rewarded when they flip the tiles so that each tile has the white side face up. However, the cows have rather large hooves and when they try to flip a certain tile, they also flip all the adjacent tiles (tiles that share a full edge with the flipped tile). Since the flips are tiring, the cows want to minimize the number of flips they have to make. Help the cows determine the minimum number of flips required, and the locations to flip to achieve that minimum. If there are multiple ways to achieve the task with the minimum amount of flips, return the one with the least lexicographical ordering in the output when considered as a string. If the task is impossible, print one line with the word “IMPOSSIBLE”.</p><p> 约翰知道，那些高智力又快乐的奶牛产奶量特别高．所以他做了一个翻瓦片的益智游戏来娱乐奶牛．在一个M×N(1≤M，N≤15)的骨架上，每一个格子里都有一个可以翻转的瓦片．瓦片的一面是黑色的，而另一面是白色的．对一个瓦片进行翻转，可以使黑变白，也可以使白变黑．然而，奶牛们的蹄子是如此的巨大而且笨拙，所以她们翻转一个瓦片的时候，与之有公共边的相邻瓦片也都被翻转了．那么，这些奶牛们最少需要多少次翻转，使所有的瓦片都变成白面向上呢？如杲可以做到，输出字典序最小的结果（将结果当成字符串处理）．如果不能做到，输出“IMPOSSIBLE”．</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><ul><li><p>Line 1: Two space-separated integers: M and N</p></li><li><p>Lines 2..M+1: Line i+1 describes the colors (left to right) of row i of the grid with N space-separated integers which are 1 for black and 0 for white</p><p>  第1行输入M和N，之后M行N列，输入游戏开始时的瓦片状态．0表示白面向上，1表示黑面向上．</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3></li><li><p>Lines 1..M: Each line contains N space-separated integers, each specifying how many times to flip that particular location.</p><p>  输出M行，每行N个用空格隔开的整数，表示对应的格子进行了多少次翻转．</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>4 4<br>1 0 0 1<br>0 1 1 0<br>0 1 1 0<br>1 0 0 1  </p></blockquote></li></ul><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>0 0 0 0<br>1 0 0 1<br>1 0 0 1<br>0 0 0 0  </p></blockquote><h3 id="OUTPUT-DETAILS"><a href="#OUTPUT-DETAILS" class="headerlink" title="OUTPUT DETAILS:"></a>OUTPUT DETAILS:</h3><blockquote><p>After flipping at row 2 column 1, the board will look like:<br>0 0 0 1<br>1 0 1 0<br>1 1 1 0<br>1 0 0 1  </p><p>After flipping at row 2 column 4, the board will look like:<br>0 0 0 0<br>1 0 0 1<br>1 1 1 1<br>1 0 0 1  </p><p>After flipping at row 3 column 1, the board will look like:<br>0 0 0 0<br>0 0 0 1<br>0 0 1 1<br>0 0 0 1  </p><p>After flipping at row 3 column 4, the board will look like:<br>0 0 0 0<br>0 0 0 0<br>0 0 0 0<br>0 0 0 0  </p><p>Another solution might be:<br>0 1 1 0<br>0 0 0 0<br>0 0 0 0<br>0 1 1 0<br>but this solution is lexicographically higher than the solution above.  </p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>枚举第一行就可以了<br>然后往下跑  </p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;int n, m;int b[17][17], a[17][17], op[17][17];inline void DoChange(int x){    for (int j = 1; j &lt;= n; j++)    {        if (op[x][j])        {            a[x - 1][j] ^= 1;            a[x][j - 1] ^= 1;            a[x][j + 1] ^= 1;            a[x + 1][j] ^= 1;        }    }}inline bool ok(){    for (int i = 1; i &lt;= m; i++)    {        for (int j = 1; j &lt;= n; j++)        {            if (a[i][j] == 1)                return 0;        }    }    return 1;}inline void print(){    for (int i = 1; i &lt;= m; i++)    {        for (int j = 1; j &lt;= n; j++)        {            printf(&quot;%d &quot;, op[i][j]);        }        printf(&quot;\n&quot;);    }}int main(){    //freopen(&quot;fliptile.in&quot;, &quot;r&quot;, stdin);    //freopen(&quot;fliptile.out&quot;, &quot;w&quot;, stdout);    scanf(&quot;%d%d&quot;, &amp;m, &amp;n);    for (int i = 1; i &lt;= m; i++)        for (int j = 1; j &lt;= n; j++)        {            scanf(&quot;%d&quot;, &amp;b[i][j]);        }    int N = (1 &lt;&lt; n) - 1;    for (int i = 0; i &lt;= N; i++)    {        memcpy(a, b, sizeof(a));        memset(op, 0, sizeof(op));        for (int j = 1; j &lt;= n; j++)        {            if (i &amp; (1 &lt;&lt; (j - 1)))            {                op[1][j] = 1;                a[1 - 1][j] ^= 1;                a[1][j - 1] ^= 1;                a[1][j] ^= 1;                a[1][j + 1] ^= 1;                a[1 + 1][j] ^= 1;            }        }        for (int j = 1; j &lt; m; j++)        {            for (int k = 1; k &lt;= n; k++)            {                if (a[j][k])                {                    op[j + 1][k] = 1;                    a[j][k] ^= 1;                    a[j + 1][k] ^= 1;                    a[j + 1][k - 1] ^= 1;                    a[j + 1][k + 1] ^= 1;                    a[j + 2][k] ^= 1;                }            }        }        if (ok())        {            print();            //while (1);            exit(0);        }    }    printf(&quot;IMPOSSIBLE\n&quot;);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/03/62/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[BZOJ 1592] Making The Grade路面修整</title>
      <link>https://blog.wildrage.xyz/2017/08/03/61/</link>
      <guid>https://blog.wildrage.xyz/2017/08/03/61/</guid>
      <pubDate>Thu, 03 Aug 2017 00:24:30 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;FJ打算好好修一下农场中某条凹凸不平的土路。按奶牛们的要求，修好后的路面高度应当单调上升或单调下降，也就是说，高度上升与高度下降的路段不能同时出现在修好的路中。 整条路被分成了N段，N个整数A_1, … , A_N (1 &amp;lt;= N &amp;lt;= 2,000)依次描述了每一段路的高度(0 &amp;lt;= A_i &amp;lt;= 1,000,000,000)。FJ希望找到一个恰好含N个元素的不上升或不下降序列B_1, … , B_N，作为修过的路中每个路段的高度。由于将每一段路垫高或挖低一个单位的花费相同，修路的总支出可以表示为：$ |A_1 - B_1| + |A_2 - B_2| + … + |A_N - B_N| $请你计算一下，FJ在这项工程上的最小支出是多少。FJ向你保证，这个支出不会超过2^31-1。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>FJ打算好好修一下农场中某条凹凸不平的土路。按奶牛们的要求，修好后的路面高度应当单调上升或单调下降，也就是说，高度上升与高度下降的路段不能同时出现在修好的路中。 整条路被分成了N段，N个整数A_1, … , A_N (1 &lt;= N &lt;= 2,000)依次描述了每一段路的高度(0 &lt;= A_i &lt;= 1,000,000,000)。FJ希望找到一个恰好含N个元素的不上升或不下降序列B_1, … , B_N，作为修过的路中每个路段的高度。由于将每一段路垫高或挖低一个单位的花费相同，修路的总支出可以表示为：$ |A_1 - B_1| + |A_2 - B_2| + … + |A_N - B_N| $请你计算一下，FJ在这项工程上的最小支出是多少。FJ向你保证，这个支出不会超过2^31-1。<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><ul><li>第1行: 输入1个整数：N * 第2..N+1行: 第i+1行为1个整数：A_i</li></ul><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><ul><li>第1行: 输出1个正整数，表示FJ把路修成高度不上升或高度不下降的最小花费</li></ul><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>7<br>1<br>3<br>2<br>4<br>5<br>3<br>9  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>3  </p></blockquote><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>FJ将第一个高度为3的路段的高度减少为2，将第二个高度为3的路段的高度增加到5，总花费为|2-3|+|5-3| = 3，并且各路段的高度为一个不下降序列 1,2,2,4,5,5,9。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>方程 $f_{i,j}=min( f_{i,j-1}, f_{i-1,j}+ \left | a_i - b_j \right | ) $<br>不知道为什么只正向能过</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;int a[2005], n, size;int f[2005][2005];int Hash[2005];inline void Hash_init(){    sort(Hash + 1, Hash + n + 1);    size = unique(Hash + 1, Hash + n + 1) - Hash - 1;}int main(){    // freopen(&quot;grading.in&quot;,&quot;r&quot;,stdin);    // freopen(&quot;grading.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%d\n&quot;, &amp;n);    for (int i = 1; i &lt;= n; i++)    {        scanf(&quot;%d&quot;, &amp;a[i]);        Hash[i] = a[i];    }    Hash_init();    int minn = 0x3f3f3f3f;    for (int i = 1; i &lt;= n; i++)    {           minn = 0x3f3f3f3f;        for (int j = 1; j &lt;= size; j++)        {            minn = min(minn, f[i - 1][j]);            f[i][j] = minn +abs(Hash[j] - a[i]);        }    }    int ans = 0x3f3f3f3f;    for (int i = 1; i &lt;= size; i++)        ans = min(ans, f[n][i]);    memset(f,0,sizeof(f));    // for (int i = n; i &gt;= 1; i++)    // {       //     minn = 0x3f3f3f3f;    //     for (int j = 1; j &lt;= size; j++)    //     {    //         minn = min(minn, f[i + 1][j]);    //         f[i][j] = minn +abs(Hash[j] - a[i]);    //     }    // }    // for (int i = 1; i &lt;= size; i++)    //     ans = min(ans, f[1][i]);    printf(&quot;%d\n&quot;, ans);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/03/61/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[BZOJ 4832] [Lydsy2017年4月月赛]抵制克苏恩</title>
      <link>https://blog.wildrage.xyz/2017/08/03/59/</link>
      <guid>https://blog.wildrage.xyz/2017/08/03/59/</guid>
      <pubDate>Thu, 03 Aug 2017 00:14:26 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;小Q同学现在沉迷炉石传说不能自拔。他发现一张名为克苏恩的牌很不公平。如果你不玩炉石传说，不必担心，小Q&lt;br&gt;同学会告诉你所有相关的细节。炉石传说是这样的一个游戏，每个玩家拥有一个 30 点血量的英雄，并且可以用牌&lt;br&gt;召唤至多 7 个随从帮助玩家攻击对手，其中每个随从也拥有自己的血量和攻击力。小Q同学有很多次游戏失败都是&lt;br&gt;因为对手使用了克苏恩这张牌，所以他想找到一些方法来抵御克苏恩。他去求助职业炉石传说玩家椎名真白，真白&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>小Q同学现在沉迷炉石传说不能自拔。他发现一张名为克苏恩的牌很不公平。如果你不玩炉石传说，不必担心，小Q<br>同学会告诉你所有相关的细节。炉石传说是这样的一个游戏，每个玩家拥有一个 30 点血量的英雄，并且可以用牌<br>召唤至多 7 个随从帮助玩家攻击对手，其中每个随从也拥有自己的血量和攻击力。小Q同学有很多次游戏失败都是<br>因为对手使用了克苏恩这张牌，所以他想找到一些方法来抵御克苏恩。他去求助职业炉石传说玩家椎名真白，真白<br><a id="more"></a><br>告诉他使用奴隶主这张牌就可以啦。如果你不明白我上面在说什么，不必担心，小Q同学会告诉你他想让你做什么<br>。现在小Q同学会给出克苏恩的攻击力是 K ，表示克苏恩会攻击 K 次，每次会从对方场上的英雄和随从中随机选<br>择一个并对其产生 1 点伤害。现在对方有一名克苏恩，你有一些奴隶主作为随从，每名奴隶主的血量是给定的。<br>如果克苏恩攻击了你的一名奴隶主，那么这名奴隶主的血量会减少 1 点，当其血量小于等于 0 时会死亡，如果受<br>到攻击后不死亡，并且你的随从数量没有达到 7 ，这名奴隶主会召唤一个拥有 3 点血量的新奴隶主作为你的随从<br>；如果克苏恩攻击了你的英雄，你的英雄会记录受到 1 点伤害。你应该注意到了，每当克苏恩进行一次攻击，你<br>场上的随从可能发生很大的变化。小Q同学为你假设了克苏恩的攻击力，你场上分别有 1 点、 2 点、 3 点血量的<br>奴隶主数量，你可以计算出你的英雄受到的总伤害的期望值是多少吗？</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入包含多局游戏。<br>第一行包含一个整数 T (T&lt;100) ，表示游戏的局数。<br>每局游戏仅占一行，包含四个非负整数 K, A, B 和 C ，表示克苏恩的攻击力是 K ，你有 A 个 1 点血量的奴隶<br>主， B 个 2 点血量的奴隶主， C 个 3 点血量的奴隶主。<br>保证 K 是小于 50 的正数， A+B+C 不超过 7 。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每局游戏，输出一个数字表示总伤害的期望值，保留两位小数。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>1<br>1 1 1 1  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>0.25</p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>简单的基础概率DP</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;double f[55][8][8][8];int main(int argc, char const *argv[]){    int T, a, b, c, k;    scanf(&quot;%d&quot;, &amp;T);    while (T--)    {        scanf(&quot;%d%d%d%d&quot;, &amp;k, &amp;a, &amp;b, &amp;c);        memset(f, 0, sizeof(f));        f[1][a][b][c] = 1;        double ans = 0;        for (int i = 1; i &lt;= k; i++)        {            for (int j = 0; j &lt;= 7; j++)                for (int l = 0; l &lt;= 7; l++)                    for (int m = 0; m &lt;= 7; m++)                    {                        if (l + j + m &lt;= 7)                        {                            if (j &gt; 0)                                f[i + 1][j - 1][l][m] += f[i][j][l][m] * j * 1.0 / (l + j + m + 1);                            if (l &gt; 0)                            {                                if (l + j + m &lt;= 6)                                    f[i + 1][j + 1][l - 1][m + 1] += f[i][j][l][m] * l * 1.0 / (l + j + m + 1);                                else                                    f[i + 1][j + 1][l - 1][m] += f[i][j][l][m] * l * 1.0 / (l + j + m + 1);                            }                            if (m &gt; 0)                            {                                if (l + j + m &lt;= 6)                                    f[i + 1][j][l + 1][m] += f[i][j][l][m] * m * 1.0 / (l + j + m + 1);                                else                                    f[i + 1][j][l + 1][m - 1] += f[i][j][l][m] * m * 1.0 / (l + j + m + 1);                            }                            f[i + 1][j][l][m] += f[i][j][l][m] * 1.0 / (l + j + m + 1);                            ans += f[i][j][l][m] * 1.0 / (l + j + m + 1);                        }                    }        }        printf(&quot;%.2lf\n&quot;, ans);    }    //while (1)        ;    return 0;}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/03/59/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[BZOJ 3829][POI2014] FarmCraft</title>
      <link>https://blog.wildrage.xyz/2017/08/03/60/</link>
      <guid>https://blog.wildrage.xyz/2017/08/03/60/</guid>
      <pubDate>Thu, 03 Aug 2017 00:14:26 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;In a village called Byteville, there are   houses connected with N-1 roads. For each pair of houses, there is a unique way to get from one to another. The houses are numbered from 1 to  . The house no. 1 belongs to the village administrator Byteasar. As part of enabling modern technologies for rural areas framework,   computers have been delivered to Byteasar’s house. Every house is to be supplied with a computer, and it is Byteasar’s task to distribute them. The citizens of Byteville have already agreed to play the most recent version of FarmCraft (the game) as soon as they have their computers.&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>In a village called Byteville, there are   houses connected with N-1 roads. For each pair of houses, there is a unique way to get from one to another. The houses are numbered from 1 to  . The house no. 1 belongs to the village administrator Byteasar. As part of enabling modern technologies for rural areas framework,   computers have been delivered to Byteasar’s house. Every house is to be supplied with a computer, and it is Byteasar’s task to distribute them. The citizens of Byteville have already agreed to play the most recent version of FarmCraft (the game) as soon as they have their computers.<br><a id="more"></a><br>Byteasar has loaded all the computers on his pickup truck and is about to set out to deliver the goods. He has just the right amount of gasoline to drive each road twice. In each house, Byteasar leaves one computer, and immediately continues on his route. In each house, as soon as house dwellers get their computer, they turn it on and install FarmCraft. The time it takes to install and set up the game very much depends on one’s tech savviness, which is fortunately known for each household. After he delivers all the computers, Byteasar will come back to his house and install the game on his computer. The travel time along each road linking two houses is exactly 1 minute, and (due to citizens’ eagerness to play) the time to unload a computer is negligible.<br>Help Byteasar in determining a delivery order that allows all Byteville’s citizens (including Byteasar) to start playing together as soon as possible. In other words, find an order that minimizes the time when everyone has FarmCraft installed.<br>mhy住在一棵有n个点的树的1号结点上，每个结点上都有一个妹子。<br>mhy从自己家出发，去给每一个妹子都送一台电脑，每个妹子拿到电脑后就会开始安装zhx牌杀毒软件，第i个妹子安装时间为Ci。<br>树上的每条边mhy能且仅能走两次，每次耗费1单位时间。mhy送完所有电脑后会回自己家里然后开始装zhx牌杀毒软件。<br>卸货和装电脑是不需要时间的。<br>求所有妹子和mhy都装好zhx牌杀毒软件的最短时间。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the standard input contains a single integer N(2&lt;=N&lt;=5 00 000)  that gives the number of houses in Byteville. The second line contains N integers C1,C2…Cn(1&lt;=Ci&lt;=10^9), separated by single spaces; Ci is the installation time (in minutes) for the dwellers of house no. i.<br>The next N-1  lines specify the roads linking the houses. Each such line contains two positive integers a and b(1&lt;=a&lt;b&lt;=N) , separated by a single space. These indicate that there is a direct road between the houses no. a and b.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>The first and only line of the standard output should contain a single integer: the (minimum) number of minutes after which all citizens will be able to play FarmCraft together.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>6<br>1 8 9 6 3 2<br>1 3<br>2 3<br>3 4<br>4 5<br>4 6  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>11  </p></blockquote><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>Explanation: Byteasar should deliver the computers to the houses in the following order: 3, 2, 4, 5, 6, and 1. The game will be installed after 11, 10, 10, 10, 8, and 9 minutes respectively, in the house number order. Thus everyone can play after 11 minutes.</p><p>If Byteasar delivered the game in the following order: 3, 4, 5, 6, 2, and 1, then the game would be installed after: 11, 16, 10, 8, 6, and 7 minutes respectively. Hence, everyone could play only after 16 minutes,</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>直接搞<br>记录一个值为总时间减遍历时间  </p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;functional&gt;using namespace std;struct edge{    int END, next;} v[1000005];int w[500005], first[500005], p;void add(int a, int b){    v[p].END = b;    v[p].next = first[a];    first[a] = p++;}int f[500005];int dfs(int x, int fa){    int t = 0;    for (int i = first[x]; i != -1; i = v[i].next)    {        if (v[i].END != fa)        {            f[v[i].END] = dfs(v[i].END, x);            t += f[v[i].END] + 2;        }    }    return t;}int t[500005];int comp(const int &amp;a, const int &amp;b){    return t[a] &gt; t[b];}void DP(int x, int fa){    vector&lt;int&gt; re;    for (int i = first[x]; i != -1; i = v[i].next)        if (v[i].END != fa)        {            DP(v[i].END, x);            re.push_back(v[i].END);        }    sort(re.begin(), re.end(), comp);    if (x != 1)        t[x] = w[x] - f[x];    int now = f[x];    for (int i = 0; i &lt; re.size(); i++)    {        now -= (f[re[i]] + 2);        t[x] = max(t[x], t[re[i]] - now - 1);    }    t[x] = max(t[x], 0);}int main(){    freopen(&quot;farmcraft.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;farmcraft.out&quot;, &quot;w&quot;, stdout);    //memset(f, -1, sizeof(f));    memset(first, -1, sizeof(first));    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i++)    {        scanf(&quot;%d&quot;, &amp;w[i]);    }    int a, b;    for (int i = 1; i &lt; n; i++)    {        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);        add(a, b);        add(b, a);    }    f[1] = dfs(1, 0);    //for (int i = 1; i &lt;= n; i++)    // printf(&quot;%d &quot;, f[i]);    //printf(&quot;\n======================\n&quot;);    DP(1, 0);    //while(1);    printf(&quot;%d\n&quot;, f[1] + max(w[1], t[1]));}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/03/60/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[NOIP2015] 斗地主</title>
      <link>https://blog.wildrage.xyz/2017/08/02/58/</link>
      <guid>https://blog.wildrage.xyz/2017/08/02/58/</guid>
      <pubDate>Wed, 02 Aug 2017 23:45:19 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;牛牛最近迷上了一种叫斗地主的扑克游戏。斗地主是一种使用黑桃、红心、梅花、方片的A到K加上大小王的共54张牌来进行的扑克牌游戏。在斗地主中，牌的大小关系根据牌的数码表示如下：3\&amp;lt;4\&amp;lt;5\&amp;lt;6\&amp;lt;7\&amp;lt;8\&amp;lt;9\&amp;lt;10\&amp;lt;J\&amp;lt;Q\&amp;lt;K\&amp;lt;A\&amp;lt;2\&amp;lt;小王\&amp;lt;大王，而花色并不对牌的大小产生影响。每一局游戏中，一副手牌由n张牌组成。游戏者每次可以根据规定的牌型进行出牌，首先打光自己的手牌一方取得游戏的胜利。现在，牛牛只想知道，对于自己的若干组手牌，分别最少需要多少次出牌可以将它们打光。请你帮他解决这个问题。需要注意的是，本题中游戏者每次可以出手的牌型与一般的斗地主相似而略有不同。具体规则如下： &lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>牛牛最近迷上了一种叫斗地主的扑克游戏。斗地主是一种使用黑桃、红心、梅花、方片的A到K加上大小王的共54张牌来进行的扑克牌游戏。在斗地主中，牌的大小关系根据牌的数码表示如下：3\&lt;4\&lt;5\&lt;6\&lt;7\&lt;8\&lt;9\&lt;10\&lt;J\&lt;Q\&lt;K\&lt;A\&lt;2\&lt;小王\&lt;大王，而花色并不对牌的大小产生影响。每一局游戏中，一副手牌由n张牌组成。游戏者每次可以根据规定的牌型进行出牌，首先打光自己的手牌一方取得游戏的胜利。现在，牛牛只想知道，对于自己的若干组手牌，分别最少需要多少次出牌可以将它们打光。请你帮他解决这个问题。需要注意的是，本题中游戏者每次可以出手的牌型与一般的斗地主相似而略有不同。具体规则如下： </p><a id="more"></a><p><img src="https://moetu.fastmirror.org/images/2017/08/03/11.PNG_7260344acb43.png" alt="11.PNG_7260344acb43.png"></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含用空格隔开的2个正整数T,N，表示手牌的组数以及每组手牌的张数。</p><p>接下来T组数据，每组数据N行，每行一个非负整数对Ai,Bi，表示一张牌，其中Ai表示牌的数码,Bi表示牌的花色，中间用空格隔开。特别的，我们用1来表示数码A，11表示数码J，12表示数码Q，13表示数码K；黑桃、红心、梅花、方片分别用1-4来表示；小王的表示方法为01，大王的表示方法为02。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>共T行，每行一个整数，表示打光第T组手牌的最少次数。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>1 8<br>7 4<br>8 4<br>9 1<br>10 4<br>11 1<br>5 1<br>1 4<br>1 1  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>3  </p></blockquote><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>共有1组手牌，包含8张牌：方片7，方片8，黑桃9，方片10，黑桃J，黑桃5，方片A以及黑桃A。可以通过打单顺子（方片7，方片8，黑桃9，方片10，黑桃J），单张牌（黑桃5）以及对子牌（黑桃A以及方片A）在3次内打光。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>搜吧  </p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;struct data{    int t, l, r;};int cnt[16];int backcnt[16];vector&lt;data&gt; s;int times[5];int Query(){    memcpy(backcnt, cnt, sizeof(backcnt));    memset(times, 0, sizeof(times));    // int ans = s.size();    // for (int i = 0; i &lt; s.size(); i++)    // {    //     for (int j = s[i].l; j &lt;= s[i].r; j++)    //         backcnt[j] -= s[i].t;    // }    int ans = 0;    for (int i = 1; i &lt;= 14; i++)    {        times[backcnt[i]]++;    }    while (times[4] &gt; 0 &amp;&amp; times[2] &gt; 1)    {        times[4]--;        times[2] -= 2;        ans++;    }    while (times[4] &gt; 0 &amp;&amp; times[1] &gt; 1)    {        times[4]--;        times[1] -= 2;        ans++;    }    while (times[4] &gt; 0 &amp;&amp; times[2] &gt; 0)    {        times[4]--;        times[2]--;        ans++;    }    while (times[3] &gt; 0 &amp;&amp; times[2] &gt; 0)    {        times[3]--;        times[2]--;        ans++;    }    while (times[3] &gt; 0 &amp;&amp; times[1] &gt; 0)    {        times[3]--;        times[1]--;        ans++;    }    while (times[4] &gt; 0)    {        times[4]--;        ans++;    }    while (times[3] &gt; 0)    {        times[3]--;        ans++;    }    while (times[2] &gt; 0)    {        times[2]--;        ans++;    }    while (times[1] &gt; 0)    {        times[1]--;        ans++;    }    return ans;}int DFS(){    //int ans = 0x3f3f3f3f;    int ans = Query();    for (int i = 1; i &lt;= 12; i++)    {        if (cnt[i])        {            for (int j = i + 1; j &lt;= 12; j++)            {                if (!cnt[j])                    break;                if (j - i + 1 &gt;= 5)                {                    //s.push_back((data){1, i, j});                    for (int k = i; k &lt;= j; k++)                        cnt[k] -= 1;                    ans = min(ans, DFS()+1);                    for (int k = i; k &lt;= j; k++)                        cnt[k] += 1;                    //ans = min(ans, Query(1));                    //s.pop_back();                }            }        }        if (cnt[i] &gt;= 2)        {            for (int j = i + 1; j &lt;= 12; j++)            {                if (cnt[j] &lt; 2)                    break;                if (j - i + 1 &gt;= 3)                {                    for (int k = i; k &lt;= j; k++)                        cnt[k] -= 2;                    ans = min(ans, DFS()+1);                    for (int k = i; k &lt;= j; k++)                        cnt[k] += 2;                    // s.push_back((data){2, i, j});                    // ans = min(ans, DFS(j + 1));                    // ans = min(ans, Query(1));                    // s.pop_back();                }            }        }        if (cnt[i] &gt;= 3)        {            for (int j = i + 1; j &lt;= 12; j++)            {                if (cnt[j] &lt; 3)                    break;                if (j - i + 1 &gt;= 2)                {                    for (int k = i; k &lt;= j; k++)                        cnt[k] -= 3;                    ans = min(ans, DFS()+1);                    for (int k = i; k &lt;= j; k++)                        cnt[k] += 3;                    // s.push_back((data){3, i, j});                    // ans = min(ans, DFS(j + 1));                    // ans = min(ans, Query(1));                    // s.pop_back();                }            }        }    }    //ans = min(ans, Query(1));    return ans;}int main(int argc, char const *argv[]){    freopen(&quot;landlords.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;landlords.out&quot;, &quot;w&quot;, stdout);    int T, n;    //int C = 1;    scanf(&quot;%d%d&quot;, &amp;T, &amp;n);    while (T--)    {        int a, b;        memset(cnt, 0, sizeof(cnt));        for (int i = 1; i &lt;= n; i++)        {            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);            if (a)                if ((a + 11) % 13)                    cnt[(a + 11) % 13]++;                else                    cnt[13]++;            else                cnt[14]++;        }        s.clear();        printf(&quot;%d\n&quot;, DFS());    }    return 0;}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/02/58/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[BZOJ 1409] Password</title>
      <link>https://blog.wildrage.xyz/2017/08/02/57/</link>
      <guid>https://blog.wildrage.xyz/2017/08/02/57/</guid>
      <pubDate>Wed, 02 Aug 2017 22:24:05 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;Rivest是密码学专家。近日他正在研究一种数列E = {E[1],E[2],……,E[n]}，&lt;br&gt;且E[1] = E[2] = p（p为一个质数），E[i] = E[i-2]*E[i-1] （若2&amp;lt;i&amp;lt;=n）。  &lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Rivest是密码学专家。近日他正在研究一种数列E = {E[1],E[2],……,E[n]}，<br>且E[1] = E[2] = p（p为一个质数），E[i] = E[i-2]*E[i-1] （若2&lt;i&lt;=n）。  </p><a id="more"></a><p>例如{2,2,4,8,32,256,8192,……}就是p = 2的数列。在此基础上他又设计了一种加密算法，该算法可以通过一个密钥q (q &lt; p)将一个正整数n加密成另外一个正整数d，计算公式为：d = E[n] mod q。现在Rivest想对一组数据进行加密，但他对程序设计不太感兴趣，请你帮助他设计一个数据加密程序。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行读入m，p。其中m表示数据个数，p用来生成数列E。 以下有m行，每行有2个整数n，q。n为待加密数据，q为密钥。 数据范围: 0 &lt; p n&lt; 2^31 0 &lt; q &lt; p 0 &lt; m &lt;= 5000。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>将加密后的数据按顺序输出到文件 第i行输出第i个加密后的数据。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>输入样例1<br>2 7<br>4 5<br>4 6<br>输入样例2<br>4 7<br>2 4<br>7 1<br>6 5<br>9 3  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>输出样例1<br>3<br>1<br>输出样例2<br>3<br>0<br>1<br>1  </p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>设斐波那契数列的第i项为$F(i)$<br><a href="https://oeis.org/A000045" target="_blank" rel="noopener">斐波那契数列</a><br>可以发现$E[i]=p^F(i)$<br>所以我们的任务变为了求$F(i)$然后矩阵快速幂<br>$$<br>    \begin{bmatrix}<br>    1 &amp; 1 \\<br>    1 &amp; 0 \\<br>    \end{bmatrix}<br>$$<br>最后乘上$ \begin{bmatrix} 1 \\ 1 \\ \end{bmatrix} $ 就可以了</p><p>然后由出现了一个问题<br>我们需要取膜（雾）<br>要知道 $ a^b%p!=a^{b%p}%p $<br>所以我们需要欧拉定理<br>$$ a^{\phi{n}} \equiv 1 (mod n) $$<br>然后易得<br>$$ a^{b\%\phi{p}} \equiv a^b (mod p) $$<br>使用条件是 a与p 互质  </p><p>然后就可以了筛出素数<br>$ \sqrt{n} $求$\phi{n}$就行了   </p><pre><code class="c++">#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;bool isnprime[1000005];int prime[200005], Idx;void Get_Prime(){    isnprime[1] = 1;    for (int i = 2; i &lt;= 1000000; i++)    {        if (!isnprime[i])        {            prime[++Idx] = i;        }        for (int j = 1; j &lt;= Idx; j++)        {            if (prime[j] * i &gt; 1000000)                break;            isnprime[i * prime[j]] = 1;            if (i % prime[j] == 0)                break;        }    }}long long Get_Phi(long long x){    if (x == 1)        return 0;    int i = 1;    int Sq = sqrt(x);    long long ans = x;    while (x != 1)    {        if (prime[i] &gt; Sq)        {            ans = ans - ans / x;            break;        }        if (x % prime[i] == 0)        {            ans = ans - ans / prime[i];            while (x % prime[i] == 0)                x /= prime[i];        }        ++i;    }    return ans;}long long phi;class Matrix{  public:    int n, m;    long long a[3][3];    Matrix(int n1, int m1)    {        n = n1, m = m1;        memset(a, 0, sizeof(a));    }    Matrix operator*(const Matrix &amp;A)    {        Matrix ans(n, A.m);        for (int i = 1; i &lt;= n; i++)            for (int k = 1; k &lt;= A.m; k++)            {                for (int j = 1; j &lt;= m; j++)                    ans.a[i][k] += a[i][j] * A.a[j][k];                if (ans.a[i][k] &gt;= phi)                    ans.a[i][k] = ans.a[i][k] % phi/* + phi*/;            }        return ans;    }    Matrix operator^(const long long &amp;b)    {        long long k = b;        Matrix ans(n, m);        for (int i = 1; i &lt;= n; i++)        {            ans.a[i][i] = 1;        }        Matrix A = *this;        while (k)        {            if (k &amp; 1)                ans = ans * A;            k &gt;&gt;= 1;            A = A * A;        }        return ans;    }};long long pow_mod(long long a, long long b, long long mod){    long long ans = 1;    while (b)    {        if (b &amp; 1)            ans = ans * a % mod;        b &gt;&gt;= 1;        a = a * a % mod;    }    return ans;}int main(){    freopen(&quot;password.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;password.out&quot;, &quot;w&quot;, stdout);    long long m, p;    Get_Prime();    Matrix O(2, 2);    O.a[1][1] = O.a[1][2] = O.a[2][1] = 1;    Matrix L(2, 1);    L.a[1][1] = 1;    scanf(&quot;%lld%lld&quot;, &amp;m, &amp;p);    while (m--)    {        long long n, q;        scanf(&quot;%lld%lld&quot;, &amp;n, &amp;q);        if (q == 1)        {            printf(&quot;0\n&quot;);            continue;        }        int t = p - q;        if (t == 1)        {            printf(&quot;1\n&quot;);            continue;        }        phi = Get_Phi(q);        printf(&quot;%lld\n&quot;, pow_mod(p, ((O ^ n) * L).a[2][1], q));    }}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/02/57/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 2588 [Spoj 10628] Count on a tree</title>
      <link>https://blog.wildrage.xyz/2017/08/02/56/</link>
      <guid>https://blog.wildrage.xyz/2017/08/02/56/</guid>
      <pubDate>Wed, 02 Aug 2017 22:24:05 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;给定一棵N个节点的树，每个点有一个权值，对于M个询问(u,v,k)，你需要回答u xor lastans和v这两个节点间第K小的点权。其中lastans是上一个询问的答案，初始为0，即第一个询问的u是明文。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给定一棵N个节点的树，每个点有一个权值，对于M个询问(u,v,k)，你需要回答u xor lastans和v这两个节点间第K小的点权。其中lastans是上一个询问的答案，初始为0，即第一个询问的u是明文。<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行两个整数N,M。<br>第二行有N个整数，其中第i个整数表示点i的权值。<br>后面N-1行每行两个整数(x,y)，表示点x到点y有一条边。<br>最后M行每行两个整数(u,v,k)，表示一组询问。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>M行，表示每个询问的答案。最后一个询问不输出换行符</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>8 5<br>105 2 9 3 8 5 7 7<br>1 2<br>1 3<br>1 4<br>3 5<br>3 6<br>3 7<br>4 8<br>2 5 1<br>0 5 2<br>10 5 3<br>11 5 4<br>110 8 2  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>2<br>8<br>9<br>105<br>7  </p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>简单来说可以每个节点复制他父亲的节点在新版本中插入自己<br>然后两个点之间的k小值就是a-lca + b-fa[lca];</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;using namespace std;struct Seg_Node *null;struct Seg_Node{    Seg_Node *ch[2];    int cnt;    //#define cnt(_) ((_) ? (_)-&gt;cnt : 0)    Seg_Node(Seg_Node *l, Seg_Node *r)    {        ch[0] = l, ch[1] = r;        cnt = ch[0]-&gt;cnt + ch[1]-&gt;cnt;    }    Seg_Node(Seg_Node *l, Seg_Node *r, int _cnt)    {        ch[0] = l, ch[1] = r;        cnt = _cnt;    }    Seg_Node *insert(int l, int r, int x)    {        if (l == r)            return new Seg_Node(null, null, cnt + 1);        else        {            int m = l + (r - l) / 2;            if (x &lt;= m)                return new Seg_Node(ch[0]-&gt;insert(l, m, x), ch[1]);            else                return new Seg_Node(ch[0], ch[1]-&gt;insert(m + 1, r, x));        }    }};struct Node{    vector&lt;Node *&gt; ch;    Node *fa;    int dep, w;    bool vis;    Seg_Node *Seg;} v[100005];void addedge(int a, int b){    v[a].ch.push_back(&amp;v[b]);    v[b].ch.push_back(&amp;v[a]);}void init(){    null = new Seg_Node(NULL, NULL, 0);    null-&gt;ch[0] = null-&gt;ch[1] = null;}int n, f[100005][20], logn;void build(){    v[0].vis = 1;    v[0].Seg = null;    queue&lt;Node *&gt; Q;    Q.push(&amp;v[1]);    v[1].vis = 1;    v[1].dep = 1;    v[1].fa = &amp;v[0];    while (!Q.empty())    {        Node *e = Q.front();        Q.pop();        e-&gt;Seg = e-&gt;fa-&gt;Seg-&gt;insert(0, INT_MAX, e-&gt;w);        for (Node **p = &amp;e-&gt;ch.front(), *u = *p; p &lt;= &amp;e-&gt;ch.back(); u = *++p)        {            if (!u-&gt;vis)            {                u-&gt;vis = 1;                u-&gt;dep = e-&gt;dep + 1;                u-&gt;fa = e;                Q.push(u);            }        }    }    while ((1 &lt;&lt; (logn + 1)) &lt;= n)        logn++;    f[1][0] = 1;    for (int i = 2; i &lt;= n; i++)        f[i][0] = v[i].fa - v;    for (int j = 1; j &lt;= logn; j++)    {        for (int i = 1; i &lt;= n; i++)        {            f[i][j] = f[f[i][j - 1]][j - 1];        }    }}int lca(int s, int e){    if (v[s].dep &lt; v[e].dep)        swap(s, e);    if (v[s].dep &gt; v[e].dep)    {        for (int i = logn; i &gt;= 0; i--)        {            if (v[f[s][i]].dep &gt;= v[e].dep)                s = f[s][i];        }    }    if (s != e)    {        for (int i = logn; i &gt;= 0; i--)        {            if (f[s][i] != f[e][i])            {                s = f[s][i];                e = f[e][i];            }        }        return f[s][0];    }    return s;}int Query(int s, int e, int k){    int p = lca(s, e);    Seg_Node *Su = v[s].Seg, *Sv = v[e].Seg, *Sp = v[p].Seg, *Sf = v[p].fa-&gt;Seg;    int l = 0, r = INT_MAX;    while (l &lt; r)    {        int m = l + (r - l) / 2;        int S = Su-&gt;ch[0]-&gt;cnt + Sv-&gt;ch[0]-&gt;cnt - Sp-&gt;ch[0]-&gt;cnt - Sf-&gt;ch[0]-&gt;cnt;        if (k &gt; S)        {            k -= S;            l = m + 1;            Su = Su-&gt;ch[1];            Sv = Sv-&gt;ch[1];            Sp = Sp-&gt;ch[1];            Sf = Sf-&gt;ch[1];        }        else        {            r = m;            Su = Su-&gt;ch[0];            Sv = Sv-&gt;ch[0];            Sp = Sp-&gt;ch[0];            Sf = Sf-&gt;ch[0];        }    }    return l;}int main(){    int m;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i++)        scanf(&quot;%d&quot;, &amp;v[i].w);    for (int i = 1; i &lt;= n - 1; i++)    {        int s, e;        scanf(&quot;%d%d&quot;, &amp;s, &amp;e);        addedge(s, e);    }    init();    build();    int ans = 0;    while (m--)    {        int s, e, k;        scanf(&quot;%d%d%d&quot;, &amp;s, &amp;e, &amp;k);        s ^= ans;        printf(m ? &quot;%d\n&quot; : &quot;%d&quot;, ans = Query(s, e, k));    }}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/02/56/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 1901 [Zju2112] Dynamic Rankings</title>
      <link>https://blog.wildrage.xyz/2017/08/02/55/</link>
      <guid>https://blog.wildrage.xyz/2017/08/02/55/</guid>
      <pubDate>Wed, 02 Aug 2017 21:38:04 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;给定一个含有n个数的序列a[1],a[2],a[3]……a[n]，程序必须回答这样的询问：对于给定的i,j,k，在a[i],a[i+1&lt;br&gt;],a[i+2]……a[j]中第k小的数是多少(1≤k≤j-i+1)，并且，你可以改变一些a[i]的值，改变后，程序还能针对改&lt;br&gt;变后的a继续回答上面的问题。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给定一个含有n个数的序列a[1],a[2],a[3]……a[n]，程序必须回答这样的询问：对于给定的i,j,k，在a[i],a[i+1<br>],a[i+2]……a[j]中第k小的数是多少(1≤k≤j-i+1)，并且，你可以改变一些a[i]的值，改变后，程序还能针对改<br>变后的a继续回答上面的问题。<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行一个数字N，代表测试组数<br>对于每组数据第一行有两个正整数n(1≤n≤10000)，m(1≤m≤10000)。<br>分别表示序列的长度和指令的个数。<br>第二行有n个数，表示a[1],a[2]……a[n]，这些数都小于10^9。<br>接下来的m行描述每条指令<br>每行的格式是下面两种格式中的一种。<br>Q i j k 或者 C i t<br>Q i j k （i,j,k是数字，1≤i≤j≤n, 1≤k≤j-i+1）<br>表示询问指令，询问a[i]，a[i+1]……a[j]中第k小的数。<br>C i t (1≤i≤n，0≤t≤10^9)表示把a[i]改变成为t</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每一次询问，你都需要输出他的答案，每一个输出占单独的一行。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>1<br>5 3<br>3 2 1 4 7<br>Q 1 4 3<br>C 2 6<br>Q 2 5 3  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>3<br>6  </p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>简单的来说就是待修改的区间k小值  </p><p>我们用让线段树外面套一层树状数组就可以修改了  </p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;const int N = 1000000000;#define lowbit(_) ((_) &amp; (-_))struct Seg_Node{    Seg_Node *ch[2];    int sum, l, r;    Seg_Node(int L, int R)    {        sum = 0, l = L, r = R;        ch[1] = ch[0] = NULL;    }#define sum(_) ((_) ? (_)-&gt;sum : 0)    void Pushup()    {        sum = sum(ch[0]) + sum(ch[1]);    }} * root[50005];int a[50005];int n;void Insert(Seg_Node *rt, int num){    if (rt-&gt;l == rt-&gt;r)    {        rt-&gt;sum++;        return;    }    int m = rt-&gt;l + rt-&gt;r &gt;&gt; 1;    if (num &lt;= m)    {        if (!rt-&gt;ch[0])            rt-&gt;ch[0] = new Seg_Node(rt-&gt;l, m);        Insert(rt-&gt;ch[0], num);    }    else    {        if (!rt-&gt;ch[1])            rt-&gt;ch[1] = new Seg_Node(m + 1, rt-&gt;r);        Insert(rt-&gt;ch[1], num);    }    rt-&gt;Pushup();}void Insert(int x, int num){    for (int i = x; i &lt;= n; i += lowbit(i))    {        if (root[i] == NULL)            root[i] = new Seg_Node(0, N);        Insert(root[i], num);    }}void Delete(Seg_Node *&amp;rt, int num){    if (rt-&gt;l == rt-&gt;r)    {        rt-&gt;sum--;        if (!rt-&gt;sum)            delete rt, rt = NULL;        return;    }    int m = rt-&gt;l + rt-&gt;r &gt;&gt; 1;    if (num &lt;= m)        Delete(rt-&gt;ch[0], num);    else        Delete(rt-&gt;ch[1], num);    rt-&gt;Pushup();    if (!rt-&gt;sum)        delete rt, rt = NULL;}void Delete(int x, int num){    for (int i = x; i &lt;= n; i += lowbit(i))    {        Delete(root[i], num);    }}vector&lt;Seg_Node *&gt; Get(int x){    vector&lt;Seg_Node *&gt; ans;    for (int i = x; i &gt; 0; i -= lowbit(i))    {        ans.push_back(root[i]);    }    return ans;}vector&lt;Seg_Node *&gt; Get_ch(vector&lt;Seg_Node *&gt; x, int op){    for (int i=0;i&lt;x.size();i++)        if (x[i])            x[i] = x[i]-&gt;ch[op];    return x;}int Query(vector&lt;Seg_Node *&gt; list1, vector&lt;Seg_Node *&gt; list2, int l, int r, int k){    if (l == r)        return l;    int ans = 0;    for (int i=0;i&lt;list2.size();i++)        if (list2[i])            ans += sum(list2[i]-&gt;ch[0]);    for (int i=0;i&lt;list1.size();i++)        if (list1[i])            ans -= sum(list1[i]-&gt;ch[0]);    int m = l + r &gt;&gt; 1;    if (ans &gt;= k)        return Query(Get_ch(list1, 0), Get_ch(list2, 0), l, m, k);    else        return Query(Get_ch(list1, 1), Get_ch(list2, 1), m + 1, r, k - ans);}void DFS(Seg_Node *&amp;rt){    if (rt)    {        DFS(rt-&gt;ch[0]);        DFS(rt-&gt;ch[1]);        delete rt;        rt=NULL;    }}void remove(){    for (int i = 1; i &lt;= n; i++)    {        DFS(root[i]);    }}int main(int argc, char const *argv[]){    //freopen(&quot;dynrank.in&quot;,&quot;r&quot;,stdin);    //freopen(&quot;dynrank.out&quot;,&quot;w&quot;,stdout);    //int T;    //scanf(&quot;%d&quot;, &amp;T);    //while (T--)    //{        int m;        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        //memset(a,0,sizeof(a));        for (int i = 1; i &lt;= n; i++)        {            scanf(&quot;%d&quot;, &amp;a[i]);            Insert(i, a[i]);        }        //sort(a + 1, a + n + 1);        char op[3];        int p, b, c;        for (int i = 1; i &lt;= m; i++)        {            scanf(&quot;%s&quot;, op);            if (op[0] == &#39;Q&#39;)            {                scanf(&quot;%d%d%d&quot;, &amp;p, &amp;b, &amp;c);                printf(&quot;%d\n&quot;, Query(Get(p - 1), Get(b), 0, N, c));            }            else            {                scanf(&quot;%d%d&quot;, &amp;p, &amp;b);                Delete(p, a[p]);                Insert(p, b);                a[p] = b;            }        }        remove(); //   }    return 0;}</code></pre><h2 id="树套树"><a href="#树套树" class="headerlink" title="树套树"></a>树套树</h2><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int a[50005], n;class Treap{    class Node    {      public:        int size, v, key;        Node *ch[2];        Node(int x)        {            key = rand();            v = x;            size = 1;            ch[0] = ch[1] = NULL;        }#define size(_) ((_) ? (_)-&gt;size : 0)        void Pushup()        {            size = size(ch[0]) + size(ch[1]) + 1;        }    } * root;    Node *Merge(Node *A, Node *B)    {        if (!A)            return B;        if (!B)            return A;        if (A-&gt;key &gt; B-&gt;key)        {            A-&gt;ch[1] = Merge(A-&gt;ch[1], B);            A-&gt;Pushup();            return A;        }        else        {            B-&gt;ch[0] = Merge(A, B-&gt;ch[0]);            B-&gt;Pushup();            return B;        }    }    typedef pair&lt;Node *, Node *&gt; DNode;    DNode Split(Node *rt, int k)    {        if (!rt)            return DNode(NULL, NULL);        DNode o;        if (size(rt-&gt;ch[0]) &gt;= k)        {            o = Split(rt-&gt;ch[0], k);            rt-&gt;ch[0] = o.second;            rt-&gt;Pushup();            o.second = rt;        }        else        {            o = Split(rt-&gt;ch[1], k - size(rt-&gt;ch[0]) - 1);            rt-&gt;ch[1] = o.first;            rt-&gt;Pushup();            o.first = rt;        }        return o;    }  public:    Treap()    {        root = NULL;    }    int kth(int k)    {        DNode x = Split(root, k - 1);        DNode y = Split(x.second, 1);        Node *ans = y.first;        root = Merge(x.first, Merge(y.first, y.second));        return ans-&gt;v;    }    int rank(int x)    {        return rank(root, x);    }    int rank(Node *rt, int x)    {        if (!rt)            return 0;        return x &lt;= rt-&gt;v ? rank(rt-&gt;ch[0], x) : rank(rt-&gt;ch[1], x) + size(rt-&gt;ch[0]) + 1;    }    void Insert(int x)    {        int k = rank(root, x);        DNode y = Split(root, k);        Node *n = new Node(x);        root = Merge(Merge(y.first, n), y.second);    }    void remove(int x)    {        int k = rank(root, x);        DNode a = Split(root, k);        DNode b = Split(a.second, 1);        root = Merge(a.first, b.second);    }} root[50005 &lt;&lt; 2];#define lch l, m, rt &lt;&lt; 1#define rch m + 1, r, rt &lt;&lt; 1 | 1void build(int l, int r, int rt){    for (int i = l; i &lt;= r; i++)        root[rt].Insert(a[i]);}void buildtree(int l, int r, int rt){    build(l, r, rt);    if (l == r)        return;    int m = l + r &gt;&gt; 1;    buildtree(lch);    buildtree(rch);}void updata(int k, int x, int y, int l, int r, int rt){    root[rt].remove(y);    root[rt].Insert(x);    if (l == r)        return;    int m = l + r &gt;&gt; 1;    if (k &lt;= m)        updata(k, x, y, lch);    else        updata(k, x, y, rch);}int rank(int L, int R, int x, int l, int r, int rt){    if (L &lt;= l &amp;&amp; R &gt;= r)        return root[rt].rank(x);    int m = l + r &gt;&gt; 1;    if (R &lt;= m)        return rank(L, R, x, lch);    if (L &gt; m)        return rank(L, R, x, rch);    return rank(L, R, x, lch) + rank(L, R, x, rch);}int kth(int L, int R, int k){    int l = -1e10, r = 1e10;    while (l &lt;= r)    {        int m = l + r &gt;&gt; 1;        int num = rank(L, R, m, 1, n, 1) + 1;        if (num &lt;= k)            l = m + 1;        else            r = m - 1;    }    return r;}int main(){    //freopen(&quot;dynrank.in&quot;, &quot;r&quot;, stdin);    //freopen(&quot;dynrank.out&quot;, &quot;w&quot;, stdout);    //int T;    //scanf(&quot;%d&quot;, &amp;T);    //while (T--)    //{    //    memset(root,0,sizeof(root));        int m;        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        for (int i = 1; i &lt;= n; i++)            scanf(&quot;%d&quot;, &amp;a[i]);        buildtree(1, n, 1);        char s[5];        int i, j, k, t;        while (m--)        {            scanf(&quot;%s&quot;, s);            if (s[0] == &#39;Q&#39;)            {                scanf(&quot;%d%d%d&quot;, &amp;i, &amp;j, &amp;k);                printf(&quot;%d\n&quot;, kth(i, j, k));            }            else            {                scanf(&quot;%d%d&quot;, &amp;i, &amp;t);                updata(i, t, a[i], 1, n, 1);                a[i] = t;            }        }    //}}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/02/55/#disqus_thread</comments>
    </item>
    
    <item>
      <title>COGS 930 [河南省队2012] 找第k小的数</title>
      <link>https://blog.wildrage.xyz/2017/08/02/54/</link>
      <guid>https://blog.wildrage.xyz/2017/08/02/54/</guid>
      <pubDate>Wed, 02 Aug 2017 13:45:43 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;简单题面&quot;&gt;&lt;a href=&quot;#简单题面&quot; class=&quot;headerlink&quot; title=&quot;简单题面&quot;&gt;&lt;/a&gt;简单题面&lt;/h2&gt;&lt;p&gt;求区间第k小&lt;/p&gt;
&lt;p&gt;COGS 1534 == 930 找第k小的数&lt;br&gt;本来是主席树或树套树的题&lt;br&gt;然而 可持久化Trie树 可以过&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="简单题面"><a href="#简单题面" class="headerlink" title="简单题面"></a>简单题面</h2><p>求区间第k小</p><p>COGS 1534 == 930 找第k小的数<br>本来是主席树或树套树的题<br>然而 可持久化Trie树 可以过<br><a id="more"></a><br>查了查好像用可持久化Trie做区间k小的人很少啊（我好像是没有查到）<br>事实上 可持久化Trie树 比较好打，代码很短。<br>本来想用 可持久化Treap 做区间k小的结果和 zzh 又调又改弄了一个晚上<br>结果发现是真的不能做啊，Treap 区间不可减 他会变化<br>然后想到了可持久化Trie 发现好像可行啊，然后就出来了。<br>跑的好像也很快比树套树和不离散的主席树快。</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int full = 21, fix = 1000001;struct Trie{    struct Trie_Node    {        Trie_Node *ch[2];        int s;        Trie_Node()        {            ch[0] = ch[1] = NULL;            s = 0;        }    } * root[100005],*null;    Trie()    {        null = new Trie_Node();        null-&gt;ch[0] = null-&gt;ch[1] = null;        root[0] = new Trie_Node();        root[0]-&gt;ch[1] = root[0]-&gt;ch[0] = null;    }    Trie_Node *NewNode()    {        Trie_Node *rt = new Trie_Node();        rt-&gt;ch[0] = rt-&gt;ch[1] = null;        return rt;    }    void copy(Trie_Node *&amp;a, Trie_Node *b)    {        if (b == null)            a = null;        else            a = NewNode(), *a = *b;    }    void Insert(int x, int cnt)    {        x += fix;        copy(root[cnt], root[cnt - 1]);        Trie_Node *rt1 = root[cnt], *rt2 = root[cnt - 1];        for (int i = full; i &gt;= 0; i--)        {            int k = (x &gt;&gt; i) &amp; 1;            copy(rt1-&gt;ch[k], rt2-&gt;ch[k]);            if (rt1-&gt;ch[k] == null)                rt1-&gt;ch[k] = NewNode();            rt1 = rt1-&gt;ch[k], rt2 = rt2-&gt;ch[k];            rt1-&gt;s++;        }    }    int kth(int k, int l, int r)    {        int res = 0;        Trie_Node *rt1 = root[r], *rt2 = root[l - 1];        for (int i = full; i &gt;= 0; i--)        {            if (k &gt; rt1-&gt;ch[0]-&gt;s - rt2-&gt;ch[0]-&gt;s)            {                k -= (rt1-&gt;ch[0]-&gt;s - rt2-&gt;ch[0]-&gt;s);                res |= (1 &lt;&lt; i);                rt1 = rt1-&gt;ch[1], rt2 = rt2-&gt;ch[1];            }            else            {                rt1 = rt1-&gt;ch[0], rt2 = rt2-&gt;ch[0];            }        }        return res - fix;    }} root;int main(){    freopen(&quot;kth.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;kth.out&quot;,&quot;w&quot;,stdout);    int n, m, a;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i++)    {        scanf(&quot;%d&quot;, &amp;a);        root.Insert(a, i);    }    int b, k;    while (m--)    {        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;k);        printf(&quot;%d\n&quot;, root.kth(k, a, b));    }}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/08/02/54/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HDU 5996 dingyeye loves stone</title>
      <link>https://blog.wildrage.xyz/2017/07/30/53/</link>
      <guid>https://blog.wildrage.xyz/2017/07/30/53/</guid>
      <pubDate>Sun, 30 Jul 2017 12:55:15 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description&quot;&gt;&lt;/a&gt;Problem Description&lt;/h3&gt;&lt;p&gt;dingyeye loves play stone game with you.&lt;/p&gt;
&lt;p&gt;dingyeye has an n-point tree.The nodes are numbered from 0 to n−1,while the root is numbered 0.Initially,there are a[i] stones on the i-th node.The game is in turns.When one move,he can choose a node and move some(this number cannot be 0) of the stones on it to its father.One loses the game if he can’t do anything when he moves.&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>dingyeye loves play stone game with you.</p><p>dingyeye has an n-point tree.The nodes are numbered from 0 to n−1,while the root is numbered 0.Initially,there are a[i] stones on the i-th node.The game is in turns.When one move,he can choose a node and move some(this number cannot be 0) of the stones on it to its father.One loses the game if he can’t do anything when he moves.<br><a id="more"></a><br>You always move first.You want to know whether you can win the game if you play optimally.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>In the first line, there is an integer $ T $ indicating the number of test cases.</p><p>In each test case,the first line contains one integer n refers to the number of nodes.<br>The next line contains $ n−1 $ integers $ fa[1]⋯fa[n−1] $,which describe the father of nodes $ 1⋯n−1 $(node 0 is the root).It is guaranteed that $ 0≤fa[i]&lt;i $.<br>The next line contains n integers $ a[0]⋯a[n−1] $,which describe the initial stones on each nodes.It is guaranteed that 0≤a[i]&lt;134217728.<br>$ 1≤T≤100,1≤n≤100000 $.</p><p>It is guaranteed that there is at most $ 7 $ test cases such that $n&gt;100$.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case output one line.If you can win the game,print “win”.Ohterwise,print “lose”.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>2<br>2<br>0<br>1000 1<br>4<br>0 1 0<br>2 3 3 3   </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>win<br>lose  </p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>由叶节点向根移石子<br>移不了的输</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>可看做多个阶梯博弈<br>将奇数层异或就可以了</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int f[100005], a[100005];vector&lt;int&gt; ch[100005];int S;void DFS(int x,int D){    if(D&amp;1) S^=a[x];    for(auto i:ch[x])    {        DFS(i,D+1);    }}int main(int argc, char const *argv[]){    int T;    scanf(&quot;%d&quot;, &amp;T);    while (T--)    {        int n;        scanf(&quot;%d&quot;, &amp;n);        for (int i = 0; i &lt; n; i++)            ch[i].clear();        for (int i = 1; i &lt;= n - 1; i++)        {            scanf(&quot;%d&quot;, &amp;f[i]);            ch[f[i]].push_back(i);        }        for (int i = 0; i &lt;= n - 1; i++)        {            scanf(&quot;%d&quot;, &amp;a[i]);        }        S = 0;        DFS(0,0);        if(S)            printf(&quot;win\n&quot;);        else             printf(&quot;lose\n&quot;);    }    //while(1);    return 0;}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/07/30/53/#disqus_thread</comments>
    </item>
    
    <item>
      <title>POJ 1704 Georgia and Bob</title>
      <link>https://blog.wildrage.xyz/2017/07/30/52/</link>
      <guid>https://blog.wildrage.xyz/2017/07/30/52/</guid>
      <pubDate>Sun, 30 Jul 2017 12:30:56 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;Georgia and Bob decide to play a self-invented game. They draw a row of grids on paper, number the grids from left to right by 1, 2, 3, …, and place N chessmen on different grids, as shown in the following figure for example:&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Georgia and Bob decide to play a self-invented game. They draw a row of grids on paper, number the grids from left to right by 1, 2, 3, …, and place N chessmen on different grids, as shown in the following figure for example:<br><a id="more"></a></p><p>Georgia and Bob move the chessmen in turn. Every time a player will choose a chessman, and move it to the left without going over any other chessmen or across the left edge. The player can freely choose number of steps the chessman moves, with the constraint that the chessman must be moved at least ONE step and one grid can at most contains ONE single chessman. The player who cannot make a move loses the game. </p><p>Georgia always plays first since “Lady first”. Suppose that Georgia and Bob both do their best in the game, i.e., if one of them knows a way to win the game, he or she will be able to carry it out. </p><p>Given the initial positions of the n chessmen, can you predict who will finally win the game? </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input contains a single integer T (1 &lt;= T &lt;= 20), the number of test cases. Then T cases follow. Each test case contains two lines. The first line consists of one integer N (1 &lt;= N &lt;= 1000), indicating the number of chessmen. The second line contains N different integers P1, P2 … Pn (1 &lt;= Pi &lt;= 10000), which are the initial positions of the n chessmen.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, prints a single line, “Georgia will win”, if Georgia will win the game; “Bob will win”, if Bob will win the game; otherwise ‘Not sure’.  </p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>2<br>3<br>1 2 3<br>8<br>1 5 6 7 9 12 14 17  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>Bob will win<br>Georgia will win  </p></blockquote><h3 id="简单题意"><a href="#简单题意" class="headerlink" title="简单题意"></a>简单题意</h3><p>在 1 * n 的格子上有一些石子<br>轮流将石子向右移动<br>不能移动的输  </p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>将间隙看做石子<br>做阶梯博弈<br>及 将奇数层的石子看做 Nim 游戏<br>偶数层不用管  </p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int x[100005], b[100005];int main(int argc, char const *argv[]){    int T;    scanf(&quot;%d&quot;,&amp;T);    while (T--)    {        int n;        scanf(&quot;%d&quot;, &amp;n);        for (int i = 1; i &lt;= n; i++)        {            scanf(&quot;%d&quot;, &amp;x[i]);        }        sort(x+1,x+n+1);        for (int i = 1; i &lt;= n; i++)        {            b[i] = x[i] - x[i - 1] - 1;        }        int S = 0;        for (int i = n; i &gt;= 1; i -= 2)        {            S ^= b[i];        }        if (S)            printf(&quot;Georgia will win\n&quot;);        else            printf(&quot;Bob will win\n&quot;);    }    return 0;}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/07/30/52/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[bzoj 1449] [JSOI2009] 球队收益</title>
      <link>https://blog.wildrage.xyz/2017/07/30/51/</link>
      <guid>https://blog.wildrage.xyz/2017/07/30/51/</guid>
      <pubDate>Sun, 30 Jul 2017 07:45:56 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://moetu.fastmirror.org/images/2017/08/02/645602374fcf3.gif&quot; alt=&quot;645602374fcf3.gif&quot;&gt;&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p><img src="https://moetu.fastmirror.org/images/2017/08/02/645602374fcf3.gif" alt="645602374fcf3.gif"><br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p><img src="https://moetu.fastmirror.org/images/2017/08/02/72452186e227.gif" alt="72452186e227.gif"></p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一个整数表示联盟里所有球队收益之和的最小值。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>3 3<br>1 0 2 1<br>1 1 10 1<br>0 1 3 3<br>1 2<br>2 3<br>3 1  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>43</p></blockquote><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p><img src="https://moetu.fastmirror.org/images/2017/08/02/469131504db0e.gif" alt="469131504db0e.gif"></p><h2 id="题解懒得写了"><a href="#题解懒得写了" class="headerlink" title="题解懒得写了"></a>题解懒得写了</h2><pre><code class="c++">/* * @Author: WildRage  * @Date: 2017-07-29 15:51:58  * @Last Modified by: WildRage * @Last Modified time: 2017-07-29 16:05:11 */#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;int win[5005], lose[5005];int C[5005], D[5005], du[5005];const int INF = 0x3f3f3f3f;class Mincost{  public:    int first[20005], p;    Mincost()    {        memset(first, -1, sizeof(first));    }    class edge    {      public:        int END, S, next, cap, cost;    } v[100005];    void add(int a, int b, int f, int c)    {        v[p].END = b, v[p].next = first[a], v[p].S = a, v[p].cap = f, v[p].cost = c, first[a] = p++;        v[p].END = a, v[p].next = first[b], v[p].S = b, v[p].cap = 0, v[p].cost = -c, first[b] = p++;    }    int dis[20005], pre[20005];    bool vis[20005];    bool spfa(int S, int E)    {        memset(dis, 0x3f, sizeof(dis));        memset(pre, -1, sizeof(pre));        memset(vis, 0, sizeof(vis));        queue&lt;int&gt; Q;        Q.push(S);        vis[S] = 1;        dis[S] = 0;        while (!Q.empty())        {            int u = Q.front();            Q.pop();            vis[u] = 0;            for (int i = first[u]; i != -1; i = v[i].next)            {                if (!v[i].cap)                    continue;                if (dis[v[i].END] &gt; dis[u] + v[i].cost)                {                    dis[v[i].END] = dis[u] + v[i].cost;                    pre[v[i].END] = i;                    if (!vis[v[i].END])                    {                        vis[v[i].END] = 1;                        Q.push(v[i].END);                    }                }            }        }        return dis[E] != 0x3f3f3f3f;    }    int MinCost(int S, int T)    {        int ans = 0, flow;        while (spfa(S, T))        {            flow = INF;            for (int i = pre[T]; i != -1; i = pre[v[i].S])                flow = min(flow, v[i].cap);            for (int i = pre[T]; i != -1; i = pre[v[i].S])                v[i].cap -= flow, v[i ^ 1].cap += flow;            ans += dis[T] * flow;        }        return ans;    }} Min;int main(int argc, char const *argv[]){    int n, m, a, b;    int S = 0, T = 10005;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i++)    {        scanf(&quot;%d%d%d%d&quot;, &amp;win[i], &amp;lose[i], &amp;C[i], &amp;D[i]);    }    int ans = 0;    for (int i = 1; i &lt;= m; i++)    {        Min.add(S, i, 1, 0);        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);        Min.add(i, m + a, 1, 0);        Min.add(i, m + b, 1, 0);        du[a]++, du[b]++;    }    for (int i = 1; i &lt;= n; i++)        lose[i] += du[i];    for (int i = 1; i &lt;= n; i++)        ans += lose[i] * lose[i] * D[i] + win[i] * win[i] * C[i];    for (int i = 1; i &lt;= n; i++)    {        for (int j = 1; j &lt;= du[i]; j++)        {            Min.add(m + i, T, 1, 2 * win[i] * C[i] + C[i] + D[i] - 2 * lose[i] * D[i]);            lose[i]--;            win[i]++;        }    }    printf(&quot;%d\n&quot;, ans + Min.MinCost(S, T));    //while (1)        ;    return 0;}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/07/30/51/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[网络流24题] 搭配飞行员</title>
      <link>https://blog.wildrage.xyz/2017/07/30/50/</link>
      <guid>https://blog.wildrage.xyz/2017/07/30/50/</guid>
      <pubDate>Sun, 30 Jul 2017 07:31:12 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;【问题描述】&quot;&gt;&lt;a href=&quot;#【问题描述】&quot; class=&quot;headerlink&quot; title=&quot;【问题描述】&quot;&gt;&lt;/a&gt;【问题描述】&lt;/h3&gt;&lt;p&gt;飞行大队有若干个来自各地的驾驶员，专门驾驶一种型号的飞机，这种飞机每架有两个驾驶员,需一个正驾驶员和一个副驾驶员。由于种种原因，例如相互配合的问题，有些驾驶员不能在同一架飞机上飞行，问如何搭配驾驶员才能使出航的飞机最多。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="【问题描述】"><a href="#【问题描述】" class="headerlink" title="【问题描述】"></a>【问题描述】</h3><p>飞行大队有若干个来自各地的驾驶员，专门驾驶一种型号的飞机，这种飞机每架有两个驾驶员,需一个正驾驶员和一个副驾驶员。由于种种原因，例如相互配合的问题，有些驾驶员不能在同一架飞机上飞行，问如何搭配驾驶员才能使出航的飞机最多。<br> <a id="more"></a><br><img src="https://moetu.fastmirror.org/images/2017/08/02/93216950253b1.jpg" alt="93216950253b1.jpg"><br>如图，假设有10个驾驶员，如图中的V1，V2，…，V10就代表达10个驾驶员,其中V1，V2，V3，V4，V5是正驾驶员,V6，V7，V8，V9，V10是副驾驶员。如果一个正驾驶员和一个副驾驶员可以同机飞行，就在代表他们两个之间连一条线,两个人不能同机飞行，就不连。例如V1和V7可以同机飞行，而V1和V8就不行。请搭配飞行员，使出航的飞机最多。注意:因为驾驶工作分工严格,两个正驾驶员或两个副驾驶员都不能同机飞行.</p><h3 id="【输入格式】"><a href="#【输入格式】" class="headerlink" title="【输入格式】"></a>【输入格式】</h3><p>输入文件有若干行<br>第一行，两个整数n与n1，表示共有n个飞行员(2&lt;=n&lt;=100),其中有n1名飞行员是正驾驶员.<br>下面有若干行,每行有2个数字a,b。表示正驾驶员a和副驾驶员b可以同机飞行。<br>注:正驾驶员的编号在前,即正驾驶员的编号小于副驾驶员的编号.</p><h3 id="【输出格式】"><a href="#【输出格式】" class="headerlink" title="【输出格式】"></a>【输出格式】</h3><p>输出文件有一行<br>第一行，1个整数，表示最大起飞的飞机数。</p><h3 id="【输入输出样例】"><a href="#【输入输出样例】" class="headerlink" title="【输入输出样例】"></a>【输入输出样例】</h3><h3 id="输入文件名：-flyer-in"><a href="#输入文件名：-flyer-in" class="headerlink" title="输入文件名： flyer.in"></a>输入文件名： flyer.in</h3><blockquote><p>10 5<br>1 7<br>2 6<br>2 10<br>3 7<br>4 8<br>5 9   </p></blockquote><h3 id="输出文件名：flyer-out"><a href="#输出文件名：flyer-out" class="headerlink" title="输出文件名：flyer.out"></a>输出文件名：flyer.out</h3><p>4  </p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>二分图直接建图  </p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;const int INF = 0x3f3f3f3f;class Dinic{  public:    struct edge    {        int END, next, cap;    } v[1005];    int first[105], p;    Dinic()    {        memset(first, -1, sizeof(first));    }    void add(int a, int b, int c)    {        v[p].END = b, v[p].next = first[a], v[p].cap = c, first[a] = p++;        v[p].END = a, v[p].next = first[b], v[p].cap = 0, first[b] = p++;    }    int dis[105];    bool vis[10005];    bool BFS(int S, int E)    {        memset(vis, 0, sizeof(vis));        memset(dis, -1, sizeof(dis));        queue&lt;int&gt; Q;        Q.push(S);        dis[S] = 0;        vis[S] = 1;        while (!Q.empty())        {            int u = Q.front();            Q.pop();            for (int i = first[u]; i != -1; i = v[i].next)            {                if (!vis[v[i].END] &amp;&amp; v[i].cap &gt; 0)                {                    vis[v[i].END] = 1;                    dis[v[i].END] = dis[u] + 1;                    if (v[i].END == E)                        return 1;                    Q.push(v[i].END);                }            }        }        return 0;    }    int DFS(int S, int E, int a)    {        if (S == E || a == 0)            return a;        int flow = 0, f;        for (int i = first[S]; i != -1; i = v[i].next)        {            if (dis[v[i].END] == dis[S] + 1 &amp;&amp; (f = DFS(v[i].END, E, min(a, v[i].cap)) &gt; 0))            {                v[i].cap -= f;                v[i ^ 1].cap += f;                a -= f;                flow += f;                if (f == 0)                    break;            }        }        if (!flow)            dis[S] = -1;        return flow;    }    int dinic(int S, int E)    {        int ans = 0;        while (BFS(S, E))        {            ans += DFS(S, E, INF);        }        return ans;    }} dinic;int main(int argc, char const *argv[]){    freopen(&quot;flyer.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;flyer.out&quot;,&quot;w&quot;,stdout);    int n, n1, a, b;    scanf(&quot;%d%d&quot;, &amp;n, &amp;n1);    while (scanf(&quot;%d%d&quot;, &amp;a, &amp;b) != EOF)        dinic.add(a, b, 1);    int S = 0, T = n + 1;    for (int i = 1; i &lt;= n1; i++)    {        dinic.add(S, i, 1);    }    for (int i = n1 + 1; i &lt;= n; i++)    {        dinic.add(i, T, 1);    }    printf(&quot;%d\n&quot;, dinic.dinic(S, T));    return 0;}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/07/30/50/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[网络流24题] 餐巾</title>
      <link>https://blog.wildrage.xyz/2017/07/30/49/</link>
      <guid>https://blog.wildrage.xyz/2017/07/30/49/</guid>
      <pubDate>Sun, 30 Jul 2017 07:16:05 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;【问题描述】&quot;&gt;&lt;a href=&quot;#【问题描述】&quot; class=&quot;headerlink&quot; title=&quot;【问题描述】&quot;&gt;&lt;/a&gt;【问题描述】&lt;/h3&gt;&lt;p&gt; 一个餐厅在相继的N天里，第i天需要Ri块餐巾(i=l，2，…，N)。餐厅可以从三种途径获得餐巾。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;购买新的餐巾，每块需p分；  &lt;/li&gt;
&lt;li&gt;把用过的餐巾送到快洗部，洗一块需m天，费用需f分(f&amp;lt;p)。如m=l时，第一天送到快洗部的餐巾第二天就可以使用了，送慢洗的情况也如此。
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="【问题描述】"><a href="#【问题描述】" class="headerlink" title="【问题描述】"></a>【问题描述】</h3><p> 一个餐厅在相继的N天里，第i天需要Ri块餐巾(i=l，2，…，N)。餐厅可以从三种途径获得餐巾。</p><ol><li>购买新的餐巾，每块需p分；  </li><li>把用过的餐巾送到快洗部，洗一块需m天，费用需f分(f&lt;p)。如m=l时，第一天送到快洗部的餐巾第二天就可以使用了，送慢洗的情况也如此。   <a id="more"></a></li><li>把餐巾送到慢洗部，洗一块需n天(n&gt;m)，费用需s分(s&lt;f)。在每天结束时，餐厅必须决定多少块用过的餐巾送到快洗部，多少块送慢洗部。在每天开始时，餐厅必须决定是否购买新餐巾及多少，使洗好的和新购的餐巾之和满足当天的需求量Ri，并使N天总的费用最小。  </li></ol><h3 id="【输入】"><a href="#【输入】" class="headerlink" title="【输入】"></a>【输入】</h3><p>输入文件共 3 行，第 1 行为总天数；第 2 行为每天所需的餐巾块数；第 3 行为每块餐巾的新购费用 p ，快洗所需天数 m ，快洗所需费用 f ，慢洗所需天数 n ，慢洗所需费用 s 。</p><h3 id="【输出】"><a href="#【输出】" class="headerlink" title="【输出】"></a>【输出】</h3><p>一行，最小的费用</p><h3 id="【样例】"><a href="#【样例】" class="headerlink" title="【样例】"></a>【样例】</h3><h3 id="napkin-in"><a href="#napkin-in" class="headerlink" title="napkin.in"></a>napkin.in</h3><blockquote><p>3<br>3 2 4<br>10 1 6 2 3  </p></blockquote><h3 id="napkin-out"><a href="#napkin-out" class="headerlink" title="napkin.out"></a>napkin.out</h3><blockquote><p>64  </p></blockquote><h3 id="【数据规模】"><a href="#【数据规模】" class="headerlink" title="【数据规模】"></a>【数据规模】</h3><p>n&lt;=200,Ri&lt;=50  </p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>将天拆点<br>由源点向天的第一个点连边<br>然后由天的第二个点向汇点连边<br>流量都为Ri  费用为零<br>由源点向天的第二个点连流量为正无穷 费用为p的边<br>然后由前一天的剩下的向后一天连边<br>由前一天洗过的向能用的那一天连边<br>然后跑最小费用最大流就好了  </p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int INF = 0x3f3f3f3f;class Mincost{  public:    int first[20005], p;    Mincost()    {        memset(first, -1, sizeof(first));    }    class edge    {      public:        int END, S, next, cap, cost;    } v[100005];    void add(int a, int b, int f, int c)    {        v[p].END = b, v[p].next = first[a], v[p].S = a, v[p].cap = f, v[p].cost = c, first[a] = p++;        v[p].END = a, v[p].next = first[b], v[p].S = b, v[p].cap = 0, v[p].cost = -c, first[b] = p++;    }    int dis[20005], pre[20005];    bool vis[20005];    bool spfa(int S, int E)    {        memset(dis, 0x3f, sizeof(dis));        memset(pre, -1, sizeof(pre));        memset(vis, 0, sizeof(vis));        queue&lt;int&gt; Q;        Q.push(S);        vis[S] = 1;        dis[S] = 0;        while (!Q.empty())        {            int u = Q.front();            Q.pop();            vis[u] = 0;            for (int i = first[u]; i != -1; i = v[i].next)            {                if (!v[i].cap)                    continue;                if (dis[v[i].END] &gt; dis[u] + v[i].cost)                {                    dis[v[i].END] = dis[u] + v[i].cost;                    pre[v[i].END] = i;                    if (!vis[v[i].END])                    {                        vis[v[i].END] = 1;                        Q.push(v[i].END);                    }                }            }        }        return dis[E] != 0x3f3f3f3f;    }    int MinCost(int S, int T)    {        int ans = 0, flow;        while (spfa(S, T))        {            flow = INF;            for (int i = pre[T]; i != -1; i = pre[v[i].S])                flow = min(flow, v[i].cap);            for (int i = pre[T]; i != -1; i = pre[v[i].S])                v[i].cap -= flow, v[i ^ 1].cap += flow;            ans += dis[T] * flow;        }        return ans;    }} Min;int a[205];int main(int argc, char const *argv[]){    freopen(&quot;napkin.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;napkin.out&quot;,&quot;w&quot;,stdout);    int n, p, m, f, c, s;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i++)    {        scanf(&quot;%d&quot;, a + i);    }    scanf(&quot;%d%d%d%d%d&quot;, &amp;p, &amp;m, &amp;f, &amp;c, &amp;s);    int S = 0, T = n * 3;    for (int i = 1; i &lt;= n; i++)    {        Min.add(S, i, a[i], 0);        Min.add(n + i, T, a[i], 0);        Min.add(S, i + n, INF, p);        //Min.add(i, i + n, a[i], 0);        if (i + 1 &lt;= n)            Min.add(i, i + 1, INF, 0);        if (i + m &lt;= n)            Min.add(i, i + n + m, INF, f);        if (i + c &lt;= n)            Min.add(i, i + n + c, INF, s);    }    printf(&quot;%d&quot;, Min.MinCost(S, T));    return 0;}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/07/30/49/#disqus_thread</comments>
    </item>
    
    <item>
      <title>vijos 天神下凡</title>
      <link>https://blog.wildrage.xyz/2017/07/30/48/</link>
      <guid>https://blog.wildrage.xyz/2017/07/30/48/</guid>
      <pubDate>Sun, 30 Jul 2017 07:16:05 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Czy找到宝藏获得屠龙宝刀和神秘秘籍！现在他要去找经常ntr他的Jmars报仇……&lt;/p&gt;
&lt;p&gt;Czy学会了一招“堕天一击”，他对一个地点发动堕天一击，地面上就会留下一个很大的圆坑。圆坑的周围一圈能量太过庞大，因此无法通过。所以每次czy发动技能都会把地面分割。Jmars拥有好大好大的土地，几十眼都望不到头，所以可以假设土地的大小是无限大。现在czy对他发动了猛烈的攻击，他想知道在泽宇攻击之后他的土地被切成几份了?&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Czy找到宝藏获得屠龙宝刀和神秘秘籍！现在他要去找经常ntr他的Jmars报仇……</p><p>Czy学会了一招“堕天一击”，他对一个地点发动堕天一击，地面上就会留下一个很大的圆坑。圆坑的周围一圈能量太过庞大，因此无法通过。所以每次czy发动技能都会把地面分割。Jmars拥有好大好大的土地，几十眼都望不到头，所以可以假设土地的大小是无限大。现在czy对他发动了猛烈的攻击，他想知道在泽宇攻击之后他的土地被切成几份了?<br><a id="more"></a><br>Czy毕竟很虚，因此圆心都在x坐标轴上。另外，保证所有圆两两之间不会相交。</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>输入第一行为整数n，表示czy放了n次堕天一击。</p><p>接下来n行，每行两个整数x[i]，r[i]。表示在坐标（x[i] , 0）放了一次堕天一击，半径为r[i]。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出一行，表示地面被分割成几块。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>4<br>7 5<br>-9 11<br>11 9<br>0 20  </p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>6  </p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>那个栈扫一遍</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;using namespace std;struct data{    int l, r, id;    bool operator&lt;(const data &amp;a) const    {        return l == a.l ? r &gt; a.r : l &lt; a.l;    }} a[1000001];int main(int argc, char const *argv[]){    stack&lt;data&gt; st;    int n, s, r;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 0; i &lt; n; i++)    {        scanf(&quot;%d%d&quot;, &amp;s, &amp;r);        a[i].l = s - r, a[i].id = i, a[i].r = s + r;    }    sort(a, a + n);    // for (int i = 0; i &lt; n; i++)    // {    //     printf(&quot;%d %d %d\n&quot;, a[i].l, a[i].r, a[i].id);    // }    //while (1)        ;    int ans = 0;    for (int i = 0; i &lt; n; i++)    {        if (a[i].l == a[i + 1].l &amp;&amp; i + 1 != n - 1)        {            st.push(a[i]);            continue;        }        if (!st.empty() &amp;&amp; a[i].r == st.top().r)        {            st.pop();            ans++;        }        if (a[i].r != a[i + 1].l)        {            if (!st.empty())                st.pop();        }    }    printf(&quot;%d&quot;, ans + n + 1);    return 0;}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/07/30/48/#disqus_thread</comments>
    </item>
    
    <item>
      <title>vijos 藏宝图</title>
      <link>https://blog.wildrage.xyz/2017/07/29/47/</link>
      <guid>https://blog.wildrage.xyz/2017/07/29/47/</guid>
      <pubDate>Sat, 29 Jul 2017 22:27:22 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Czy爬上黑红树，到达了一个奇怪的地方……&lt;/p&gt;
&lt;p&gt;Czy发现了一张奇怪的藏宝图。图上有n个点，m条无向边。已经标出了图中两两之间距离dist。但是czy知道，只有当图刚好又是一颗树的时候，这张藏宝图才是真的。如果藏宝图是真的，那么经过点x的边的边权平均数最大的那个x是藏着宝物的地方。请计算这是不是真的藏宝图，如果是真的藏宝之处在哪里。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Czy爬上黑红树，到达了一个奇怪的地方……</p><p>Czy发现了一张奇怪的藏宝图。图上有n个点，m条无向边。已经标出了图中两两之间距离dist。但是czy知道，只有当图刚好又是一颗树的时候，这张藏宝图才是真的。如果藏宝图是真的，那么经过点x的边的边权平均数最大的那个x是藏着宝物的地方。请计算这是不是真的藏宝图，如果是真的藏宝之处在哪里。<br><a id="more"></a></p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>输入数据第一行一个数T,表示T组数据。</p><p>对于每组数据，第一行一个n，表示藏宝图上的点的个数。</p><p>接下来n行,每行n个数，表示两两节点之间的距离。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出一行或两行。第一行”Yes”或”No”，表示这是不是真的藏宝图。</p><p>若是真的藏宝图，第二行再输出一个数，表示哪个点是藏宝之处。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>2<br>3<br>0 7 9<br>7 0 2<br>9 2 0<br>3<br>0 2 7<br>2 0 9<br>7 9 0  </p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>Yes<br>1<br>Yes<br>3  </p></blockquote><blockquote><p>样例解释:第一棵树的形状是1–2–3。1、2之间的边权是7，2、3之间是2。<br>第二棵树的形状是2–1–3。2、1之间的边权是2，1、3之间是7。</p></blockquote><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>对于30%数据，n&lt;=50,1&lt;=树上的边的长度&lt;=10^9。<br>对于50%数据，n&lt;=600.<br>对于100%数据，1&lt;=n&lt;=2500,除30%小数据外任意0&lt;=dist[i][j]&lt;=10^9,T&lt;=5</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>跑最小生成树<br>然后跑两两之间距离DFS<br>比较一下两个矩阵就出来了  </p><pre><code class="c++"></code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/07/29/47/#disqus_thread</comments>
    </item>
    
    <item>
      <title>vijos 黑红树</title>
      <link>https://blog.wildrage.xyz/2017/07/29/46/</link>
      <guid>https://blog.wildrage.xyz/2017/07/29/46/</guid>
      <pubDate>Sat, 29 Jul 2017 22:16:02 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Mz们在czy的生日送他一个黑红树种子……czy种下种子，结果种子很快就长得飞快，它的枝干伸入空中看不见了……&lt;/p&gt;
&lt;p&gt;Czy发现黑红树具有一些独特的性质。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;这是二叉树，除根节点外每个节点都有红与黑之间的一种颜色。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每个节点的两个儿子节点都被染成恰好一个红色一个黑色。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这棵树你是望不到头的（树的深度可以到无限大）&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Mz们在czy的生日送他一个黑红树种子……czy种下种子，结果种子很快就长得飞快，它的枝干伸入空中看不见了……</p><p>Czy发现黑红树具有一些独特的性质。</p><ol><li><p>这是二叉树，除根节点外每个节点都有红与黑之间的一种颜色。</p></li><li><p>每个节点的两个儿子节点都被染成恰好一个红色一个黑色。</p></li><li><p>这棵树你是望不到头的（树的深度可以到无限大）</p><a id="more"></a></li><li>黑红树上的高度这样定义:h(根节点)=0，h[son]=h[father]+1。</li></ol><p>Czy想从树根顺着树往上爬。他有p/q的概率到达红色的儿子节点，有1-p/q的概率到达黑色节点。但是他知道如果自己经过的路径是不平衡的，他会马上摔下来。一条红黑树上的链是不平衡的，当且仅当红色节点与黑色节点的个数之差大于1。现在他想知道他刚好在高度为h的地方摔下来的概率的精确值a/b，gcd(a,b)=0。那可能很大，所以他只要知道a,b对K取模的结果就可以了。另外，czy对输入数据加密：第i个询问Qi真正大小将是给定的Q减上一个询问的第一个值a%K.</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第一行四个数p,q,T,k，表示走红色节点概率是p/q，以下T组询问，答案对K取模。接下来T行，每行一个数 Q,表示czy想知道刚好在高度Q掉下来的概率（已加密）</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出T行，每行两个整数，表示要求的概率a/b中a%K和b%K的精确值。如果这个概率就是0或1，直接输出0 0或1 1（中间有空格）。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><p>样例输入1        </p><blockquote><p>2 3 2 100<br>1<br>2  </p></blockquote><p>样例输入2</p><blockquote><p>2 3 2 20<br>4<br>6</p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><p>样例输出1  </p><blockquote><p>0 0<br>5 9</p></blockquote><p>样例输出2</p><blockquote><p>0 1<br>0 9</p></blockquote><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>对于30%数据,p,q&lt;=5,T&lt;=1000,K&lt;=127,对于任意解密后的Q，有Q&lt;=30</p><p>对于60%数据,p,q&lt;=20,T&lt;=100000,K&lt;=65535,对于任意解密后的Q,有Q&lt;=1000</p><p>对于100%数据,p,q&lt;=100,T&lt;=1000000, K&lt;=1000000007,对于任意解密后的Q,有Q&lt;=1000000</p><p>对于100%数据,有q&gt;p,即0&lt;= p/q&lt;=1</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>不写了<br>主要就是两行两行的考虑</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;int P;class frac{  public:    long long a, b;    long long gcd(long long A, long long B)    {        return B == 0 ? A : gcd(B, A % B);    }    frac Update(frac s)    {        if (s.a == 0)            return s;        int GCD = s.gcd(s.a, s.b);        return (frac){s.a / GCD, s.b / GCD};    }    frac operator*(const frac A)    {        return (frac){a * A.a % P, b * A.b % P};    }    frac operator*(const int A)    {        return (frac){a * A % P, b % P};    }};frac ans[1000001];// 0 b, 1 r// 0 = ,1 b&gt;r ,2,b&lt;rint main(){    //freopen(&quot;brtree.in&quot;, &quot;r&quot;, stdin);    //freopen(&quot;brtree.out&quot;, &quot;w&quot;, stdout);    int p, q, T;    scanf(&quot;%d%d%d%d&quot;, &amp;p, &amp;q, &amp;T, &amp;P);    p %= P;    q %= P;    frac B = (frac){q - p, q};    frac R = (frac){p, q};    frac BR = B * R * 2;    frac BBRR = (frac){p * p + (q - p) * (q - p), q * q};    BR = BR.Update(BR);    BBRR = BBRR.Update(BBRR);    ans[2] = BBRR;    for (int i = 4; i &lt;= 1000000; i += 2)    {        ans[i] = ans[i - 2] * BR;    }    int k = 0, r = 0;    while (T--)    {        scanf(&quot;%d&quot;, &amp;k);        k -= r;        //int Gcd = ans[k].gcd(ans[k].a, ans[k].b);        r = 0;        printf(&quot;%lld %lld\n&quot;, ans[k].a % P, ans[k].b % P);        r = ans[k].a % P;    }}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/07/29/46/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 2510 弱题</title>
      <link>https://blog.wildrage.xyz/2017/07/27/45/</link>
      <guid>https://blog.wildrage.xyz/2017/07/27/45/</guid>
      <pubDate>Thu, 27 Jul 2017 13:18:32 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;有M个球，一开始每个球均有一个初始标号，标号范围为1～N且为整数，标号为i的球有ai个，并保证Σai = M。&lt;br&gt;每次操作等概率取出一个球（即取出每个球的概率均为1/M），若这个球标号为k（k &amp;lt; N），则将它重新标号为k + 1；若这个球标号为N，则将其重标号为1。（取出球后并不将其丢弃）&lt;br&gt;现在你需要求出，经过K次这样的操作后，每个标号的球的期望个数。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>有M个球，一开始每个球均有一个初始标号，标号范围为1～N且为整数，标号为i的球有ai个，并保证Σai = M。<br>每次操作等概率取出一个球（即取出每个球的概率均为1/M），若这个球标号为k（k &lt; N），则将它重新标号为k + 1；若这个球标号为N，则将其重标号为1。（取出球后并不将其丢弃）<br>现在你需要求出，经过K次这样的操作后，每个标号的球的期望个数。<br><a id="more"></a> </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行包含三个正整数N，M，K，表示了标号与球的个数以及操作次数。<br>第2行包含N个非负整数ai，表示初始标号为i的球有ai个。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>应包含N行，第i行为标号为i的球的期望个数，四舍五入保留3位小数。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>2 3 2<br>3 0  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>1.667<br>1.333</p></blockquote><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><h5 id="【样例说明】"><a href="#【样例说明】" class="headerlink" title="【样例说明】"></a>【样例说明】</h5><p>第1次操作后，由于标号为2球个数为0，所以必然是一个标号为1的球变为标号为2的球。所以有2个标号为1的球，有1个标号为2的球。</p><p>第2次操作后，有1/3的概率标号为2的球变为标号为1的球（此时标号为1的球有3个），有2/3的概率标号为1的球变为标号为2的球（此时标号为1的球有1个），所以标号为1的球的期望个数为1/3<em>3+2/3</em>1 = 5/3。同理可求出标号为2的球期望个数为4/3。</p><h5 id="【数据规模与约定】"><a href="#【数据规模与约定】" class="headerlink" title="【数据规模与约定】"></a>【数据规模与约定】</h5><p>对于10%的数据，N ≤ 5, M ≤ 5, K ≤ 10；<br>对于20%的数据，N ≤ 20, M ≤ 50, K ≤ 20；<br>对于30%的数据，N ≤ 100, M ≤ 100, K ≤ 100；<br>对于40%的数据，M ≤ 1000, K ≤ 1000；<br>对于100%的数据，N ≤ 1000, M ≤ 100,000,000, K ≤ 2,147,483,647。  </p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>一看k的范围<br>就能看出要矩阵乘优化<br>易得矩阵为<br>$$<br>    \begin{bmatrix}<br>        1-\frac{1}{m} &amp; \frac{1}{m} &amp; 0 &amp; \cdots &amp; 0 \\<br>        0 &amp; 1-\frac{1}{m} &amp; \frac{1}{m} &amp;\cdots &amp; 0 \\<br>        \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>        \frac{1}{m} &amp; 0 &amp; 0 &amp; \cdots &amp; 1-\frac{1}{m} \\<br>    \end{bmatrix}<br>$$</p><p>然后我们发现n=1000过不了<br>但是我们发现这个矩阵是一个循环矩阵<br>只用维护第一行就可以了<br>降低到$ n^2*log_2{k} $<br>就可以跑了</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;struct Martix{    double a[1005];    int n;    Martix(int x)    {        n = x;        memset(a, 0, sizeof(a));    }    Martix operator*(const Martix &amp;b)    {        Martix ans(n);        ans.a[1] = 0;        for (int i = 1; i &lt;= n; i++)        {            for (int k = 1; k &lt;= n; k++)            {                int t=(i-k+n+1)%n;                if(!t) t+=n;                ans.a[i] += a[k] * b.a[t];            }        }        return ans;    }    Martix operator^(const int x)    {        Martix a = *this, ans(n);        int k = x;        ans.a[1] = 1;        while (k)        {            if (k &amp; 1)                ans = ans * a;            k &gt;&gt;= 1;            a = a * a;        }        return ans;    }};int a[1005];double ans[1005];int main(int argc, char const *argv[]){    int n, m, k;    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);    for (int i = 1; i &lt;= n; i++)        scanf(&quot;%d&quot;, &amp;a[i]);    Martix K(n);    K.a[1] = (double)1 - ((double)1 / m);    K.a[2] = ((double)1 / m);    K=K^k;    for (int i = 1; i &lt;= n; i++)    {        for (int j = 1; j &lt;= n; j++)        {            int t=(i+j-1)%n;            if(!t) t+=n;            ans[t] += K.a[i] * a[j];        }    }    for (int i = 1; i &lt;= n; i++)    {        printf(&quot;%.3lf\n&quot;, ans[i]);    }    //while(1);    return 0;}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/07/27/45/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[NOIP2011] 玛雅游戏</title>
      <link>https://blog.wildrage.xyz/2017/07/27/44/</link>
      <guid>https://blog.wildrage.xyz/2017/07/27/44/</guid>
      <pubDate>Thu, 27 Jul 2017 13:04:01 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;【问题描述】&quot;&gt;&lt;a href=&quot;#【问题描述】&quot; class=&quot;headerlink&quot; title=&quot;【问题描述】&quot;&gt;&lt;/a&gt;【问题描述】&lt;/h3&gt;&lt;p&gt;Mayan puzzle 是最近流行起来的一个游戏。游戏界面是一个7 行5 列的棋盘，上面堆放着一些方块，方块不能悬空堆放，即方块必须放在最下面一行，或者放在其他方块之上。游戏通关是指在规定的步数内消除所有的方块，消除方块的规则如下：&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="【问题描述】"><a href="#【问题描述】" class="headerlink" title="【问题描述】"></a>【问题描述】</h3><p>Mayan puzzle 是最近流行起来的一个游戏。游戏界面是一个7 行5 列的棋盘，上面堆放着一些方块，方块不能悬空堆放，即方块必须放在最下面一行，或者放在其他方块之上。游戏通关是指在规定的步数内消除所有的方块，消除方块的规则如下：<br><a id="more"></a></p><ol><li>每步移动可以且仅可以沿横向（即向左或向右）拖动某一方块一格：当拖动这一方块时，如果拖动后到达的位置（以下称目标位置）也有方块，那么这两个方块将交换位置（参见输入输出样例说明中的图6 到图7）；如果目标位置上没有方块，那么被拖动的方块将从原来的竖列中抽出，并从目标位置上掉落（直到不悬空，参见下面图1 和图2）；<br><img src="https://moetu.fastmirror.org/images/2017/08/02/5211920921a01.png" alt="5211920921a01.png"></li><li><p>任一时刻，如果在一横行或者竖列上有连续三个或者三个以上相同颜色的方块，则它们将立即被消除（参见图1 到图3）。<br> <img src="https://moetu.fastmirror.org/images/2017/08/02/53446976e072a.png" alt="53446976e072a.png"><br> 注意：  </p><ul><li>如果同时有多组方块满足消除条件，几组方块会同时被消除（例如下面图4，三个颜色为1 的方块和三个颜色为2 的方块会同时被消除，最后剩下一个颜色为2 的方块）。  </li><li>当出现行和列都满足消除条件且行列共享某个方块时，行和列上满足消除条件的所有方块会被同时消除（例如下面图5 所示的情形，5 个方块会同时被消除）。</li></ul></li><li><p>方块消除之后，消除位置之上的方块将掉落，掉落后可能会引起新的方块消除。注意：掉落的过程中将不会有方块的消除。<br>上面图1 到图3 给出了在棋盘上移动一块方块之后棋盘的变化。棋盘的左下角方块的坐标为（0, 0），将位于（3, 3）的方块向左移动之后，游戏界面从图1 变成图2 所示的状态，此时在一竖列上有连续三块颜色为4 的方块，满足消除条件，消除连续3 块颜色为4 的方块后，上方的颜色为3 的方块掉落，形成图3 所示的局面。  </p></li></ol><h3 id="【输入】"><a href="#【输入】" class="headerlink" title="【输入】"></a>【输入】</h3><p>输入文件mayan.in，共6 行。<br>第一行为一个正整数n，表示要求游戏通关的步数。<br>接下来的5 行，描述7*5 的游戏界面。每行若干个整数，每两个整数之间用一个空格隔开，每行以一个0 结束，自下向上表示每竖列方块的颜色编号（颜色不多于10 种，从1 开始顺序编号，相同数字表示相同颜色）。<br>输入数据保证初始棋盘中没有可以消除的方块。  </p><h3 id="【输出】"><a href="#【输出】" class="headerlink" title="【输出】"></a>【输出】</h3><p>输出文件名为mayan.out。<br>如果有解决方案，输出n 行，每行包含3 个整数x，y，g，表示一次移动，每两个整数之间用一个空格隔开，其中（x，y）表示要移动的方块的坐标，g 表示移动的方向，1 表示向右移动，-1 表示向左移动。注意：多组解时，按照x 为第一关健字，y 为第二关健字，1优先于-1，给出一组字典序最小的解。游戏界面左下角的坐标为（0，0）。<br>如果没有解决方案，输出一行，包含一个整数-1。  </p><h3 id="mayan-in"><a href="#mayan-in" class="headerlink" title="mayan.in"></a>mayan.in</h3><blockquote><p>3<br>1 0<br>2 1 0<br>2 3 4 0<br>3 1 0<br>2 4 3 4 0  </p></blockquote><h3 id="mayan-out"><a href="#mayan-out" class="headerlink" title="mayan.out"></a>mayan.out</h3><blockquote><p>2 1 1<br>3 1 1<br>3 0 1 </p></blockquote><h3 id="【输入输出样例说明】"><a href="#【输入输出样例说明】" class="headerlink" title="【输入输出样例说明】"></a>【输入输出样例说明】</h3><p>按箭头方向的顺序分别为图6 到图11<br><img src="https://moetu.fastmirror.org/images/2017/08/02/19512145e77e.png" alt="19512145e77e.png"><br>样例输入的游戏局面如上面第一个图片所示，依次移动的三步是：（2，1）处的方格向右移动，（3，1）处的方格向右移动，（3，0）处的方格向右移动，最后可以将棋盘上所有方块消除。</p><h3 id="【数据范围】"><a href="#【数据范围】" class="headerlink" title="【数据范围】"></a>【数据范围】</h3><p>对于30%的数据，初始棋盘上的方块都在棋盘的最下面一行；<br>对于100%的数据，0 &lt; n≤5。  </p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>大暴搜<br>读完题先看数据范围<br>发现这道题的 n 很小<br>感觉应该可以搜<br>然后想到了BFS<br>一个一个的试<br>现在的问题就是如何消除和下落在消除的时候横着扫一遍竖着扫一遍<br>两个for打上标记<br>然后一遍循环搞掉标记的点<br>在BFS传参数的时候要注意备份用 <code>memcpy();</code><br>在搜的时候及时退出<code>exit(0);</code><br>否则可能被卡  </p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;cstdlib&gt;using namespace std;//#define WILDRAGE 1int a[6][8];bool over[6][8];void print(const int c[6][8]){    for (int i = 1; i &lt;= 5; i++)    {        for (int j = 1; j &lt;= 7; j++)            printf(&quot;%d &quot;, c[i][j]);        printf(&quot;\n&quot;);    }    printf(&quot;\n&quot;);}bool ok(const int c[6][8]){    //return 0;    for (int i = 1; i &lt;= 5; i++)    {        if (c[i][1])            return 0;    }    return 1;}bool remove(int c[6][8]){    int it1, it2;    for (int i = 1; i &lt;= 5; i++)    {        it1 = it2 = 1;        while (1)        {            while (c[i][it1] != 0 &amp;&amp; it1 &lt;= 7)                it1++;            it2 = it1;            while (c[i][it2] == 0 &amp;&amp; it2 &lt;= 7)                it2++;            if (it2 != 8)                swap(c[i][it2], c[i][it1]);            else                break;        }    }    // memset(over,0,sizeof(over));    int times = 1;    for (int i = 1; i &lt;= 5; i++)        for (int j = 1; j &lt;= 7; j++)        {            if (c[i][j] &amp;&amp; c[i][j] == c[i][j - 1])            {                times++;                if (times &gt;= 3 &amp;&amp; times &lt; 4)                {                    over[i][j - 2] = over[i][j - 1] = over[i][j] = 1;                }                if (times &gt;= 4)                    over[i][j] = 1;            }            else                times = 1;        }    times = 1;    for (int j = 1; j &lt;= 7; j++)        for (int i = 1; i &lt;= 5; i++)        {            if (c[i][j] &amp;&amp; c[i][j] == c[i - 1][j])            {                times++;                if (times &gt;= 3 &amp;&amp; times &lt; 4)                {                    over[i - 2][j] = over[i - 1][j] = over[i][j] = 1;                }                if (times &gt;= 4)                    over[i][j] = 1;            }            else                times = 1;        }    bool yes = 0;    for (int i = 1; i &lt;= 5; i++)        for (int j = 1; j &lt;= 7; j++)            if (over[i][j])                yes = 1, over[i][j] = 0, c[i][j] = 0;    if (!yes)        return 0;    //int it1, it2;    for (int i = 1; i &lt;= 5; i++)    {        it1 = it2 = 1;        while (1)        {            while (c[i][it1] != 0 &amp;&amp; it1 &lt;= 7)                it1++;            it2 = it1;            while (c[i][it2] == 0 &amp;&amp; it2 &lt;= 7)                it2++;            if (it2 != 8)                swap(c[i][it2], c[i][it1]);            else                break;        }    }    return 1;}struct data{    int x, y, t;};stack&lt;data&gt; op;stack&lt;data&gt; ans;int n;void dfs(int t, const int c[6][8]){    if (t == n)    {#ifdef WILDRAGE        print(c);#endif        if (ok(c))        {            while (!op.empty())            {                ans.push(op.top());                op.pop();            }            while (!ans.empty())            {                printf(&quot;%d %d %d\n&quot;, ans.top().x - 1, ans.top().y - 1, ans.top().t);                ans.pop();            }            exit(0);        }        return;    }    else    {        int s[6][8];        for (int i = 1; i &lt;= 5; i++)        {            for (int j = 1; j &lt;= 7; j++)            {                if (c[i][j] &amp;&amp; i + 1 &lt;= 5)                {                    op.push((data){i, j, 1});                    memcpy(s, c, sizeof(s));                    swap(s[i][j], s[i + 1][j]);#ifdef WILDRAGE//print(s);#endif                    while (remove(s))                        ;#ifdef WILDRAGE                    printf(&quot;%d %d %d\n&quot;, i, j, 1);                    print(s);#endif                    dfs(t + 1, s);                    op.pop();                }                if (c[i][j] &amp;&amp; i - 1 &gt; 0 &amp;&amp; !c[i - 1][j])                {                    op.push((data){i, j, -1});                    memcpy(s, c, sizeof(s));                    swap(s[i][j], s[i - 1][j]);#ifdef WILDRAGE//print(s);#endif                    while (remove(s))                        ;#ifdef WILDRAGE                    printf(&quot;%d %d %d\n&quot;, i, j, -1);                    print(s);#endif                    dfs(t + 1, s);                    op.pop();                }            }        }    }}int main(){#ifndef WILDRAGE    freopen(&quot;mayan.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;mayan.out&quot;, &quot;w&quot;, stdout);#endif    int s;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= 5; i++)    {        int j = 0;        while (scanf(&quot;%d&quot;, &amp;s))        {            if (s == 0)                break;            a[i][++j] = s;        }        //a[i][0] = j;    }#ifdef WILDRAGE    print(a);#endif    dfs(0, a);    printf(&quot;-1\n&quot;);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/07/27/44/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 2090 [Poi2010] Monotonicity 2</title>
      <link>https://blog.wildrage.xyz/2017/07/27/43/</link>
      <guid>https://blog.wildrage.xyz/2017/07/27/43/</guid>
      <pubDate>Thu, 27 Jul 2017 12:51:03 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;给出N个正整数a[1..N]，再给出K个关系符号（&amp;gt;、&amp;lt;或=）s[1..k]。&lt;br&gt;选出一个长度为L的子序列（不要求连续），要求这个子序列的第i项和第i+1项的的大小关系为s[(i-1)mod K+1]。&lt;br&gt;求出L的最大值。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给出N个正整数a[1..N]，再给出K个关系符号（&gt;、&lt;或=）s[1..k]。<br>选出一个长度为L的子序列（不要求连续），要求这个子序列的第i项和第i+1项的的大小关系为s[(i-1)mod K+1]。<br>求出L的最大值。<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行两个正整数，分别表示N和K (N, K &lt;= 500,000)。<br>第二行给出N个正整数，第i个正整数表示a[i]（a[i] &lt;= 10^6）。<br>第三行给出K个空格隔开关系符号（&gt;、&lt;或=），第i个表示s[i]。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一个正整数，表示L的最大值。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>7 3<br>2 4 3 1 3 5 3<br>&lt; &gt; =  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>6  </p></blockquote><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>选出的子序列为2 4 3 3 5 3，相邻大小关系分别是&lt; &gt; = &lt; &gt;。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>权值树状数组优化DP<br>不会正确性证明</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;const int MaxN = 1000000;int Max1[MaxN + 5], Max2[MaxN + 5], Max3[MaxN + 5];#define lowbit(_) ((_) &amp; (-_))void Update1(int a, int b){    for (int i = a; i &lt;= MaxN; i += lowbit(i))    {        Max1[i] = max(b, Max1[i]);    }}void Update2(int a, int b){    for (int i = a; i &gt; 0; i -= lowbit(i))    {        Max2[i] = max(b, Max2[i]);    }}int MAX1(int x){    int ans = 0;    for (int i = x; i &gt; 0; i -= lowbit(i))    {        ans = max(ans, Max1[i]);    }    return ans;}int MAX2(int x){    int ans = 0;    for (int i = x; i &lt;= MaxN; i += lowbit(i))    {        ans = max(ans, Max2[i]);    }    return ans;}int a[500005], op[500005];int f[500005][4], n, k;void add(int len, int a){    int W = (len - 1) % k + 1;    switch (op[W])    {    case 1:        Update1(a, len);        break;    case 2:        Update2(a, len);        break;    case 3:        Max3[a] = max(len, Max3[a]);        break;    default:        printf(&quot;ERROR\n&quot;);        exit(0);        break;    }}int main(){    //freopen(&quot;mot.in&quot;, &quot;r&quot;, stdin);    //freopen(&quot;mot.out&quot;, &quot;w&quot;, stdout);    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);    for (int i = 1; i &lt;= n; i++)    {        scanf(&quot;%d&quot;, &amp;a[i]);    }    char c;    for (int i = 1; i &lt;= k; i++)    {        c = getchar();        while (c != &#39;&lt;&#39; &amp;&amp; c != &#39;&gt;&#39; &amp;&amp; c != &#39;=&#39;)            c = getchar();        switch (c)        {        case &#39;&lt;&#39;:            op[i] = 1;            break;        case &#39;&gt;&#39;:            op[i] = 2;            break;        case &#39;=&#39;:            op[i] = 3;        }    }    int ans = 0;    //f[1][1] = f[1][2] = f[1][3] = 1;    for (int i = 1; i &lt;= n; i++)    {        f[i][1] = MAX1(a[i] - 1) + 1;        f[i][2] = MAX2(a[i] + 1) + 1;        f[i][3] = Max3[a[i]] + 1;        for (int j = 1; j &lt;= 3; j++)        {            add(f[i][j], a[i]);            ans = max(ans, f[i][j]);        }    }    //for(int i=1;i&lt;=n;i++)    //    printf(&quot;%d %d %d\n&quot;,f[i][1],f[i][2],f[i][3]);    // while(1);    printf(&quot;%d&quot;, ans);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/07/27/43/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 2438 [中山市选2011] 杀人游戏</title>
      <link>https://blog.wildrage.xyz/2017/07/27/42/</link>
      <guid>https://blog.wildrage.xyz/2017/07/27/42/</guid>
      <pubDate>Thu, 27 Jul 2017 07:52:00 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;一位冷血的杀手潜入 Na-wiat，并假装成平民。警察希望能在 N 个人里面，&lt;br&gt;查出谁是杀手。&lt;br&gt;警察能够对每一个人进行查证，假如查证的对象是平民，他会告诉警察，他&lt;br&gt;认识的人， 谁是杀手， 谁是平民。 假如查证的对象是杀手， 杀手将会把警察干掉。&lt;br&gt;现在警察掌握了每一个人认识谁。&lt;br&gt;每一个人都有可能是杀手，可看作他们是杀手的概率是相同的。&lt;br&gt;问：根据最优的情况，保证警察自身安全并知道谁是杀手的概率最大是多&lt;br&gt;少？&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>一位冷血的杀手潜入 Na-wiat，并假装成平民。警察希望能在 N 个人里面，<br>查出谁是杀手。<br>警察能够对每一个人进行查证，假如查证的对象是平民，他会告诉警察，他<br>认识的人， 谁是杀手， 谁是平民。 假如查证的对象是杀手， 杀手将会把警察干掉。<br>现在警察掌握了每一个人认识谁。<br>每一个人都有可能是杀手，可看作他们是杀手的概率是相同的。<br>问：根据最优的情况，保证警察自身安全并知道谁是杀手的概率最大是多<br>少？<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行有两个整数 N,M。<br>接下来有 M 行，每行两个整数 x,y，表示 x 认识 y（y 不一定认识 x,例如胡锦涛同志） 。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>仅包含一行一个实数，保留小数点后面 6 位，表示最大概率。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>5 4<br>1 2<br>1 3<br>1 4<br>1 5   </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>0.800000 </p></blockquote><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>警察只需要查证 1。假如1是杀手，警察就会被杀。假如 1不是杀手，他会告诉警<br>察 2,3,4,5 谁是杀手。而 1 是杀手的概率是 0.2,所以能知道谁是杀手但没被杀的概<br>率是0.8。  </p><p>对于 100%的数据有 1≤N ≤100000,0≤M ≤300000<br>数据已加强！</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>Tarjan缩点<br>讨论一下入度出度就可以了</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;stack&gt;using namespace std;struct edge{    int END, next;} v[1000005], E[1000005];int first[100005], Efirst[100005], p, Ep;void add(int a, int c){    v[p].END = c;    v[p].next = first[a];    first[a] = p++;}void add1(int a, int c){    E[Ep].END = c;    E[Ep].next = Efirst[a];    Efirst[a] = Ep++;}int S[100005];int low[100005], dfsn[100005], Index;bool flag[100005];int T;int belong[100005];stack&lt;int&gt; st;void tarjan(int rt){    low[rt] = dfsn[rt] = ++Index;    st.push(rt);    flag[rt] = 1;    for (int i = first[rt]; i != -1; i = v[i].next)    {        if (!dfsn[v[i].END])        {            tarjan(v[i].END);            low[rt] = min(low[rt], low[v[i].END]);        }        else if (flag[v[i].END])            low[rt] = min(low[rt], dfsn[v[i].END]);    }    if (dfsn[rt] == low[rt])    {        T++;        int v;        do        {            v = st.top();            st.pop();            flag[v] = 0;            belong[v] = T;            S[T]++;        } while (dfsn[v] != low[v]);    }}int isnroot[100005], ithason[100005];int main(){    memset(first, -1, sizeof(first));    memset(Efirst, -1, sizeof(Efirst));    //freopen(&quot;killer.in&quot;, &quot;r&quot;, stdin);    //freopen(&quot;killer.out&quot;, &quot;w&quot;, stdout);    int n, m;    int s, e;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= m; i++)    {        scanf(&quot;%d%d&quot;, &amp;s, &amp;e);        add(s, e);    }    for (int i = 1; i &lt;= n; i++)        if (!dfsn[i])            tarjan(i);    for (int i = 1; i &lt;= n; i++)    {        for (int j = first[i]; j != -1; j = v[j].next)        {            if (belong[i] != belong[v[j].END])            {                add1(belong[i], belong[v[j].END]);                isnroot[belong[v[j].END]]++;                ithason[belong[i]]++;            }        }    }    int ans = 0;    bool flags = 0;    for (int i = 1; i &lt;= T; i++)    {        if (!isnroot[i])        {            ans++;            if (flags)                continue;            //if (!ithason[i])            //    flags = 1;            if (S[i] == 1)            {                if (!ithason[i])                    flags = 1;                else                {                    bool e = 0;                    for (int j = Efirst[i]; j != -1; j = E[j].next)                    {                        if (isnroot[E[j].END] == 1)                            e = 1;                    }                    if (!e)                        flags = 1;                }            }        }    }    // if (!ans)    //     ans = 1;    if (flags)        ans -= 1;    printf(&quot;%.6lf&quot;, (double)(n - ans) / n);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/07/27/42/#disqus_thread</comments>
    </item>
    
    <item>
      <title>COGS 1752 [BOI2007] 摩基亚Mokia</title>
      <link>https://blog.wildrage.xyz/2017/07/26/41/</link>
      <guid>https://blog.wildrage.xyz/2017/07/26/41/</guid>
      <pubDate>Wed, 26 Jul 2017 13:34:23 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;【题目描述】&quot;&gt;&lt;a href=&quot;#【题目描述】&quot; class=&quot;headerlink&quot; title=&quot;【题目描述】&quot;&gt;&lt;/a&gt;【题目描述】&lt;/h3&gt;&lt;p&gt;摩尔瓦多的移动电话公司摩基亚（Mokia）设计出了一种新的用户定位系统。和其他的定位系统一样，它能够迅速回答任何形如“用户C的位置在哪？”的问题，精确到毫米。但其真正高科技之处在于，它能够回答形如“给定区域内有多少名用户？”的问题。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>摩尔瓦多的移动电话公司摩基亚（Mokia）设计出了一种新的用户定位系统。和其他的定位系统一样，它能够迅速回答任何形如“用户C的位置在哪？”的问题，精确到毫米。但其真正高科技之处在于，它能够回答形如“给定区域内有多少名用户？”的问题。<br><a id="more"></a><br>在定位系统中，世界被认为是一个W×W的正方形区域，由1×1的方格组成。每个方格都有一个坐标(x,y)，1&lt;=x,y&lt;=W。坐标的编号从1开始。对于一个4×4的正方形，就有1&lt;=x&lt;=4,1&lt;=y&lt;=4（如图）: <img src="https://moetu.fastmirror.org/images/2017/08/02/6967203467051.png" alt="6967203467051.png"><br>请帮助Mokia公司编写一个程序来计算在某个矩形区域内有多少名用户。</p><h3 id="【输入格式】"><a href="#【输入格式】" class="headerlink" title="【输入格式】"></a>【输入格式】</h3><p>有三种命令，意义如下：</p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">参数</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">W</td><td style="text-align:center">初始化一个全零矩阵。本命令仅开始时出现一次。</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">x y A</td><td style="text-align:center">向方格(x,y)中添加A个用户。A是正整数。</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">X1 Y1 X2 Y2</td><td style="text-align:center">查询X1&lt;=x&lt;=X2，Y1&lt;=y&lt;=Y2所规定的矩形中的用户数量</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">无参数</td><td style="text-align:center">结束程序。本命令仅结束时出现一次。</td></tr></tbody></table><h3 id="【输出格式】"><a href="#【输出格式】" class="headerlink" title="【输出格式】"></a>【输出格式】</h3><p>对所有命令2，输出一个一行整数，即当前询问矩形内的用户数量。</p><h3 id="【输入样例】"><a href="#【输入样例】" class="headerlink" title="【输入样例】"></a>【输入样例】</h3><blockquote><p>0 4<br>1 2 3 3<br>2 1 1 3 3<br>1 2 2 2<br>2 2 2 3 4<br>3  </p></blockquote><h3 id="【输出样例】"><a href="#【输出样例】" class="headerlink" title="【输出样例】"></a>【输出样例】</h3><blockquote><p>3<br>5  </p></blockquote><h3 id="【提示】"><a href="#【提示】" class="headerlink" title="【提示】"></a>【提示】</h3><table><thead><tr><th style="text-align:center">输入</th><th style="text-align:center">输出</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center">0 4</td><td style="text-align:center"></td><td style="text-align:center">大小为4×4的全零正方形</td></tr><tr><td style="text-align:center">1 2 3 3</td><td style="text-align:center"></td><td style="text-align:center">向(2,3)方格加入3名用户</td></tr><tr><td style="text-align:center">2 1 1 3 3</td><td style="text-align:center"></td><td style="text-align:center">查询矩形1&lt;=x&lt;=3,1&lt;=y&lt;=3内的用户数量</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">3</td><td style="text-align:center">查询结果</td></tr><tr><td style="text-align:center">1 2 2 2</td><td style="text-align:center"></td><td style="text-align:center">向(2,2)方格加入2名用户</td></tr><tr><td style="text-align:center">2 2 2 3 4</td><td style="text-align:center"></td><td style="text-align:center">查询矩形2&lt;=x&lt;=3,2&lt;=y&lt;=4内的用户数量</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">5</td><td style="text-align:center">查询结果</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center"></td><td style="text-align:center">终止程序</td></tr></tbody></table><p>【数据规模】</p><p>1&lt;=W&lt;=2000000<br>1&lt;=X1&lt;=X2&lt;=W<br>1&lt;=Y1&lt;=Y2&lt;=W<br>1&lt;=x,y&lt;=W<br>0&lt;A&lt;=10000<br>命令1不超过160000个。<br>命令2不超过10000个。  </p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define MAXN 800010#define MAXL 2000010struct Query{    int x, y, val, pos, id, opt;    bool operator&lt;(const Query a) const    {        if (x == a.x &amp;&amp; y == a.y)            return opt &lt; a.opt;        return x == a.x ? y &lt; a.y : x &lt; a.x;    }} Ask[MAXN], tmp[MAXN];int n, m, Ans[MAXN];class BIT{  public:    int _tree[MAXL];    BIT() { ; }#define lowbit(_) ((_) &amp; (-_))    void Update(int i, int val)    {        for (; i &lt;= n; i += lowbit(i))            _tree[i] += val;        return;    }    int Query(int i)    {        int _ans = 0;        for (; i; i -= lowbit(i))            _ans += _tree[i];        return _ans;    }} bit;void add(){    int x1, x2, y1, y2;    scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);    ++Ans[0];    Ask[++m].pos = Ans[0], Ask[m].x = x1 - 1, Ask[m].y = y1 - 1, Ask[m].val = 1, Ask[m].opt = 1;    Ask[++m].pos = Ans[0], Ask[m].x = x2, Ask[m].y = y2, Ask[m].val = 1, Ask[m].opt = 1;    Ask[++m].pos = Ans[0], Ask[m].x = x1 - 1, Ask[m].y = y2, Ask[m].val = -1, Ask[m].opt = 1;    Ask[++m].pos = Ans[0], Ask[m].x = x2, Ask[m].y = y1 - 1, Ask[m].val = -1, Ask[m].opt = 1;    return;}void CDQ(int l, int r){    if (l == r)        return;    int mid = l + r &gt;&gt; 1, l1 = l, l2 = mid + 1;    for (int i = l; i &lt;= r; i++)    {        if (Ask[i].id &lt;= mid &amp;&amp; !Ask[i].opt)            bit.Update(Ask[i].y, Ask[i].val);        if (Ask[i].id &gt; mid &amp;&amp; Ask[i].opt)            Ans[Ask[i].pos] += Ask[i].val * bit.Query(Ask[i].y);    }    for (int i = l; i &lt;= r; i++)        if (Ask[i].id &lt;= mid &amp;&amp; !Ask[i].opt)            bit.Update(Ask[i].y, -Ask[i].val);    for (int i = l; i &lt;= r; i++)    {        if (Ask[i].id &lt;= mid)            tmp[l1++] = Ask[i];        else            tmp[l2++] = Ask[i];    }    for (int i = l; i &lt;= r; i++)        Ask[i] = tmp[i];    CDQ(l, mid);    CDQ(mid + 1, r);    return;}int main(){    int c;    freopen(&quot;mokia.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;mokia.out&quot;, &quot;w&quot;, stdout);    scanf(&quot;%d%d&quot;, &amp;c, &amp;n);    while (1)    {        int op;        scanf(&quot;%d&quot;, &amp;op);        if (op == 1)        {            ++m;            scanf(&quot;%d%d%d&quot;, &amp;Ask[m].x, &amp;Ask[m].y, &amp;Ask[m].val);        }        else if (op == 2)        {            add();        }        else            break;    }    for (int i = 1; i &lt;= m; i++)        Ask[i].id = i;    sort(Ask + 1, Ask + m + 1);    CDQ(1, m);    for (int i = 1; i &lt;= Ans[0]; i++)        printf(&quot;%d\n&quot;, Ans[i]);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/07/26/41/#disqus_thread</comments>
    </item>
    
    <item>
      <title>COGS 2235 烤鸡翅</title>
      <link>https://blog.wildrage.xyz/2017/07/26/40/</link>
      <guid>https://blog.wildrage.xyz/2017/07/26/40/</guid>
      <pubDate>Wed, 26 Jul 2017 13:13:59 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;【题目描述】&quot;&gt;&lt;a href=&quot;#【题目描述】&quot; class=&quot;headerlink&quot; title=&quot;【题目描述】&quot;&gt;&lt;/a&gt;【题目描述】&lt;/h3&gt;&lt;p&gt;在焦作太行路上，有一家烤鸡翅的生意火爆。因为好吃，所以卖的特别好。排队的人就特别多，经常有很多人买不到鸡翅。&lt;br&gt;鸡翅会在每分钟烤出Xi个，每分钟也只会卖给一个客人，第i个客人需要买Yi个。因为生意火爆，老板可以选择在这分钟不卖给这个客人鸡翅，或者卖给这个顾客他需要的鸡翅， 如果现在剩余的鸡翅不够，那就肯定不能卖给这个客人。无论这个客人能否买到鸡翅，他必须离开队伍。&lt;br&gt;现在给定N分钟，且已经知道每分钟烤出的鸡翅个数Xi，也知道每个客人需要鸡翅的Yi个数，现在老板想知道，如何合理安排卖给与拒绝，最多可以满足多少人&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>在焦作太行路上，有一家烤鸡翅的生意火爆。因为好吃，所以卖的特别好。排队的人就特别多，经常有很多人买不到鸡翅。<br>鸡翅会在每分钟烤出Xi个，每分钟也只会卖给一个客人，第i个客人需要买Yi个。因为生意火爆，老板可以选择在这分钟不卖给这个客人鸡翅，或者卖给这个顾客他需要的鸡翅， 如果现在剩余的鸡翅不够，那就肯定不能卖给这个客人。无论这个客人能否买到鸡翅，他必须离开队伍。<br>现在给定N分钟，且已经知道每分钟烤出的鸡翅个数Xi，也知道每个客人需要鸡翅的Yi个数，现在老板想知道，如何合理安排卖给与拒绝，最多可以满足多少人<br><a id="more"></a></p><h3 id="【输入格式】"><a href="#【输入格式】" class="headerlink" title="【输入格式】"></a>【输入格式】</h3><p>第一行一个正整数N，表示有N分钟的时间卖鸡翅<br>第二行N个用空格隔开的整数 X1，X2……Xn，Xi表示第i分钟会有Xi个鸡翅烤出<br>第三行N个用空格隔开的整数Y1，Y2……Yn，Yi表示第i分钟的顾客需要Yi个鸡翅</p><h3 id="【输出格式】"><a href="#【输出格式】" class="headerlink" title="【输出格式】"></a>【输出格式】</h3><p>一个整数，表示最多可以满足买到鸡翅的人数。</p><h3 id="【样例输入】"><a href="#【样例输入】" class="headerlink" title="【样例输入】"></a>【样例输入】</h3><blockquote><p>6<br>2 2 1 2 1 0<br>1 2 2 3 4 4  </p></blockquote><h3 id="【样例输出】"><a href="#【样例输出】" class="headerlink" title="【样例输出】"></a>【样例输出】</h3><blockquote><p>3  </p></blockquote><h3 id="【数据范围】"><a href="#【数据范围】" class="headerlink" title="【数据范围】"></a>【数据范围】</h3><p>  50%  数据保证 N&lt;=1000<br>  100%  1&lt;=N&lt;=250000   Xi,Yi都在[0,10^9]范围内</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>能卖就卖<br>卖不了了如何以前有人买的数目比他多<br>那就不卖给以前的那个人了也就是收回来<br>可后悔的贪心，长见识了。<br>主要使用优先队列</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;int x[250005], y[250005];class comp{  public:    bool operator()(long long a, long long b)    {        return y[a] &lt; y[b];    }};priority_queue&lt;long long, vector&lt;long long&gt;, comp&gt; Q;int main(){    freopen(&quot;wing.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;wing.out&quot;, &quot;w&quot;, stdout);    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i++)        scanf(&quot;%d&quot;, &amp;x[i]);    for (int i = 1; i &lt;= n; i++)        scanf(&quot;%d&quot;, &amp;y[i]);    long long sum = 0;    for (int i = 1; i &lt;= n; i++)    {        sum += x[i];        if (sum &gt;= y[i])            sum -= y[i], Q.push(i);        else        {            if (!Q.empty())            {                if (y[Q.top()] &gt; y[i])                {                    sum += y[Q.top()];                    Q.pop();                    sum -= y[i];                    Q.push(i);                }            }        }    }    printf(&quot;%d\n&quot;, Q.size());}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/07/26/40/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 3668 [NOI2014] 起床困难综合症</title>
      <link>https://blog.wildrage.xyz/2017/07/26/39/</link>
      <guid>https://blog.wildrage.xyz/2017/07/26/39/</guid>
      <pubDate>Wed, 26 Jul 2017 13:03:23 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;21 世纪，许多人得了一种奇怪的病：起床困难综合症，其临床表现为：起床难，起床后精神不佳。作为一名青春阳光好少年，atm 一直坚持与起床困难综合症作斗争。通过研究相关文献，他找到了该病的发病原因：在深邃的太平洋海底中，出现了一条名为 drd 的巨龙，它掌握着睡眠之精髓，能随意延长大家的睡眠时间。正是由于 drd 的活动，起床困难综合症愈演愈烈，以惊人的速度在世界上传播。为了彻底消灭这种病，atm 决定前往海底，消灭这条恶龙。历经千辛万苦，atm 终于来到了 drd 所在的地方，准备与其展开艰苦卓绝的战斗。drd 有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。具体说来，drd 的防御战线由 n扇防御门组成。每扇防御门包括一个运算op和一个参数t，其中运算一定是OR,XOR,AND中的一种，参数则一定为非负整数。如果还未通过防御门时攻击力为x，则其通过这扇防御门后攻击力将变为x op t。最终drd 受到的伤害为对方初始攻击力x依次经过所有n扇防御门后转变得到的攻击力。由于atm水平有限，他的初始攻击力只能为0到m之间的一个整数（即他的初始攻击力只能在0,1,…,m中任选，但在通过防御门之后的攻击力不受 m的限制）。为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让 drd 受到最大的伤害，请你帮他计算一下，他的一次攻击最多能使 drd 受到多少伤害。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>21 世纪，许多人得了一种奇怪的病：起床困难综合症，其临床表现为：起床难，起床后精神不佳。作为一名青春阳光好少年，atm 一直坚持与起床困难综合症作斗争。通过研究相关文献，他找到了该病的发病原因：在深邃的太平洋海底中，出现了一条名为 drd 的巨龙，它掌握着睡眠之精髓，能随意延长大家的睡眠时间。正是由于 drd 的活动，起床困难综合症愈演愈烈，以惊人的速度在世界上传播。为了彻底消灭这种病，atm 决定前往海底，消灭这条恶龙。历经千辛万苦，atm 终于来到了 drd 所在的地方，准备与其展开艰苦卓绝的战斗。drd 有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。具体说来，drd 的防御战线由 n扇防御门组成。每扇防御门包括一个运算op和一个参数t，其中运算一定是OR,XOR,AND中的一种，参数则一定为非负整数。如果还未通过防御门时攻击力为x，则其通过这扇防御门后攻击力将变为x op t。最终drd 受到的伤害为对方初始攻击力x依次经过所有n扇防御门后转变得到的攻击力。由于atm水平有限，他的初始攻击力只能为0到m之间的一个整数（即他的初始攻击力只能在0,1,…,m中任选，但在通过防御门之后的攻击力不受 m的限制）。为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让 drd 受到最大的伤害，请你帮他计算一下，他的一次攻击最多能使 drd 受到多少伤害。<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行包含2个整数，依次为n,m，表示drd有n扇防御门，atm的初始攻击力为0到m之间的整数。接下来n行，依次表示每一扇防御门。每行包括一个字符串op和一个非负整数t，两者由一个空格隔开，且op在前，t在后，op表示该防御门所对应的操作， t表示对应的参数。n&lt;=10^5</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一行一个整数，表示atm的一次攻击最多使 drd 受到多少伤害。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>3 10<br>AND 5<br>OR 6<br>XOR 7  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>1  </p></blockquote><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><h4 id="【样例说明1】"><a href="#【样例说明1】" class="headerlink" title="【样例说明1】"></a>【样例说明1】</h4><p>atm可以选择的初始攻击力为0,1,…,10。</p><p>假设初始攻击力为4，最终攻击力经过了如下计算</p><p>4 AND 5 = 4</p><p>4 OR 6 = 6</p><p>6 XOR 7 = 1</p><p>类似的，我们可以计算出初始攻击力为1,3,5,7,9时最终攻击力为0，初始攻击力为0,2,4,6,8,10时最终攻击力为1，因此atm的一次攻击最多使 drd 受到的伤害值为1。</p><p>0&lt;=m&lt;=10^9</p><p>0&lt;=t&lt;=10^9  </p><p>一定为OR,XOR,AND 中的一种</p><h4 id="【运算解释】"><a href="#【运算解释】" class="headerlink" title="【运算解释】"></a>【运算解释】</h4><p>在本题中，选手需要先将数字变换为二进制后再进行计算。如果操作的两个数二进制长度不同，则在前补0至相同长度。OR为按位或运算，处理两个长度相同的二进制数，两个相应的二进制位中只要有一个为1，则该位的结果值为1，否则为0。XOR为按位异或运算，对等长二进制模式或二进制数的每一位执行逻辑异或操作。如果两个相应的二进制位不同（相异），则该位的结果值为1，否则该位为0。 AND 为按位与运算，处理两个长度相同的二进制数，两个相应的二进制位都为1，该位的结果值才为1，否则为0。</p><p>例如，我们将十进制数5与十进制数3分别进行OR，XOR 与 AND 运算，可以得到如下结果：</p><table><thead><tr><th style="text-align:center">OR</th><th style="text-align:center">XOR</th><th style="text-align:center">AND</th></tr></thead><tbody><tr><td style="text-align:center">0101 (十进制 5)</td><td style="text-align:center">0101 (十进制 5)</td><td style="text-align:center">0101 (十进制 5)</td></tr><tr><td style="text-align:center">OR 0011 (十进制 3)</td><td style="text-align:center">XOR 0011 (十进制 3)</td><td style="text-align:center">AND 0011 (十进制 3)</td></tr><tr><td style="text-align:center">= 0111 (十进制 7)</td><td style="text-align:center">= 0110 (十进制 6)</td><td style="text-align:center">= 0001 (十进制 1)</td></tr></tbody></table><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>贪心的考虑每一位<br>如果这一位为0能使结果的这一位为1在这一位一定是0<br>如果为1的话在高位一定比在低位优<br>所以如果这一位不能为0而1可以的话能为1则为1<br>否则为0  </p><p>代码打的很傻</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int a[100005], op[100005];int er[31][100005];int n, m;void to_two(int c, int j){    int i = 1;    while (c)    {        er[i][j] = (c &amp; 1);        i++, c &gt;&gt;= 1;    }}bool judge(int j, int c){    int ans = c;    for (int i = 1; i &lt;= n; i++)    {        if (op[i] == 1)            ans &amp;= er[j][i];        else if (op[i] == 2)            ans |= er[j][i];        else if (op[i] == 3)            ans ^= er[j][i];    }    return ans;}int main(){    //freopen(&quot;sleep.in&quot;,&quot;r&quot;,stdin);    //freopen(&quot;sleep.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    char c[10];    for (int i = 1; i &lt;= n; i++)    {        scanf(&quot;%s&quot;, c);        if (c[0] == &#39;A&#39;)            op[i] = 1;        else if (c[0] == &#39;O&#39;)            op[i] = 2;        else            op[i] = 3;        scanf(&quot;%d&quot;, &amp;a[i]);        to_two(a[i], i);    }    int ans = 0;    //printf(&quot;%d\n&quot;,ans);    for (int i = 29; i &gt; 0; i--)    {        if (judge(i, 0))            ;        else        {            if (judge(i, 1))                if ((ans | (1 &lt;&lt; (i - 1))) &lt;= m)                    ans |= (1 &lt;&lt; (i - 1));        }        //printf(&quot;%d\n&quot;,ans);    }    //printf(&quot;%d\n&quot;,ans);    for (int i = 1; i &lt;= n; i++)    {        if (op[i] == 1)            ans &amp;= a[i];        else if (op[i] == 2)            ans |= a[i];        else if (op[i] == 3)            ans ^= a[i];    }    printf(&quot;%d&quot;, ans);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/07/26/39/#disqus_thread</comments>
    </item>
    
    <item>
      <title>COGS 2421 简单的Treap</title>
      <link>https://blog.wildrage.xyz/2017/07/26/38/</link>
      <guid>https://blog.wildrage.xyz/2017/07/26/38/</guid>
      <pubDate>Wed, 26 Jul 2017 12:53:01 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;【题目描述】&quot;&gt;&lt;a href=&quot;#【题目描述】&quot; class=&quot;headerlink&quot; title=&quot;【题目描述】&quot;&gt;&lt;/a&gt;【题目描述】&lt;/h3&gt;&lt;p&gt;Treap是一种平衡二叉搜索树，除二叉搜索树的基本性质外，Treap还满足一个性质：&lt;br&gt;每个节点都有一个确定的优先级，且每个节点的优先级都比它的两个儿子小(即它的优先级满足堆性质)。&lt;br&gt;不难证明在节点的优先级都事先给定且互不相同时，对应的Treap有且仅有一个。&lt;br&gt;现在，给定n个数和每个数对应的优先级，求出对应的以数的大小作为二叉搜索树比较依据的Treap的先序遍历结果。&lt;br&gt;对先序遍历的定义是：先访问根节点，再访问左子树，最后访问右子树。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>Treap是一种平衡二叉搜索树，除二叉搜索树的基本性质外，Treap还满足一个性质：<br>每个节点都有一个确定的优先级，且每个节点的优先级都比它的两个儿子小(即它的优先级满足堆性质)。<br>不难证明在节点的优先级都事先给定且互不相同时，对应的Treap有且仅有一个。<br>现在，给定n个数和每个数对应的优先级，求出对应的以数的大小作为二叉搜索树比较依据的Treap的先序遍历结果。<br>对先序遍历的定义是：先访问根节点，再访问左子树，最后访问右子树。<br><a id="more"></a></p><h3 id="【输入格式】"><a href="#【输入格式】" class="headerlink" title="【输入格式】"></a>【输入格式】</h3><p>第一行一个数n表示数的个数。<br>第二行n个数表示每个数的大小。<br>第三行n个数表示每个数对应的优先级。</p><h3 id="【输出格式】"><a href="#【输出格式】" class="headerlink" title="【输出格式】"></a>【输出格式】</h3><p>一行n个数，表示Treap的先序遍历结果(对于每个节点，输出对应的数)。</p><h3 id="【样例输入】"><a href="#【样例输入】" class="headerlink" title="【样例输入】"></a>【样例输入】</h3><blockquote><p>7<br>2 11 5 9 1 4 3<br>2 10 1 8 4 6 5  </p></blockquote><h3 id="【样例输出】"><a href="#【样例输出】" class="headerlink" title="【样例输出】"></a>【样例输出】</h3><blockquote><p>5 2 1 3 4 9 11  </p></blockquote><h3 id="【样例解释】"><a href="#【样例解释】" class="headerlink" title="【样例解释】"></a>【样例解释】</h3><p>对应的Treap如图所示，其中圈内的数是给出的数，圈外的数是节点的优先级。<br><img src="http://ostb19hxn.bkt.clouddn.com/17-7-26/92869378.jpg" alt=""></p><h3 id="【数据范围】"><a href="#【数据范围】" class="headerlink" title="【数据范围】"></a>【数据范围】</h3><p>n&lt;=500000。<br>所有的数和优先级都互不相同且在int(C++)/longint(Pascal)范围内。</p><h3 id="【提示】"><a href="#【提示】" class="headerlink" title="【提示】"></a>【提示】</h3><p>为了给不想用栈模拟递归的孩纸们偷懒的机会，C++选手请在main函数的开头加入以下代码：</p><pre><code class="c++">int __size__=128&lt;&lt;20;char *__p__=(char*)malloc(__size__)+__size__;__asm__(&quot;movl %0, %%esp\n&quot;::&quot;r&quot;(__p__));</code></pre><p>注意上述代码会占用你128MB的空间，请自行调整代码。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>其实就是排序后用<a href="https://zh.wikipedia.org/wiki/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91" target="_blank" rel="noopener">笛卡尔树</a>建一颗树  </p><p>所以这道题是一道笛卡尔树的裸题</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class data{  public:    int v, key;    bool operator&lt;(const data &amp;a) const    {        return v &lt; a.v;    }} a[500005];class Node{  public:    Node *ch[2];    int key, v;    Node(data x)    {        key = x.key;        v = x.v;        ch[0] = ch[1] = NULL;    }    ~Node();} * st[500005];Node *build(int m){    Node *x, *last;    int p = 0;    for (int i = 1; i &lt;= m; i++)    {        x = new Node(a[i]);        last = NULL;        while (p &amp;&amp; st[p]-&gt;key &gt; x-&gt;key)        {            last = st[p];            st[p--] = NULL;        }        if (p)            st[p]-&gt;ch[1] = x;        x-&gt;ch[0] = last;        st[++p] = x;    }    return st[1];}void dfs(Node *a){    if (a)    {        printf(&quot;%d &quot;, a-&gt;v);        dfs(a-&gt;ch[0]);        dfs(a-&gt;ch[1]);    }}int main(){    int __size__ = 128 &lt;&lt; 20;    char *__p__ = (char *)malloc(__size__) + __size__;    __asm__(&quot;movl %0, %%esp\n&quot; ::&quot;r&quot;(__p__));    freopen(&quot;treap.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;treap.out&quot;,&quot;w&quot;,stdout);    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i++)        scanf(&quot;%d&quot;, &amp;a[i].v);    for (int i = 1; i &lt;= n; i++)        scanf(&quot;%d&quot;, &amp;a[i].key);    sort(a + 1, a + n + 1);    Node *rt = build(n);    dfs(rt);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/07/26/38/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 2818 GCD</title>
      <link>https://blog.wildrage.xyz/2017/07/26/37/</link>
      <guid>https://blog.wildrage.xyz/2017/07/26/37/</guid>
      <pubDate>Wed, 26 Jul 2017 12:21:12 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;给定整数N，求1&amp;lt;=x,y&amp;lt;=N且Gcd(x,y)为素数的&lt;br&gt;数对(x,y)有多少对.&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;一个整数N&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;如题&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给定整数N，求1&lt;=x,y&lt;=N且Gcd(x,y)为素数的<br>数对(x,y)有多少对.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>一个整数N</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>如题<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>4  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>4  </p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>$$ \sum_{d}{\sum_{i=1}^{n}{\sum_{j=1}^{n}[gcd(i,j)=d]}} $$</p><p>$$ = \sum_{d}{\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}{\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}{[gcd(i,j)=1]}}} $$</p><p>$$ = \sum_{T}{\lfloor\frac{n}{T}\rfloor \lfloor\frac{n}{T}\rfloor\sum_{d|T}{\mu(\frac{n}{T})}} $$<br>令 $f[i]=\sum_{d|T}^{} \mu(\frac{T}{d})$</p><p>然后线性筛</p><pre><code class="c++">#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int N = 10000000;int mu[N + 5], prime[N + 5], g[N + 5];long long sum[N + 5], cnt;bool isnprime[N + 5];void get_g(){    mu[1] = 1;    for (int i = 2; i &lt;= N; i++)    {        if (!isnprime[i])        {            prime[++cnt] = i;            mu[i] = -1;            g[i] = 1;        }        for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= N; j++)        {            isnprime[i * prime[j]] = 1;            if (i % prime[j])                mu[i * prime[j]] = -mu[i], g[i * prime[j]] = mu[i] - g[i];            else            {                mu[i * prime[j]] = 0;                g[i * prime[j]] = mu[i];                break;            }        }    }    for (int i = 1; i &lt;= N; i++)    {        sum[i] = sum[i - 1] + g[i];    }}int main(){    get_g();    int n;    scanf(&quot;%d&quot;, &amp;n);    long long ans = 0, last;    for (int i = 1; i &lt;= n; i = last + 1)    {        last = n / (n / i);        ans += (long long)(sum[last] - sum[i - 1]) * (n / i) * (n / i);    }    printf(&quot;%lld\n&quot;, ans);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/07/26/37/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 1500 [NOI2005] 维护数列 </title>
      <link>https://blog.wildrage.xyz/2017/07/15/36/</link>
      <guid>https://blog.wildrage.xyz/2017/07/15/36/</guid>
      <pubDate>Sat, 15 Jul 2017 07:56:21 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;【问题描述】&quot;&gt;&lt;a href=&quot;#【问题描述】&quot; class=&quot;headerlink&quot; title=&quot;【问题描述】&quot;&gt;&lt;/a&gt;【问题描述】&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://moetu.fastmirror.org/images/2017/08/02/564239476b322.gif&quot; alt=&quot;564239476b322.gif&quot;&gt;&lt;br&gt;题目链接&lt;br&gt;&lt;a href=&quot;http://www.lydsy.com/JudgeOnline/problem.php?id=1500&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ&lt;/a&gt; &lt;a href=&quot;http://cogs.pro/cogs/problem/problem.php?pid=339&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;COGS&lt;/a&gt;&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="【问题描述】"><a href="#【问题描述】" class="headerlink" title="【问题描述】"></a>【问题描述】</h3><p><img src="https://moetu.fastmirror.org/images/2017/08/02/564239476b322.gif" alt="564239476b322.gif"><br>题目链接<br><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1500" target="_blank" rel="noopener">BZOJ</a> <a href="http://cogs.pro/cogs/problem/problem.php?pid=339" target="_blank" rel="noopener">COGS</a><br><a id="more"></a></p><h3 id="【输入格式】"><a href="#【输入格式】" class="headerlink" title="【输入格式】"></a>【输入格式】</h3><p>输入文件的第 1 行包含两个数 N 和 M，N 表示初始时数列中数的个数，M表示要进行的操作数目。第 2 行包含 N 个数字，描述初始时的数列。以下 M 行，每行一条命令，格式参见问题描述中的表格。</p><h3 id="【输出格式】"><a href="#【输出格式】" class="headerlink" title="【输出格式】"></a>【输出格式】</h3><p>对于输入数据中的 GET-SUM 和 MAX-SUM 操作，向输出文件依次打印结果，每个答案（数字）占一行。</p><h3 id="【输入样例】"><a href="#【输入样例】" class="headerlink" title="【输入样例】"></a>【输入样例】</h3><blockquote><p>9 8<br>2 -6 3 5 1 -5 -3 6 3<br>GET-SUM 5 4<br>MAX-SUM<br>INSERT 8 3 -5 7 2<br>DELETE 12 1<br>MAKE-SAME 3 3 2<br>REVERSE 3 6<br>GET-SUM 5 4<br>MAX-SUM  </p></blockquote><h3 id="【输出样例】"><a href="#【输出样例】" class="headerlink" title="【输出样例】"></a>【输出样例】</h3><blockquote><p>-1<br>10<br>1<br>10  </p></blockquote><h3 id="【样例说明】"><a href="#【样例说明】" class="headerlink" title="【样例说明】"></a>【样例说明】</h3><p>初始时，我们拥有数列 2 -6 3 5 1 -5 -3 6 3<br>执行操作 GET-SUM 5 4，表示求出数列中从第 5 个数开始连续 4 个数字之和，1+(-5)+(-3)+6 = -1：</p><blockquote><p>2     -6     3      5      1     -5    -3     6      3</p></blockquote><p>执行操作 MAX-SUM，表示要求求出当前数列中最大的一段和，应为 3+5+1+(-5)+(-3)+6+3 = 10：</p><blockquote><p>2     -6     3      5      1     -5    -3     6      3</p></blockquote><p>执行操作 INSERT 8 3 -5 7 2，即在数列中第 8 个数字后插入-5 7 2，</p><blockquote><p>2     -6     3      5      1     -5    -3     6     -5     7      2      3</p></blockquote><p>执行操作 DELETE 12 1，表示删除第 12 个数字，即最后一个：</p><blockquote><p>2     -6     3      5      1     -5    -3     6     -5     7      2</p></blockquote><p>执行操作 MAKE-SAME 3 3 2，表示从第 3 个数开始的 3 个数字，统一修改为 2：</p><blockquote><p>2    -6    3    5    1    -5    -3    6    -5    7    2  </p></blockquote><p>改为</p><blockquote><p>2    -6    2    2    2    -5    -3    6    -5    7    2  </p></blockquote><p>执行操作 REVERSE 3 6，表示取出数列中从第 3 个数开始的连续 6 个数：</p><blockquote><p>2 -6 2 2 2 -5 -3 6 -5 7 2  </p></blockquote><p>如上所示的灰色部分 2 2 2 -5 -3 6，翻转后得到 6 -3 -5 2 2 2，并放回原来位置：  </p><blockquote><p>2 -6 6 -3 -5 2  2  2 -5 7  2  </p></blockquote><p>最后执行 GET-SUM 5 4 和 MAX-SUM，不难得到答案 1 和 10。</p><blockquote><p>2 -6 6 -3 -5 2 2 2 -5 7 2</p></blockquote><p>BZOJ 版<br><img src="http://ostb19hxn.bkt.clouddn.com/17-7-15/22527878.jpg" alt=""></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>本题要求维护 <em>动态连续最大连续和</em> 和 <em>区间和</em><br>所以要用 Max，和 Sum 来记录<br>类似线段树我们需要Pushdown和Pushup函数<br>此外对于Max 为了更新他的值，我们还需要维护两个变量<br>l，r 分别记录前缀最大和&amp;后缀最大和  </p><hr><h5 id="向上传递的"><a href="#向上传递的" class="headerlink" title="向上传递的"></a>向上传递的</h5><ul><li><p>对于一个节点更新Max时要分一下几种情况讨论  </p><ol><li>它的左儿子的Max  </li><li>它的右儿子的Max</li><li>它的左儿子的r加上本节点的权值v</li><li>它的右儿子的l加上本节点的权值v</li><li><p>它的左儿子的r加上本节点的权值v加上右儿子的l</p><p>用一张图来表示是这样的<img src="http://ostb19hxn.bkt.clouddn.com/17-7-15/11752870.jpg" alt="">  </p></li></ol></li><li><p>我们还需要维护一个节点的 l  与上面相似 要分三种情况</p><ol><li>它的左儿子的 l </li><li>它的左儿子的 sum 加上 本节点的权值v</li><li>它的左节点的 sum 加上 本节点的权值v 加上 他的右儿子的 l  </li></ol><p>用另一张张图来表示是这样的<img src="http://ostb19hxn.bkt.clouddn.com/17-7-15/95774098.jpg" alt=""></p></li><li><p>r与上面的相似</p><ol><li>它的右儿子的 r</li><li>它的右儿子的 sum 加上 本节点的权值v</li><li>它的右节点的 sum 加上 本节点的权值v 加上 他的左儿子的 r  </li></ol><p>不想画图了╭(╯^╰)╮</p></li><li>然后是Sum 直接加起来就好了</li></ul><h5 id="向下传递的"><a href="#向下传递的" class="headerlink" title="向下传递的"></a>向下传递的</h5><ul><li>首先是旋转标记<ol><li>直接下传然后交换左右儿子即可</li><li>注意异或的用法</li></ol></li><li><p>然后是修改标记</p><ol><li>首先你不能暴力修改 有一个点会超时，亲测</li><li>所以想线段树一样我们需要一个标记</li><li><p>下传时注意维护Max，sum，l，r 这些值</p><blockquote><p>对于Sum 直接乘就好  </p></blockquote><blockquote><p>对于Max,l,r 要分类讨论  </p><ol><li>如果改变的值为负数那这三个的值都未你改变成的值  </li><li>否则这等于Sum</li></ol></blockquote></li></ol></li><li><p>对于插入<br>  直接新建一颗树插进去就可以了</p><h4 id="最后一步-码代码-调程序"><a href="#最后一步-码代码-调程序" class="headerlink" title="最后一步 码代码 调程序"></a>最后一步 码代码 调程序</h4></li></ul><p>能Pushdown() 就Pushdown()<br>能Pushup() 就Pushup()  </p><p>fhq Treap 真好<br>如果打Splay 我会死的  </p><p>另外需要注意如果子树为空的返回值  </p><h4 id="链接们"><a href="#链接们" class="headerlink" title="链接们"></a>链接们</h4><p>fhq大佬 <a href="http://fanhq666.blog.163.com/blog/static/819434262011021105212299/" target="_blank" rel="noopener">挖掘Treap的潜力 - fanhq666的日志</a><br>我的板子来源<br><a href="http://memphis.is-programmer.com/posts/46317.html" target="_blank" rel="noopener">非旋转Treap及可持久化[Merge,Split]  Memphis’s Blog</a><br>附朋友的题解<br><a href="http://www.cnblogs.com/LadyLex/p/7182631.html" target="_blank" rel="noopener">[您有新的未分配科技点] 无旋treap：从单点到区间（例题 BZOJ1500&amp;NOI2005 维护数列 ）</a><br><a href="http://www.cnblogs.com/LadyLex/p/7182491.html" target="_blank" rel="noopener">[您有新的未分配科技点]无旋treap：从好奇到入门（例题：bzoj3224 普通平衡树）</a>  </p><h4 id="C-Code"><a href="#C-Code" class="headerlink" title="C++ Code"></a>C++ Code</h4><pre><code class="c++">/* * @Author: WildRage  * @Date: 2017-07-15 10:32:15  * @Last Modified by:   WildRage  * @Last Modified time: 2017-07-15 15:07:46  */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define INF 0x3f3f3f3fusing namespace std;struct Node{    int v, key, size, rev;    int Max, l, r, sum, change;    Node *ch[2];    Node(int x)    {        v = x;        key = rand();        size = 1;        rev = 0;        change = -INF;        Max = x;        l = x;        r = x;        sum = x;        ch[0] = ch[1] = NULL;    }#define size(_) ((_) ? (_)-&gt;size : (0))#define sum(_) ((_) ? (_)-&gt;sum : (0))#define l(_) ((_) ? (_)-&gt;l : (-INF))#define r(_) ((_) ? (_)-&gt;r : (-INF))#define Max(_) ((_) ? (_)-&gt;Max : (-INF))#define change(_) ((_) ? (_)-&gt;change : (-INF))    void Pushup()    {        size = 1 + size(ch[1]) + size(ch[0]);        l = max(l(ch[0]), max(sum(ch[0]) + v, sum(ch[0]) + v + l(ch[1])));        r = max(r(ch[1]), max(sum(ch[1]) + v, sum(ch[1]) + v + r(ch[0])));        Max = max(Max(ch[0]), max(Max(ch[1]), max(r(ch[0]) + v, max(l(ch[1]) + v, max(r(ch[0]) + l(ch[1]) + v, v)))));        sum = sum(ch[0]) + sum(ch[1]) + v;    }    void reverse()    {        if (!this)            return;        swap(ch[0], ch[1]);        swap(l, r);        rev ^= 1;    }    void Update()    {        if (!this)            return;        if (ch[1])            ch[1]-&gt;change = change;        if (ch[0])            ch[0]-&gt;change = change;        sum = size * change;        v=change;        l=r=Max=max(change,size*change);        //change = -INF;    }    void Pushdown()    {        if (!this)            return;        if (rev)        {            ch[0]-&gt;reverse();            ch[1]-&gt;reverse();            rev = 0;        }        if (change != -INF)        {            ch[0]-&gt;Update();            ch[1]-&gt;Update();            change=-INF;        }    }} * root;typedef pair&lt;Node *, Node *&gt; DNode;Node *Merge(Node *A, Node *B){    if (!A)        return B;    if (!B)        return A;    if (A-&gt;key &lt; B-&gt;key)    {        A-&gt;Pushdown();        A-&gt;ch[1] = Merge(A-&gt;ch[1], B);        A-&gt;Pushup();        return A;    }    else    {        B-&gt;Pushdown();        B-&gt;ch[0] = Merge(A, B-&gt;ch[0]);        B-&gt;Pushup();        return B;    }}DNode Split(Node *rt, int k){    if (!rt)        return DNode(NULL, NULL);    DNode o;    rt-&gt;Pushdown();    if (size(rt-&gt;ch[0]) &gt;= k)    {        o = Split(rt-&gt;ch[0], k);        rt-&gt;ch[0] = o.second;        rt-&gt;Pushup();        o.second = rt;    }    else    {        o = Split(rt-&gt;ch[1], k - size(rt-&gt;ch[0]) - 1);        rt-&gt;ch[1] = o.first;        rt-&gt;Pushup();        o.first = rt;    }    return o;}Node *st[4000005];Node *build(int m){    //memset(st, 0, sizeof(st));    Node *x, *last;    int p = 0;    int a;    for (int i = 1; i &lt;= m; i++)    {        scanf(&quot;%d&quot;, &amp;a);        x = new Node(a);        last = NULL;        while (p &amp;&amp; st[p]-&gt;key &gt; x-&gt;key)        {            st[p]-&gt;Pushup();            last = st[p];            st[p--] = NULL;        }        if (p)            st[p]-&gt;ch[1] = x;        x-&gt;ch[0] = last;        st[++p] = x;    }    while (p)        st[p--]-&gt;Pushup();    return st[1];}Node *kth(int k){    DNode x = Split(root, k - 1);    DNode y = Split(x.second, 1);    Node *ans = y.first;    root = Merge(Merge(x.first, ans), y.second);    return ans;}int Rank(Node *rt, int x){    if (!rt)        return 0;    return x &lt;= rt-&gt;v ? Rank(rt-&gt;ch[0], x) : Rank(rt-&gt;ch[1], x) + size(rt-&gt;ch[0]) + 1;}void Insert(int x){    int k = Rank(root, x);    DNode y = Split(root, k);    Node *n = new Node(x);    root = Merge(Merge(y.first, n), y.second);}void remove(int x){    int k = Rank(root, x);    DNode a = Split(root, k);    DNode b = Split(a.second, 1);    root = Merge(a.first, b.second);}void flip(int i, int m){    DNode x = Split(root, i - 1);    DNode y = Split(x.second, m);    y.first-&gt;reverse();    root = Merge(x.first, Merge(y.first, y.second));}void dfs(Node *rt){    if (rt)    {        rt-&gt;Pushdown();        dfs(rt-&gt;ch[0]);        printf(&quot;%d &quot;, rt-&gt;v);        dfs(rt-&gt;ch[1]);    }}void Insert(int i, int tot){    Node *x = build(tot);    DNode y = Split(root, i);    root = Merge(y.first, Merge(x, y.second));}void rmdfs(Node *rt){    if (rt)    {        rmdfs(rt-&gt;ch[0]);        rmdfs(rt-&gt;ch[1]);    }    delete rt;}void remove(int i, int tot){    DNode x = Split(root, i - 1);    DNode y = Split(x.second, tot);    rmdfs(y.first);    root = Merge(x.first, y.second);}void Update(int i, int tot, int c){    DNode x = Split(root, i - 1);    DNode y = Split(x.second, tot);    y.first-&gt;change = c;    y.first-&gt;Update();    //Node *m = build(tot, c);    //rmdfs(y.first);    root = Merge(x.first, Merge(y.first, y.second));}int get_sum(int i, int tot){    DNode x = Split(root, i - 1);    DNode y = Split(x.second, tot);    int ans = sum(y.first);    root = Merge(x.first, Merge(y.first, y.second));    return ans;}int Max_Sum(){    return Max(root);}int main(){    //freopen(&quot;seq2005.in&quot;, &quot;r&quot;, stdin);    //freopen(&quot;seq2005.out&quot;, &quot;w&quot;, stdout);    int n, m;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    root = build(n);    //dfs(root);    //printf(&quot;----------------------\n&quot;);    int l, r, c;    char s[16];    for (int i = 1; i &lt;= m; i++)    {        scanf(&quot;%s&quot;, s);        switch (s[0])        {        case &#39;G&#39;:            scanf(&quot;%d%d&quot;, &amp;l, &amp;r);            printf(&quot;%d\n&quot;, get_sum(l, r));            break;        case &#39;D&#39;:            scanf(&quot;%d%d&quot;, &amp;l, &amp;r);            remove(l, r);            break;        case &#39;I&#39;:            scanf(&quot;%d%d&quot;, &amp;l, &amp;r);            Insert(l, r);            break;        case &#39;R&#39;:            scanf(&quot;%d%d&quot;, &amp;l, &amp;r);            flip(l, r);            break;        case &#39;M&#39;:            if (s[2] == &#39;K&#39;)            {                scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;c);                Update(l, r, c);            }            else            {                printf(&quot;%d\n&quot;, Max_Sum());            }        }        //printf(&quot;--------------------------------\n&quot;);        //dfs(root);        //printf(&quot;\n-----------DONE-----------------\n&quot;);    }    //while (1)    ;}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/07/15/36/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 1875 [SDOI2009]HH去散步 矩阵乘</title>
      <link>https://blog.wildrage.xyz/2017/07/13/35/</link>
      <guid>https://blog.wildrage.xyz/2017/07/13/35/</guid>
      <pubDate>Thu, 13 Jul 2017 10:00:56 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;Made-by-WZZ&quot;&gt;&lt;a href=&quot;#Made-by-WZZ&quot; class=&quot;headerlink&quot; title=&quot;Made by WZZ&quot;&gt;&lt;/a&gt;Made by WZZ&lt;/h1&gt;&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;HH有个一成不变的习惯，喜欢饭后百步走。所谓百步走，就是散步，就是在一定的时间 内，走过一定的距离。 但&lt;br&gt;是同时HH又是个喜欢变化的人，所以他不会立刻沿着刚刚走来的路走回。 又因为HH是个喜欢变化的人，所以他每&lt;br&gt;天走过的路径都不完全一样，他想知道他究竟有多 少种散步的方法。 现在给你学校的地图（假设每条路的长度都&lt;br&gt;是一样的都是1），问长度为t，从给定地 点A走到给定地点B共有多少条符合条件的路径&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Made-by-WZZ"><a href="#Made-by-WZZ" class="headerlink" title="Made by WZZ"></a>Made by WZZ</h1><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>HH有个一成不变的习惯，喜欢饭后百步走。所谓百步走，就是散步，就是在一定的时间 内，走过一定的距离。 但<br>是同时HH又是个喜欢变化的人，所以他不会立刻沿着刚刚走来的路走回。 又因为HH是个喜欢变化的人，所以他每<br>天走过的路径都不完全一样，他想知道他究竟有多 少种散步的方法。 现在给你学校的地图（假设每条路的长度都<br>是一样的都是1），问长度为t，从给定地 点A走到给定地点B共有多少条符合条件的路径<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行：五个整数N，M，t，A，B。<br>N表示学校里的路口的个数<br>M表示学校里的 路的条数<br>t表示HH想要散步的距离<br>A表示散步的出发点<br>B则表示散步的终点。<br>接下来M行<br>每行一组Ai，Bi，表示从路口Ai到路口Bi有一条路。<br>数据保证Ai ！= Bi,但不保证任意两个路口之间至多只有一条路相连接。<br>路口编号从0到N -1。<br>同一行内所有数据均由一个空格隔开，行首行尾没有多余空格。没有多余空行。<br>答案模45989。<br>N ≤ 20，M ≤ 60，t ≤ 2^30，0 ≤ A,B  </p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一行，表示答案。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>4 5 3 0 0<br>0 1<br>0 2<br>0 3<br>2 1<br>3 2  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>4  </p></blockquote><p>这道题是一道矩阵乘的题<br>通常我们用矩阵乘表示 点a 到 点b<br>$$<br>    \begin{matrix}<br>    1 &amp; 2 &amp; 3 &amp; 4 &amp; ….. &amp; N-1 &amp; N \<br>    \end{matrix}<br>$$<br>1 2 3 4 …..N-1 N<br>1-1 1-2 …. N-1<br>2-1 2-2 …. N-2<br>3-1 3-2 …. N-3<br>… … …. …<br>N-1 N-2 …. N-N  </p><p>乘之后便为到 i点的方案数<br>但这道题有不能重复走边的限制<br>我们便巧妙地用矩阵储存边<br>边 i 能到达 边 j的条件为 edge[i].to==edge[j].from(即相连)<br>但 i不能到达i+1条边（i为偶数） 所以a[i][i+1]=0;<br>再循环找满足条件即可  </p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define mod 45989using namespace std;int n, m, t, size, head[25], began, endd, x, y;int a[160][160], ans[160][160], tot;struct node{    int from, to, next;} edge[400];void add(int from, int to){    edge[++size].from = from;    edge[size].to = to;    edge[size].next = head[from];    head[from] = size;}void cheng(int a[160][160], int b[160][160], int to[160][160]){    int tmp[160][160] = {0};    for (int i = 1; i &lt;= size; i++)        for (int j = 1; j &lt;= size; j++)            for (int u = 1; u &lt;= size; u++)                tmp[i][j] = (tmp[i][j] + a[i][u] * b[u][j] % mod) % mod;    for (int i = 1; i &lt;= size; i++)        for (int j = 1; j &lt;= size; j++)            to[i][j] = tmp[i][j];}void dp(){    while (t)    {        if (t &amp; 1)            cheng(a, ans, ans);        t = t &gt;&gt; 1;        cheng(a, a, a);    }    for (int i = 1; i &lt;= size; i++)        if (edge[i].to == endd)            for (int j = 1; j &lt;= size; j++)                if (edge[j].from == began)                    tot = (tot + ans[j][i]) % mod;}int main(){    scanf(&quot;%d%d%d%d%d&quot;, &amp;n, &amp;m, &amp;t, &amp;began, &amp;endd);    began++, endd++;    for (int i = 1; i &lt;= m; i++)    {        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);        x++, y++;        add(x, y);        add(y, x);    }    for (int i = 1; i &lt;= size; i++)        for (int j = 1; j &lt;= size; j++)            if (edge[i].to == edge[j].from)                a[i][j] = 1;    for (int i = 1; i &lt;= size; i += 2)        a[i][i + 1] = a[i + 1][i] = 0;    for (int i = 1; i &lt;= size; i++)        ans[i][i] = 1;    t--;    dp();    printf(&quot;%d&quot;, tot);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/07/13/35/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 3038 上帝造题的七分钟2 线段树</title>
      <link>https://blog.wildrage.xyz/2017/07/13/34/</link>
      <guid>https://blog.wildrage.xyz/2017/07/13/34/</guid>
      <pubDate>Thu, 13 Jul 2017 09:31:56 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;XLk觉得《上帝造题的七分钟》不太过瘾，于是有了第二部。&lt;br&gt;“第一分钟，X说，要有数列，于是便给定了一个正整数数列。&lt;br&gt;第二分钟，L说，要能修改，于是便有了对一段数中每个数都开平方(下取整)的操作。&lt;br&gt;第三分钟，k说，要能查询，于是便有了求一段数的和的操作。&lt;br&gt;第四分钟，彩虹喵说，要是noip难度，于是便有了数据范围。&lt;br&gt;第五分钟，诗人说，要有韵律，于是便有了时间限制和内存限制。&lt;br&gt;第六分钟，和雪说，要省点事，于是便有了保证运算过程中及最终结果均不超过64位有符号整数类型的表示范围的限制。&lt;br&gt;第七分钟，这道题终于造完了，然而，造题的神牛们再也不想写这道题的程序了。”&lt;br&gt;——《上帝造题的七分钟·第二部》&lt;br&gt;所以这个神圣的任务就交给你了。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>XLk觉得《上帝造题的七分钟》不太过瘾，于是有了第二部。<br>“第一分钟，X说，要有数列，于是便给定了一个正整数数列。<br>第二分钟，L说，要能修改，于是便有了对一段数中每个数都开平方(下取整)的操作。<br>第三分钟，k说，要能查询，于是便有了求一段数的和的操作。<br>第四分钟，彩虹喵说，要是noip难度，于是便有了数据范围。<br>第五分钟，诗人说，要有韵律，于是便有了时间限制和内存限制。<br>第六分钟，和雪说，要省点事，于是便有了保证运算过程中及最终结果均不超过64位有符号整数类型的表示范围的限制。<br>第七分钟，这道题终于造完了，然而，造题的神牛们再也不想写这道题的程序了。”<br>——《上帝造题的七分钟·第二部》<br>所以这个神圣的任务就交给你了。<br><a id="more"></a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行一个整数n，代表数列中数的个数。<br>第二行n个正整数，表示初始状态下数列中的数。<br>第三行一个整数m，表示有m次操作。<br>接下来m行每行三个整数k,l,r，k=0表示给[l,r]中的每个数开平方(下取整)，k=1表示询问[l,r]中各个数的和。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于询问操作，每行输出一个回答。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>10<br>1 2 3 4 5 6 7 8 9 10<br>5<br>0 1 10<br>1 1 10<br>1 1 5<br>0 5 8<br>1 4 8  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>19<br>7<br>6  </p></blockquote><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>1：对于100%的数据，1&lt;=n&lt;=100000，1&lt;=l&lt;=r&lt;=n，数列中的数大于0，且不超过1e12。<br>2：数据不保证L&lt;=R 若L&gt;R，请自行交换L,R，谢谢！</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>线段树 去修改就可以了<br>区间为1后就不用改了<br>很暴力的  </p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;#define LL long long#define lch l, m, rt &lt;&lt; 1#define rch m + 1, r, rt &lt;&lt; 1 | 1const int N = 100005;LL Min[N &lt;&lt; 2], Max[N &lt;&lt; 2], Sum[N &lt;&lt; 2];int Sqr[N &lt;&lt; 2];void Pushup(int rt){    Min[rt] = min(Min[rt &lt;&lt; 1], Min[rt &lt;&lt; 1 | 1]);    Max[rt] = max(Max[rt &lt;&lt; 1], Max[rt &lt;&lt; 1 | 1]);    if (Sum[rt &lt;&lt; 1] != -1 &amp;&amp; Sum[rt &lt;&lt; 1 | 1] != -1)        Sum[rt] = Sum[rt &lt;&lt; 1] + Sum[rt &lt;&lt; 1 | 1];    else        Sum[rt] = -1;}void Pushdown(int rt, int s){    if (Sqr[rt])    {        Sqr[rt &lt;&lt; 1] += Sqr[rt];        Sqr[rt &lt;&lt; 1 | 1] += Sqr[rt];        Sum[rt &lt;&lt; 1] = Sum[rt &lt;&lt; 1 | 1] = -1;        if (Max[rt &lt;&lt; 1] &gt; 1)            for (int i = 1; i &lt;= Sqr[rt]; i++)            {                Max[rt &lt;&lt; 1] = sqrt(Max[rt &lt;&lt; 1]);                Min[rt &lt;&lt; 1] = sqrt(Min[rt &lt;&lt; 1]);                if (Max[rt &lt;&lt; 1] == 1)                    break;            }        if (Max[rt &lt;&lt; 1 | 1] &gt; 1)            for (int i = 1; i &lt;= Sqr[rt]; i++)            {                Max[rt &lt;&lt; 1 | 1] = sqrt(Max[rt &lt;&lt; 1 | 1]);                Min[rt &lt;&lt; 1 | 1] = sqrt(Min[rt &lt;&lt; 1 | 1]);                if (Max[rt &lt;&lt; 1 | 1] == 1)                    break;            }        if (Max[rt &lt;&lt; 1 | 1] == Min[rt &lt;&lt; 1 | 1])            Sum[rt &lt;&lt; 1 | 1] = Max[rt &lt;&lt; 1 | 1] * (s &gt;&gt; 1);        if (Max[rt &lt;&lt; 1] == Min[rt &lt;&lt; 1])            Sum[rt &lt;&lt; 1] = Max[rt &lt;&lt; 1] * (s - (s &gt;&gt; 1));        Sqr[rt] = 0;    }}void buildtree(int l, int r, int rt){    if (l == r)    {        scanf(&quot;%lld&quot;, &amp;Min[rt]);        Sum[rt] = Max[rt] = Min[rt];        return;    }    int m = l + r &gt;&gt; 1;    buildtree(lch);    buildtree(rch);    Pushup(rt);}void Update(int L, int R, int l, int r, int rt){    if (L &lt;= l &amp;&amp; R &gt;= r)    {        Sqr[rt] += 1;        Max[rt] = sqrt(Max[rt]), Min[rt] = sqrt(Min[rt]);        Sum[rt] = -1;        if (Max[rt] == Min[rt])            Sum[rt] = Max[rt] * (r - l + 1);        return;    }    Sum[rt] = -1;    Pushdown(rt, r - l + 1);    int m = l + r &gt;&gt; 1;    if (L &lt;= m)        Update(L, R, lch);    if (R &gt; m)        Update(L, R, rch);    Pushup(rt);}LL Query(int L, int R, int l, int r, int rt){    if (L &lt;= l &amp;&amp; R &gt;= r)    {        if (Max[rt] == Min[rt])        {            return Sum[rt] = Max[rt] * (r - l + 1);        }        if (Sum[rt] != -1)            return Sum[rt];    }    Pushdown(rt, r - l + 1);    LL ans = 0;    int m = l + r &gt;&gt; 1;    if (L &lt;= m)        ans += Query(L, R, lch);    if (R &gt; m)        ans += Query(L, R, rch);    return ans;    Pushup(rt);}void print(int l, int r, int rt){    printf(&quot;l=%d,r=%d,rt=%d,Sum[rt]=%lld\n&quot;, l, r, rt, Sum[rt]);    if (l == r)        return;    int m = l + r &gt;&gt; 1;    print(lch);    print(rch);}int main(){    int n, m;    //freopen(&quot;god.in&quot;, &quot;r&quot;, stdin);   // freopen(&quot;god.out&quot;, &quot;w&quot;, stdout);    scanf(&quot;%d&quot;, &amp;n);    buildtree(1, n, 1);    scanf(&quot;%d&quot;, &amp;m);    int op, l, r;    for (int i = 1; i &lt;= m; i++)    {        scanf(&quot;%d%d%d&quot;, &amp;op, &amp;l, &amp;r);        if (l &gt; r)            swap(l, r);        if (op)        {            printf(&quot;%lld\n&quot;, Query(l, r, 1, n, 1));        }        else        {            Update(l, r, 1, n, 1);        }    }#ifdef Mine    //while (1)        ;#endif}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/07/13/34/#disqus_thread</comments>
    </item>
    
    <item>
      <title>String STL set map Trie</title>
      <link>https://blog.wildrage.xyz/2017/07/11/33/</link>
      <guid>https://blog.wildrage.xyz/2017/07/11/33/</guid>
      <pubDate>Tue, 11 Jul 2017 08:09:42 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;硬盘中里面有n个文件，文件从1到n标号，每个文件可以用若干个数字序列来表示，而且每个文件存在一个重要值。现在请你完成一个搜索系统，有m&lt;br&gt;个搜索的操作，如果一个文件中有以这个数字序列为前缀的数字序列，那么这个文件会被搜索到，现在我们想知道会有多少个文件被搜索到，以及这&lt;br&gt;些文件中重要值前k小的是哪些。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>硬盘中里面有n个文件，文件从1到n标号，每个文件可以用若干个数字序列来表示，而且每个文件存在一个重要值。现在请你完成一个搜索系统，有m<br>个搜索的操作，如果一个文件中有以这个数字序列为前缀的数字序列，那么这个文件会被搜索到，现在我们想知道会有多少个文件被搜索到，以及这<br>些文件中重要值前k小的是哪些。<br><a id="more"></a></p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第一行两个数n,m。<br>接下来n行是对每个文件的描述（标号依次是1到n）：<br>每行的前两个数字分别为描述这个文件的数字序列个数t和文件的重要值v。<br>接下来有t组数。<br>每组数先有一个数l，表示这个数字序列的长度。<br>接下来有l个数，表示这个序列。<br>接下来m行表示m个搜索操作：<br>每行的前两个数字分别为搜索数k和前缀长度l。<br>接下来l个数是这个前缀的数字序列。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>共m行。<br>每行来表示搜索的结果：<br>首先你需要输出有多少个文件会被搜索到。<br>接下来你需要输出k个数，依次是重要值前k小的标号（根据重要值由小到大输出，重要值相同时，标号小的排在前面）。<br>如果搜索到的文件数p比k小，那么你只需要输出p个,如果没有搜索到文件就不用输出了。  </p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>5 5<br>1 1 5 1 2 3 4 5<br>1 2 5 1 2 4 5 3<br>1 8 5 2 1 4 3 2<br>1 9 5 2 1 8 5 2<br>1 1 5 1 2 3 4 5<br>2 2 1 2<br>3 2 1 2<br>4 2 1 2<br>4 2 2 1<br>1 2 2 1  </p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>3 1 5<br>3 1 5 2<br>3 1 5 2<br>2 3 4<br>2 3    </p></blockquote><h3 id="数据范围和约定"><a href="#数据范围和约定" class="headerlink" title="数据范围和约定"></a>数据范围和约定</h3><ul><li>对于20%的数据<br>0&lt;n,m&lt;=50<br>每次询问k无限制<br>0&lt;重要值&lt;=10^9<br>0&lt;数字序列中的数字&lt;=10<br>所有文件数字序列长度之和&lt;=500<br>所有询问前缀数字序列长度之和&lt;=500  </li><li>对于另外20%的数据<br>0&lt;n,m&lt;=50<br>每次询问k无限制<br>0&lt;重要值&lt;=10^9<br>0&lt;数字序列中的数字&lt;=10^9<br>所有文件数字序列长度之和&lt;=500<br>所有询问前缀数字序列长度之和&lt;=500  </li><li>对于另外20%的数据<br>0&lt;n,m&lt;=5<em>10^4<br>每次询问k=1或k=2<br>0&lt;重要值&lt;=10^9<br>0&lt;数字序列中的数字&lt;=10<br>所有文件数字序列长度之和&lt;=2</em>10^5<br>所有询问前缀数字序列长度之和&lt;=2*10^5  </li><li>对于剩下的数据<br>0&lt;n,m&lt;=5<em>10^4<br>每次询问k无限制<br>0&lt;重要值&lt;=10^9<br>0&lt;数字序列中的数字&lt;=10^9<br>所有文件数字序列长度之和&lt;=2</em>10^5<br>所有询问前缀数字序列长度之和&lt;=2*10^5  </li></ul><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;ctime&gt;using namespace std;vector&lt;int&gt; l;struct Improtant{    int i, Imp;    bool operator&lt;(const Improtant &amp;a) const    {        return Imp == a.Imp ? i &lt; a.i : Imp &lt; a.Imp;    }} number[50005];struct Trie{    map&lt;int, Trie *&gt; mp;    set&lt;Improtant&gt; mark;} * root;void insert(int x){    Trie *rt = root;    rt-&gt;mark.insert(number[x]);    for (int i = 0; i &lt; l.size(); i++)    {        if (!rt-&gt;mp[l[i]])            rt-&gt;mp[l[i]] = new Trie;        rt = rt-&gt;mp[l[i]];        rt-&gt;mark.insert(number[x]);    }}void Query(int k){    Trie *rt = root;    for (int i = 0; i &lt; l.size(); i++)    {        if (rt-&gt;mp[l[i]] == NULL)        {            printf(&quot;0\n&quot;);            return;        }        rt = rt-&gt;mp[l[i]];    }    set&lt;Improtant&gt;::iterator it = rt-&gt;mark.begin();    printf(&quot;%d &quot;, rt-&gt;mark.size());    for (int i = 1; i &lt;= k &amp;&amp; it != rt-&gt;mark.end(); i++, it++)    {        printf(&quot;%d &quot;, it-&gt;i);    }    printf(&quot;\n&quot;);    return;}int main(){#ifdef Mine    freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);#else    freopen(&quot;string.in&quot;, &quot;r&quot;, stdin);#endif    freopen(&quot;string.out&quot;, &quot;w&quot;, stdout);    int n, m;    root = new Trie;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    int t, s, a;    for (int i = 1; i &lt;= n; i++)    {        number[i].i = i;        scanf(&quot;%d%d&quot;, &amp;t, &amp;number[i].Imp);        while (t--)        {            scanf(&quot;%d&quot;, &amp;s);            l.clear();            for (int j = 1; j &lt;= s; j++)            {                scanf(&quot;%d&quot;, &amp;a);                l.push_back(a);            }            insert(i);        }    }    int k;    for (int i = 1; i &lt;= m; i++)    {        scanf(&quot;%d%d&quot;, &amp;k, &amp;s);        l.clear();        for (int j = 1; j &lt;= s; j++)        {            scanf(&quot;%d&quot;, &amp;a);            l.push_back(a);        }        Query(k);    }    //printf(&quot;%lf&quot;,(double)clock()/CLOCKS_PER_SEC);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/07/11/33/#disqus_thread</comments>
    </item>
    
    <item>
      <title>数学</title>
      <link>https://blog.wildrage.xyz/2017/07/10/32/</link>
      <guid>https://blog.wildrage.xyz/2017/07/10/32/</guid>
      <pubDate>Mon, 10 Jul 2017 07:52:42 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;组合数&quot;&gt;&lt;a href=&quot;#组合数&quot; class=&quot;headerlink&quot; title=&quot;组合数&quot;&gt;&lt;/a&gt;组合数&lt;/h2&gt;&lt;p&gt;$$ C(n,k)=\frac {n!} {(n-k)!k!} $$&lt;br&gt;$$ 0!=1 $$&lt;/p&gt;
&lt;p&gt;$$ x^{p} m
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><p>$$ C(n,k)=\frac {n!} {(n-k)!k!} $$<br>$$ 0!=1 $$</p><p>$$ x^{p} mod p=x mod p $$<br>$$ x^{p-2} * x % p=1; $$</p>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/07/10/32/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 2120 数颜色 </title>
      <link>https://blog.wildrage.xyz/2017/07/09/31/</link>
      <guid>https://blog.wildrage.xyz/2017/07/09/31/</guid>
      <pubDate>Sun, 09 Jul 2017 12:45:16 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;墨墨购买了一套N支彩色画笔（其中有些颜色可能相同），摆成一排，你需要回答墨墨的提问。墨墨会像你发布如下指令： 1、 Q L R代表询问你从第L支画笔到第R支画笔中共有几种不同颜色的画笔。 2、 R P Col 把第P支画笔替换为颜色Col。为了满足墨墨的要求，你知道你需要干什么了吗？&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>墨墨购买了一套N支彩色画笔（其中有些颜色可能相同），摆成一排，你需要回答墨墨的提问。墨墨会像你发布如下指令： 1、 Q L R代表询问你从第L支画笔到第R支画笔中共有几种不同颜色的画笔。 2、 R P Col 把第P支画笔替换为颜色Col。为了满足墨墨的要求，你知道你需要干什么了吗？<br><a id="more"></a>  </p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第1行两个整数N，M，分别代表初始画笔的数量以及墨墨会做的事情的个数。第2行N个整数，分别代表初始画笔排中第i支画笔的颜色。第3行到第2+M行，每行分别代表墨墨会做的一件事情，格式见题干部分。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>对于每一个Query的询问，你需要在对应的行中给出一个数字，代表第L支画笔到第R支画笔中共有几种不同颜色的画笔。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>6 5<br>1 2 3 4 5 5<br>Q 1 4<br>Q 2 6<br>R 1 2<br>Q 1 4<br>Q 2 6  </p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><p>4<br>4<br>3<br>4  </p><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>对于100%的数据，N≤10000，M≤10000，修改操作不多于1000次，所有的输入数据中出现的所有整数均大于等于1且不超过10^6。<br>2016.3.2新加数据两组by Nano_Ape</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>计算出 i 的 前一个出现的位置<br>然后就和教主的魔法一样了<br>注意数组大小</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;int comp(int a, int b){    return a &gt; b;}using namespace std;int pre[10005], front[1000005];int in[10005];int a[10005], b[10005];int n, block;void build(int x){    for (int i = (x - 1) * block + 1; i &lt;= min(x * block, n); i++)    {        pre[i] = b[i];    }    sort(pre + (x - 1) * block + 1, pre + min(x * block + 1, n + 1));}void rebuild(int k, int x){    for (int i = 1; i &lt;= n; i++)        front[a[i]] = 0;    a[k] = x;    for (int i = 1; i &lt;= n; i++)    {        int ls = b[i];        b[i] = front[a[i]];        if (ls != b[i])            build(in[i]);        front[a[i]] = i;    }}int query(int c, int x){    int l = (x - 1) * block + 1, r = min(n, x * block);    int head = l;    while (l &lt;= r)    {        int m = (l + r) &gt;&gt; 1;        if (pre[m] &lt; c)            l = m + 1;        else            r = m - 1;    }    return l - head;}int Query(int l, int r){    int ans = 0;    if (in[l] == in[r])    {        for (int i = l; i &lt;= r; i++)            if (b[i] &lt; l)                ans++;    }    else    {        for (int i = l; i &lt;= min(block * in[l], n); i++)            if (b[i] &lt; l)                ans++;        for (int i = block * (in[r] - 1) + 1; i &lt;= r; i++)            if (b[i] &lt; l)                ans++;    }    for (int i = in [l] + 1; i &lt; in[r]; i++)        ans += query(l, i);    return ans;}int main(){    //freopen(&quot;nt2011_color.in&quot;,&quot;r&quot;,stdin);    //freopen(&quot;nt2011_color.out&quot;,&quot;w&quot;,stdout);    //freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);    int m;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    block = sqrt(n);    for (int i = 1; i &lt;= n; i++)    {        scanf(&quot;%d&quot;, &amp;a[i]);        b[i] = front[a[i]];        front[a[i]] = i;        in[i] = (i - 1) / block + 1;    }    int tot = in[n];    for (int i = 1; i &lt;= tot; i++)        build(i);    char s[10];    int l, r;    while (m--)    {        scanf(&quot;%s&quot;, s);        if (s[0] == &#39;Q&#39;)        {            scanf(&quot;%d%d&quot;, &amp;l, &amp;r);            printf(&quot;%d\n&quot;, Query(l, r));        }        else        {            scanf(&quot;%d%d&quot;, &amp;l, &amp;r);            rebuild(l, r);        }    }}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/07/09/31/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 2724 [Violet 6] 蒲公英</title>
      <link>https://blog.wildrage.xyz/2017/07/09/30/</link>
      <guid>https://blog.wildrage.xyz/2017/07/09/30/</guid>
      <pubDate>Sun, 09 Jul 2017 12:36:54 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://moetu.fastmirror.org/images/2017/08/02/145076757cd1b.gif&quot; alt=&quot;145076757cd1b.gif&quot;&gt;&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://moetu.fastmirror.org/images/2017/08/02/145076757cd1b.gif" alt="145076757cd1b.gif"><br><a id="more"></a>  </p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p><img src="https://moetu.fastmirror.org/images/2017/08/02/24583944f28e6.gif" alt="24583944f28e6.gif"><br>修正一下</p><p>l = (l_0 + x - 1) mod n + 1, r = (r_0 + x - 1) mod n + 1</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p><img src="https://moetu.fastmirror.org/images/2017/08/02/5196304f4bf2.gif" alt="5196304f4bf2.gif"></p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>6 3<br>1 2 3 2 1 2<br>1 5<br>3 6<br>1 5  </p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>1<br>2<br>1   </p></blockquote><p><img src="https://moetu.fastmirror.org/images/2017/08/02/203875813f6f9.gif" alt="203875813f6f9.gif"></p><p>修正下：<br>n &lt;= 40000, m &lt;= 50000</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>f(i,j)表示第 i 块到第 j 块的众数。<br>为每一个数开vector&lt;&gt; 存他的位置<br>在求得时候二分就可以了<br>详见《区间众数解题报告 - 陈立杰》 </p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cmath&gt;using namespace std;int n, m, block, tot;int a[40005], Index, v[40005];int in[40005];int f[4000][4000], num[40005];map&lt;int, int&gt; mp;vector&lt;int&gt; x[40005];void Init(int u){    memset(num, 0, sizeof(num));    int Max = 0, ans = 0;    for (int i = (u - 1) * block + 1; i &lt;= n; i++)    {        num[a[i]]++;        if (num[a[i]] &gt; Max || (num[a[i]] == Max &amp;&amp; v[a[i]] &lt; v[ans]))            ans = a[i], Max = num[a[i]];        f[u][in[i]] = ans;    }}int Query(int l, int r, int u){    return upper_bound(x[u].begin(), x[u].end(), r) - lower_bound(x[u].begin(), x[u].end(), l);}int Query(int l, int r){    int ans, Max;    ans = f[in[l] + 1][in[r] - 1];    Max = Query(l, r, ans);    for (int i = l; i &lt;= min(in[l] * block, r); i++)    {        int now = Query(l, r, a[i]);        if (now &gt; Max || (now == Max &amp;&amp; v[a[i]] &lt; v[ans]))            ans = a[i], Max = now;    }    if (in[l] != in[r])    {        for (int i = (in[r] - 1) * block + 1; i &lt;= r; i++)        {            int now = Query(l, r, a[i]);            if (now &gt; Max || (now == Max &amp;&amp; v[a[i]] &lt; v[ans]))                ans = a[i], Max = now;        }    }    return ans;}int main(){    //freopen(&quot;input.in&quot;, &quot;r&quot;, stdin);    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    block = 200;    for (int i = 1; i &lt;= n; i++)    {        scanf(&quot;%d&quot;, &amp;a[i]);        if (!mp[a[i]])        {            mp[a[i]] = ++Index;            v[Index] = a[i];        }        a[i] = mp[a[i]];        x[a[i]].push_back(i);        in[i] = (i - 1) / block + 1;    }    tot = in[n];    for (int i = 1; i &lt;= tot; i++)        Init(i);    int l, r, ans = 0;    for (int i = 1; i &lt;= m; i++)    {        scanf(&quot;%d%d&quot;, &amp;l, &amp;r);        l = (l + ans - 1) % n + 1, r = (r + ans - 1) % n + 1;        if (l &gt; r)            swap(l, r);        ans = v[Query(l, r)];        printf(&quot;%d\n&quot;, ans);    }    //while (1)    ;}</code></pre><p>附数据生成器  </p><pre><code class="c++">#include&lt;cstdio&gt;  #include&lt;ctime&gt;  #include&lt;cstdlib&gt;  #include&lt;iostream&gt;  using namespace std;  int main()  {      freopen(&quot;input.in&quot;,&quot;w&quot;,stdout);      int n,m;      n=40000;m=50000;      srand(time(0));      printf(&quot;%d %d\n&quot;,n,m);      for (int i=1;i&lt;=n;i++){          int x=rand()*rand()%1000000000+1;          cout&lt;&lt;x&lt;&lt;&quot; &quot;;      }      printf(&quot;\n&quot;);      for (int i=1;i&lt;=m;i++){          int l=rand()*rand()%n+1;          int r=rand()*rand()%n+1;          cout&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl;      }      return 0;  }  </code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/07/09/30/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 2002 [Hnoi2010]Bounce 弹飞绵羊</title>
      <link>https://blog.wildrage.xyz/2017/07/06/29/</link>
      <guid>https://blog.wildrage.xyz/2017/07/06/29/</guid>
      <pubDate>Thu, 06 Jul 2017 09:16:03 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;某天，Lostmonkey发明了一种超级弹力装置，为了在他的绵羊朋友面前显摆，他邀请小绵羊一起玩个游戏。游戏一开始，Lostmonkey在地上沿着一条直线摆上n个装置，每个装置设定初始弹力系数ki，当绵羊达到第i个装置时，它会往后弹ki步，达到第i+ki个装置，若不存在第i+ki个装置，则绵羊被弹飞。绵羊想知道当它从第i个装置起步时，被弹几次后会被弹飞。为了使得游戏更有趣，Lostmonkey可以修改某个弹力装置的弹力系数，任何时候弹力系数均为正整数。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>某天，Lostmonkey发明了一种超级弹力装置，为了在他的绵羊朋友面前显摆，他邀请小绵羊一起玩个游戏。游戏一开始，Lostmonkey在地上沿着一条直线摆上n个装置，每个装置设定初始弹力系数ki，当绵羊达到第i个装置时，它会往后弹ki步，达到第i+ki个装置，若不存在第i+ki个装置，则绵羊被弹飞。绵羊想知道当它从第i个装置起步时，被弹几次后会被弹飞。为了使得游戏更有趣，Lostmonkey可以修改某个弹力装置的弹力系数，任何时候弹力系数均为正整数。<br><a id="more"></a></p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第一行包含一个整数n，表示地上有n个装置，装置的编号从0到n-1,接下来一行有n个正整数，依次为那n个装置的初始弹力系数。第三行有一个正整数m，接下来m行每行至少有两个数i、j，若i=1，你要输出从j出发被弹几次后被弹飞，若i=2则还会再输入一个正整数k，表示第j个弹力装置的系数被修改成k。对于20%的数据n,m&lt;=10000，对于100%的数据n&lt;=200000,m&lt;=100000</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>对于每个i=1的情况，你都要输出一个需要的步数，占一行。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>4<br>1 2 1 1<br>3<br>1 1<br>2 1 1<br>1 1  </p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>2<br>3  </p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>将每一块都处理出<br>i 跳出 这一块所用的次数和跳到的位置<br>然后更新时将这一块重构</p><p>细节有问题的代码也能过（气）</p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;inline int read(){    int x = 0, f = 1;    char ch = getchar();    while (ch &gt; &#39;9&#39; || ch &lt; &#39;0&#39;)    {        if (ch == &#39;-&#39;)            f = -1;        ch = getchar();    }    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)    {        x = x * 10 + ch - &#39;0&#39;;        ch = getchar();    }    return x * f;}int n, m, k[200005], block;int in[200005], next[200005], times[200005], l[200005];int main(){    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    //scanf(&quot;%d&quot;, &amp;n);    n = read();    block = sqrt(n);    for (int i = 0; i &lt; n; i++)    {        k[i] = read();        //scanf(&quot;%d&quot;, k + i);        in[i] = i / block + 1;        l[i] = (in[i] - 1) * block;    }    for (int i = n - 1; i &gt;= 0; i--)    {        if (i + k[i] &gt; n)        {            times[i] = 1;            next[i] = n;        }        else if (in[i] == in[i + k[i]])        {            times[i] = times[i + k[i]] + 1;            next[i] = next[i + k[i]];        }        else        {            times[i] = 1;            next[i] = i + k[i];        }    }    //scanf(&quot;%d&quot;, &amp;m);    m = read();    int op, s;    while (m--)    {        //scanf(&quot;%d&quot;, &amp;op);        op = read();        if (op == 1)        {            //scanf(&quot;%d&quot;, &amp;s);            s = read();            int ans = 0;            for (int i = s; i &lt; n; i = next[i])            {                ans += times[i];            }            printf(&quot;%d\n&quot;, ans);        }        else        {            //scanf(&quot;%d%d&quot;, &amp;s, &amp;c);            //k[s] = c;            s = read();            k[s] = read();            for (int i = s; i &gt;= l[s]; i--)            {                if (i + k[i] &gt; n)                {                    times[i] = 1;                    next[i] = i + k[i];                }                if (in[i] == in[i + k[i]])                {                    times[i] = times[i + k[i]] + 1;                    next[i] = next[i + k[i]];                }                else                {                    times[i] = 1;                    next[i] = i + k[i];                }            }        }    }}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/07/06/29/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Codeforces 743E Vladik and cards</title>
      <link>https://blog.wildrage.xyz/2017/07/03/27/</link>
      <guid>https://blog.wildrage.xyz/2017/07/03/27/</guid>
      <pubDate>Mon, 03 Jul 2017 08:30:22 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Vladik在回家的路上无聊，决定玩下面的游戏：他拿了n张牌在他面前排成一个序列，每张牌上都有一个不超过8的正整数，他决定找到满足以下条件的牌的最长子序列：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在这个序列中,[1,8]每个数字出现的次数之差的绝对值不超过1;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;相同的数字必须连续，输出最长子序列的长度。例如，子序列[1, 1, 2, 2]满足第2个条件，但是子序列 [1, 2, 2, 1]就不满足(注意，子序列[1, 1, 2, 2]不满足第一个条件)。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Vladik在回家的路上无聊，决定玩下面的游戏：他拿了n张牌在他面前排成一个序列，每张牌上都有一个不超过8的正整数，他决定找到满足以下条件的牌的最长子序列：</p><ol><li><p>在这个序列中,[1,8]每个数字出现的次数之差的绝对值不超过1;</p></li><li><p>相同的数字必须连续，输出最长子序列的长度。例如，子序列[1, 1, 2, 2]满足第2个条件，但是子序列 [1, 2, 2, 1]就不满足(注意，子序列[1, 1, 2, 2]不满足第一个条件)。</p><a id="more"></a> <p>请帮助Vladik找到满足这两个条件的最长子序列的长度。</p></li></ol><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第一行包含单个整数n（1≤n≤1000） - Vladik序列中的牌数。</p><p>第二行包含不超过8的n个正整数的序列 - 每个数空格隔开</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出一个整数，即满足两个条件的子序列的最大长度</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><ul><li>sample input 1:<blockquote><p>3<br>1 1 1</p></blockquote></li><li><p>sample input 2:</p><blockquote><p>8<br>8 7 6 5 4 3 2 1</p></blockquote></li><li><p>sample input 3:</p><blockquote><p>24<br>1 8 1 2 8 2 3 8 3 4 8 4 5 8 5 6 8 6 7 8 7 8 8 8</p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>sample output 1:<br>1<br>sample output 2:<br>8<br>sample output 3:<br>17  </p></blockquote></li></ul><p>题解请参考<a href="https://www.cnblogs.com/TSHugh/p/7106544.html" target="_blank" rel="noopener">CodeForces743E. Vladik and cards 二分+装压dp</a></p><pre><code class="c++">/* * @Author: WildRage  * @Date: 2017-07-02 16:07:15  * @Last Modified by: WildRage * @Last Modified time: 2017-07-02 17:58:06 */#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int a[1005], sum[10][1005],n;int DP[1005][300];bool had[10];int N = (1 &lt;&lt; 8) - 1;vector&lt;int&gt; in[10];int get_num(int p, int len){    int now = lower_bound(in[a[p]].begin(), in[a[p]].end(), p) - in[a[p]].begin();    int ans = now + len - 1;    if (in[a[p]].size() - 1 &lt; ans)        return -1;    return in[a[p]][ans];}int Judge(int len){    memset(DP, 0, sizeof(DP));    for (int i = 0; i &lt; n; i++)    {        int to = get_num(i + 1, len);        if (to != -1)            DP[to][(1 &lt;&lt; (a[i + 1] - 1))] = max(DP[i][0] + len, DP[to][1 &lt;&lt; (a[i + 1] - 1)]);        to = get_num(i + 1, len + 1);        if (to != -1)            DP[to][(1 &lt;&lt; (a[i + 1] - 1))] = max(DP[i][0] + len + 1, DP[to][(1 &lt;&lt; (a[i + 1] - 1))]);        for (int j = 1; j &lt; N; j++)        {            if (DP[i][j])            {                DP[i + 1][j] = max(DP[i + 1][j], DP[i][j]);                if (j &amp; (1 &lt;&lt; (a[i + 1] - 1)))                    continue;                to = get_num(i + 1, len);                if (to != -1)                    DP[to][j | (1 &lt;&lt; (a[i + 1] - 1))] = max(DP[i][j] + len, DP[to][j | (1 &lt;&lt; (a[i + 1] - 1))]);                to = get_num(i + 1, len + 1);                if (to != -1)                    DP[to][j | (1 &lt;&lt; (a[i + 1] - 1))] = max(DP[i][j] + len + 1, DP[to][j | (1 &lt;&lt; (a[i + 1] - 1))]);            }            DP[i + 1][N] = max(DP[i + 1][N], DP[i][N]);        }    }    return DP[n][N];}int main(){    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i++)    {        scanf(&quot;%d&quot;, a + i);        had[a[i]] = 1;        in[a[i]].push_back(i);    }    int ans = 0;    for(int i=1;i&lt;=8;i++)if(had[i])ans++;    int l = 1, r = 256;    while (l &lt;= r)    {        int mid = l + r &gt;&gt; 1;        int x = Judge(mid);        ans = max(x, ans);        if (x)            l = mid + 1;        else            r = mid - 1;    }    printf(&quot;%d&quot;, ans);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/07/03/27/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HDU 1166 敌兵布阵</title>
      <link>https://blog.wildrage.xyz/2017/07/03/28/</link>
      <guid>https://blog.wildrage.xyz/2017/07/03/28/</guid>
      <pubDate>Mon, 03 Jul 2017 08:30:22 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。 &lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。 </p><a id="more"></a><p>中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的.</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第一行一个整数T，表示有T组数据。<br>每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。<br>接下来每行有一条命令，命令有4种形式：<br>(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）<br>(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;<br>(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;<br>(4)End 表示结束，这条命令在每组数据最后出现;<br>每组数据最多有40000条命令</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>对第i组数据,首先输出“Case i:”和回车,<br>对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>1<br>10<br>1 2 3 4 5 6 7 8 9 10<br>Query 1 3<br>Add 3 6<br>Query 2 7<br>Sub 10 2<br>Add 6 3<br>Query 3 10<br>End   </p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>Case 1:<br>6<br>33<br>59  </p></blockquote><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;namespace MineWorkSpace{int n;class Block_Main{    int block, n;    int a[50005], in[50005], sum[305];  public:    void Init(int N)    {        memset(in, 0, sizeof(in));        memset(sum, 0, sizeof(sum));        memset(a, 0, sizeof(a));        n = N;        block = sqrt(n);        for (int i = 1; i &lt;= n; i++)        {            scanf(&quot;%d&quot;, a + i);            in[i] = (i - 1) / block + 1;            sum[in[i]] += a[i];        }    }    void Updata(int i, int c)    {        a[i] += c;        sum[in[i]] += c;    }    int Query(int l, int r)    {        int ans = 0;        if (in[l] == in[r])        {            for (int i = l; i &lt;= r; i++)                ans += a[i];            return ans;        }        else        {            for (int i = in [l] + 1; i &lt;= in[r] - 1; i++)                ans += sum[i];            for (int i = l; i &lt;= in[l] * block; i++)                ans += a[i];            for (int i = (in[r] - 1) * block + 1; i &lt;= r; i++)                ans += a[i];            return ans;        }    }} Block;class Order_run{    int l, r;  public:    void Run(char c)    {        if (c == &#39;Q&#39;)        {            scanf(&quot;%d%d&quot;, &amp;l, &amp;r);            if (l &gt; r)                printf(&quot;0\n&quot;);            else                printf(&quot;%d\n&quot;, Block.Query(l, r));            return;        }        if (c == &#39;A&#39;)        {            scanf(&quot;%d%d&quot;, &amp;l, &amp;r);            Block.Updata(l, r);            return;        }        if (c == &#39;S&#39;)        {            scanf(&quot;%d%d&quot;, &amp;l, &amp;r);            Block.Updata(l, -r);            return;        }    }} Order;class Main{  public:    Main()    {        int T;        scanf(&quot;%d&quot;, &amp;T);        for (int L = 1; L &lt;= T; L++)        {            printf(&quot;Case %d:\n&quot;, L);            scanf(&quot;%d&quot;, &amp;n);            Block.Init(n);            char s[10];            while (1)            {                scanf(&quot;%s&quot;, s);                if (s[0] == &#39;E&#39;)                    break;                Order.Run(s[0]);            }        }    }} run;}int main() { ; }</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/07/03/28/#disqus_thread</comments>
    </item>
    
    <item>
      <title>POJ 2185 Milking Grid</title>
      <link>https://blog.wildrage.xyz/2017/07/03/26/</link>
      <guid>https://blog.wildrage.xyz/2017/07/03/26/</guid>
      <pubDate>Mon, 03 Jul 2017 08:12:51 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;Every morning when they are milked, the Farmer John’s cows form a rectangular grid that is R (1 &amp;lt;= R &amp;lt;= 10,000) rows by C (1 &amp;lt;= C &amp;lt;= 75) columns. As we all know, Farmer John is quite the expert on cow behavior, and is currently writing a book about feeding behavior in cows. He notices that if each cow is labeled with an uppercase letter indicating its breed, the two-dimensional pattern formed by his cows during milking sometimes seems to be made from smaller repeating rectangular patterns.&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Every morning when they are milked, the Farmer John’s cows form a rectangular grid that is R (1 &lt;= R &lt;= 10,000) rows by C (1 &lt;= C &lt;= 75) columns. As we all know, Farmer John is quite the expert on cow behavior, and is currently writing a book about feeding behavior in cows. He notices that if each cow is labeled with an uppercase letter indicating its breed, the two-dimensional pattern formed by his cows during milking sometimes seems to be made from smaller repeating rectangular patterns.<br><a id="more"></a><br>Help FJ find the rectangular unit of smallest area that can be repetitively tiled to make up the entire milking grid. Note that the dimensions of the small rectangular unit do not necessarily need to divide evenly the dimensions of the entire milking grid, as indicated in the sample input below. </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><ul><li><p>Line 1: Two space-separated integers: R and C </p></li><li><p>Lines 2..R+1: The grid that the cows form, with an uppercase letter denoting each cow’s breed. Each of the R input lines has C characters with no space or other intervening character. </p></li></ul><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><ul><li>Line 1: The area of the smallest unit from which the grid is formed <h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>2 5<br>ABABA<br>ABABA  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>2  </p></blockquote></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>要求循环节，想到<a href="https://wildrage.cf/2017/06/13/2/" target="_blank" rel="noopener">“POJ 2406 Power Strings”</a><br>把情况拓展到二维<br>对于每一个横行求最短循环节也就是m-next[m]<br>然后不断的求lcm<br>竖列也是一样<br>最后乘起来就可以了<br>不过在求lcm时如果大于边界就可以将他的值给为边界  </p><pre><code class="c++">/* * @Author: WildRage  * @Date: 2017-07-01 10:17:47  * @Last Modified by: WildRage * @Last Modified time: 2017-07-01 11:08:00 */#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;namespace MineWorkSpace{    char s[10005][80];    int next[10005][80];    int next2[80][10005];    int gcd(int a,int b){        return b==0? a: gcd(b,a%b);    }    int lcm(int a,int b){        return a/gcd(a,b)*b;    }    int Main()    {    #ifdef Mine        freopen(&quot;mgrid.in&quot;,&quot;r&quot;,stdin);        freopen(&quot;mgrid.out&quot;,&quot;w&quot;,stdout);    #endif        int n,m;        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=0;i&lt;n;i++){            scanf(&quot;%s&quot;,s[i]);        }        int ans1=1,ans2=1;        for(int i=0;i&lt;n;i++){            int j=0,k=-1;            next[i][0]=-1;            while(j&lt;m){                if(k==-1||s[i][j]==s[i][k]){                    next[i][++j]=++k;                }                else k=next[i][k];            }            if(m-next[i][m]) ans1=lcm(ans1,m-next[i][m]);            if(ans1&gt;m)ans1=m;        }        for(int i=0;i&lt;m;i++){            int j=0,k=-1;            next2[i][0]=-1;            while(j&lt;n){                if(k==-1||s[j][i]==s[k][i]){                    next2[i][++j]=++k;                }                else k=next2[i][k];            }            if(n-next2[i][n])ans2=lcm(ans2,n-next2[i][n]);            if(ans2&gt;n)ans2=n;        }        return printf(&quot;%d&quot;,ans1*ans2);    }}int main(){    MineWorkSpace::Main();    //while(1);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/07/03/26/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 4720 [NOIP2016]换教室</title>
      <link>https://blog.wildrage.xyz/2017/06/25/25/</link>
      <guid>https://blog.wildrage.xyz/2017/06/25/25/</guid>
      <pubDate>Sun, 25 Jun 2017 08:46:30 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;对于刚上大学的牛牛来说,他面临的第一个问题是如何根据实际情况申请合适的课程。在可以选择的课程中,有2n节&lt;br&gt;课程安排在n个时间段上。在第i(1≤i≤n)个时间段上,两节内容相同的课程同时在不同的地点进行,其中,牛牛预先&lt;br&gt;被安排在教室ci上课,而另一节课程在教室di进行。在不提交任何申请的情况下,学生们需要按时间段的顺序依次完&lt;br&gt;成所有的n节安排好的课程。如果学生想更换第i节课程的教室,则需要提出申请。若申请通过,学生就可以在第i个&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>对于刚上大学的牛牛来说,他面临的第一个问题是如何根据实际情况申请合适的课程。在可以选择的课程中,有2n节<br>课程安排在n个时间段上。在第i(1≤i≤n)个时间段上,两节内容相同的课程同时在不同的地点进行,其中,牛牛预先<br>被安排在教室ci上课,而另一节课程在教室di进行。在不提交任何申请的情况下,学生们需要按时间段的顺序依次完<br>成所有的n节安排好的课程。如果学生想更换第i节课程的教室,则需要提出申请。若申请通过,学生就可以在第i个<br><a id="more"></a><br>时间段去教室di上课,否则仍然在教室ci上课。由于更换教室的需求太多,申请不一定能获得通过。通过计算,牛牛<br>发现申请更换第i节课程的教室时,申请被通过的概率是一个已知的实数ki,并且对于不同课程的申请,被通过的概率<br>是互相独立的。学校规定,所有的申请只能在学期开始前一次性提交,并且每个人只能选择至多m节课程进行申请。<br>这意味着牛牛必须一次性决定是否申请更换每节课的教室,而不能根据某些课程的申请结果来决定其他课程是否申<br>请;牛牛可以申请自己最希望更换教室的m门课程,也可以不用完这m个申请的机会,甚至可以一门课程都不申请。因<br>为不同的课程可能会被安排在不同的教室进行,所以牛牛需要利用课间时间从一间教室赶到另一间教室。牛牛所在<br>的大学有v个教室,有e条道路。每条道路连接两间教室,并且是可以双向通行的。由于道路的长度和拥堵程度不同,<br>通过不同的道路耗费的体力可能会有所不同。当第i(1≤i≤n-1)节课结束后,牛牛就会从这节课的教室出发,选择一<br>条耗费体力最少的路径前往下一节课的教室。现在牛牛想知道,申请哪几门课程可以使他因在教室间移动耗费的体<br>力值的总和的期望值最小,请你帮他求出这个最小值。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一行,包含一个实数,四舎五入精确到小数点后恰好2位,表示答案。你的<br>输出必须和标准输出完全一样才算正确。<br>测试数据保证四舎五入后的答案和准确答案的差的绝对值不大于4*10^-3。(如果你不知道什么是浮点误差,这段话<br>可以理解为:对于大多数的算法,你可以正常地使用浮点数类型而不用对它进行特殊的处理)</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>3 2 3 3<br>2 1 2<br>1 2 1<br>0.8 0.2 0.5<br>1 2 5<br>1 3 3<br>2 3 1  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>2.80</p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这道题相比于前几道题是真水<br>先跑一下 Floyd<br>根据期望的可加性 只要在算DP数组的时候不断的加就可以了<br>分四种情况讨论<br>然后交上去就WA了<br>再一看要保留2位小数<br>我保留了3位<br>另外能把程序写的这么宽的人也只有我了吧  </p><pre><code class="c++">/* * @Author: WildRage  * @Date: 2017-06-25 15:42:08  * @Last Modified by: WildRage * @Last Modified time: 2017-06-25 16:28:13 */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;namespace WorkSpace{    class Floyd{        int n;        int a[305][305];    public:        void GetMinDis(){            for(int i=1;i&lt;=n;i++) a[i][i]=0;            for(int k=1;k&lt;=n;k++)                for(int i=1;i&lt;=n;i++)                    for(int j=1;j&lt;=n;j++)                        a[i][j]=std::min(a[i][j],a[i][k]+a[k][j]);        }        void GetMap(int Number=0,int m=0){            n=Number;            memset(a,0x3f,sizeof(a));            int s,e,v;            for(int i=1;i&lt;=m;i++){                scanf(&quot;%d%d%d&quot;,&amp;s,&amp;e,&amp;v);                a[s][e]=std::min(v,a[s][e]);                a[e][s]=std::min(v,a[s][e]);            }        }        int MinDis(int s=0,int e=0){            return a[s][e];        }    }Map;    struct Input{        int n,m,v,e;    }Read;    int ClassroomC[2005],ClassroomD[2005];    double ChangeProbability[2005],FailedToChange[2005];    class Init{        void OpenFile(){            freopen(&quot;classrooma.in&quot;,&quot;r&quot;,stdin);            freopen(&quot;classrooma.out&quot;,&quot;w&quot;,stdout);        }        void ReadInput(){            scanf(&quot;%d%d%d%d&quot;,&amp;Read.n,&amp;Read.m,&amp;Read.v,&amp;Read.e);            for(int i=1;i&lt;=Read.n;i++) scanf(&quot;%d&quot;,&amp;ClassroomC[i]);            for(int i=1;i&lt;=Read.n;i++) scanf(&quot;%d&quot;,&amp;ClassroomD[i]);            for(int i=1;i&lt;=Read.n;i++) scanf(&quot;%lf&quot;,&amp;ChangeProbability[i]),FailedToChange[i]=1-ChangeProbability[i];            Map.GetMap(Read.v,Read.e);        }    public:        Init(){        #ifdef MineWorkSpace            OpenFile();        #endif            ReadInput();            Map.GetMinDis();        }    };    class DP{        double MinExpectation[2010][2010][2];    public:        #define n Read.n        #define m Read.m        DP(){            memset(MinExpectation,0x43,sizeof(MinExpectation));            MinExpectation[1][0][0]=0;MinExpectation[1][1][1]=0;            for(int i=2;i&lt;=n;i++){                for(int j=0;j&lt;=m;j++){                    MinExpectation[i][j][0]=std::min(MinExpectation[i-1][j][0]+Map.MinDis(ClassroomC[i-1],ClassroomC[i]),MinExpectation[i-1][j][1]+(double)Map.MinDis(ClassroomD[i-1],ClassroomC[i])*ChangeProbability[i-1]+(double)Map.MinDis(ClassroomC[i-1],ClassroomC[i])*FailedToChange[i-1]);                    if(j&gt;0)MinExpectation[i][j][1]=std::min(MinExpectation[i-1][j-1][0]+(double)Map.MinDis(ClassroomC[i-1],ClassroomD[i])*ChangeProbability[i]+(double)Map.MinDis(ClassroomC[i-1],ClassroomC[i])*FailedToChange[i],MinExpectation[i-1][j-1][1]+(double)Map.MinDis(ClassroomC[i-1],ClassroomC[i])*FailedToChange[i-1]*FailedToChange[i]+(double)Map.MinDis(ClassroomC[i-1],ClassroomD[i])*FailedToChange[i-1]*ChangeProbability[i]+(double)Map.MinDis(ClassroomD[i-1],ClassroomC[i])*ChangeProbability[i-1]*FailedToChange[i]+Map.MinDis(ClassroomD[i-1],ClassroomD[i])*ChangeProbability[i-1]*ChangeProbability[i]);                }            }            double ans=1e16;            for(int i=0;i&lt;=m;i++){                ans=std::min(MinExpectation[n][i][0],ans);                ans=std::min(MinExpectation[n][i][1],ans);            }            printf(&quot;%.2lf&quot;,ans);        }        };    class Main{    public:        Main(){            new Init();            new DP();            //while(1);        }    }Run;}int main(){;}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/06/25/25/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 1076 [SCOI2008]奖励关</title>
      <link>https://blog.wildrage.xyz/2017/06/24/24/</link>
      <guid>https://blog.wildrage.xyz/2017/06/24/24/</guid>
      <pubDate>Sat, 24 Jun 2017 01:48:46 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;　你正在玩你最喜欢的电子游戏，并且刚刚进入一个奖励关。在这个奖励关里，系统将依次随机抛出k次宝物，&lt;br&gt;每次你都可以选择吃或者不吃（必须在抛出下一个宝物之前做出选择，且现在决定不吃的宝物以后也不能再吃）。&lt;br&gt; 宝物一共有n种，系统每次抛出这n种宝物的概率都相同且相互独立。也就是说，即使前k-1次系统都抛出宝物1（&lt;br&gt;这种情况是有可能出现的，尽管概率非常小），第k次抛出各个宝物的概率依然均为1/n。 获取第i种宝物将得到Pi&lt;br&gt;分，但并不是每种宝物都是可以随意获取的。第i种宝物有一个前提宝物集合Si。只有当Si中所有宝物都至少吃过&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>　你正在玩你最喜欢的电子游戏，并且刚刚进入一个奖励关。在这个奖励关里，系统将依次随机抛出k次宝物，<br>每次你都可以选择吃或者不吃（必须在抛出下一个宝物之前做出选择，且现在决定不吃的宝物以后也不能再吃）。<br> 宝物一共有n种，系统每次抛出这n种宝物的概率都相同且相互独立。也就是说，即使前k-1次系统都抛出宝物1（<br>这种情况是有可能出现的，尽管概率非常小），第k次抛出各个宝物的概率依然均为1/n。 获取第i种宝物将得到Pi<br>分，但并不是每种宝物都是可以随意获取的。第i种宝物有一个前提宝物集合Si。只有当Si中所有宝物都至少吃过<br><a id="more"></a><br>一次，才能吃第i种宝物（如果系统抛出了一个目前不能吃的宝物，相当于白白的损失了一次机会）。注意，Pi可<br>以是负数，但如果它是很多高分宝物的前提，损失短期利益而吃掉这个负分宝物将获得更大的长期利益。 假设你<br>采取最优策略，平均情况你一共能在奖励关得到多少分值？</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行为两个正整数k和n，即宝物的数量和种类。以下n行分别描述一种宝物，其中第一个整数代表分值，随<br>后的整数依次代表该宝物的各个前提宝物（各宝物编号为1到n），以0结尾。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一个实数，保留六位小数，即在最优策略下平均情况的得分。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>1 2<br>1 0<br>2 0  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>1.500000</p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>逆推即可<br>水题  </p><pre><code class="c++">#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int w[16];int p[16];double f[105][1&lt;&lt;15];int main(){    int n,k;    scanf(&quot;%d%d&quot;,&amp;k,&amp;n);    int a;    for(int i=1;i&lt;=n;i++){        scanf(&quot;%d&quot;,&amp;w[i]);        while(scanf(&quot;%d&quot;,&amp;a)&amp;&amp;a!=0) p[i]|=1&lt;&lt;(a-1);    }    int S=(1&lt;&lt;n)-1;    for(int i=k;i&gt;=1;i--){        for(int j=0;j&lt;=S;j++){            for(int m=1;m&lt;=n;m++)                if((p[m]&amp;j)==p[m])                    f[i][j]+=max(f[i+1][j],f[i+1][j|(1&lt;&lt;(m-1))]+w[m]);                else f[i][j]+=f[i+1][j];            f[i][j]/=n;        }    }    printf(&quot;%.6lf&quot;,f[1][0]);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/06/24/24/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 2337 [HNOI2011]XOR和路径</title>
      <link>https://blog.wildrage.xyz/2017/06/22/23/</link>
      <guid>https://blog.wildrage.xyz/2017/06/22/23/</guid>
      <pubDate>Thu, 22 Jun 2017 09:05:22 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/06/22/594b88b5de2d5.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p><img src="https://ooo.0o0.ooo/2017/06/22/594b88b5de2d5.gif" alt=""></p><a id="more"></a> <h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>以每一位分别分析<br>f[i]为这一位为1的概率  </p><p>然后高斯消元即可  </p><pre><code class="c++">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;struct edge{    int END,next;    bool b[32];}v[30005];int first[105],p,t[105],du[105];double f[105][35][2];double a[105][105],x[105];void add(int a,int b,int c){    int i=1;    du[a]++;    while(c){        v[p].b[i]=c&amp;1;        i++;c&gt;&gt;=1;    }    v[p].END=b;v[p].next=first[a];    first[a]=p++;}int n,m;void gauss(){    int im,num=1;    for(int k=1;k&lt;=n;k++,num++){        im=k;        for(int i=k+1;i&lt;=n;i++){            if(fabs(a[i][k])&gt;fabs(a[im][k]))                im=i;        }        if(im!=k){            for(int i=k;i&lt;=n+1;i++){                swap(a[num][i],a[im][i]);            }        }        if(!a[num][k]){            num--;continue;        }        for(int i=num+1;i&lt;=n;i++){            if(!a[num][k])continue;            long double t=a[i][k]/a[num][k];            for(int j=k;j&lt;=n+1;j++){                a[i][j]-=t*a[k][j];            }        }    }    for(int i=n;i&gt;=1;i--){        for(int j=n;j&gt;=i+1;j--){            a[i][n+1]-=a[i][j]*x[j];        }        x[i]=a[i][n+1]/a[i][i];    }}int main(){    //freopen(&quot;xorpath.in&quot;, &quot;r&quot;, stdin);    //freopen(&quot;xorpath.out&quot;, &quot;w&quot;, stdout);    memset(first,-1,sizeof(first));    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int a1,b,c,i=1;i&lt;=m;i++){        scanf(&quot;%d%d%d&quot;,&amp;a1,&amp;b,&amp;c);        add(a1,b,c);        if(a1!=b) add(b,a1,c);    }    //for(int i=first[n];i!=-1;i=v[i].next)     //   rdu[v[i].END]--;    long double ans=0;    for(int k=1;k&lt;=31;k++){        memset(a,0,sizeof(a));        for(int i=1;i&lt;n;i++){            a[i][i]=1;            memset(t,0,sizeof(t));            for(int j=first[i];j!=-1;j=v[j].next){                //if(v[j].END==n)continue;                if(v[j].b[k]) a[i][v[j].END]+=double(1)/du[i],a[i][n+1]+=(double)1/du[i];                else a[i][v[j].END]-=double(1)/du[i];            }        }        a[n][n]=1;        gauss();        ans+=x[1]*(1&lt;&lt;(k-1));    }    printf(&quot;%.3lf&quot;,(double)ans);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/06/22/23/#disqus_thread</comments>
    </item>
    
    <item>
      <title>莫比乌斯反演的证明</title>
      <link>https://blog.wildrage.xyz/2017/06/21/22/</link>
      <guid>https://blog.wildrage.xyz/2017/06/21/22/</guid>
      <pubDate>Wed, 21 Jun 2017 10:00:21 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;莫比乌斯反演&quot;&gt;&lt;a href=&quot;#莫比乌斯反演&quot; class=&quot;headerlink&quot; title=&quot;莫比乌斯反演&quot;&gt;&lt;/a&gt;莫比乌斯反演&lt;/h3&gt;&lt;p&gt;已知&lt;br&gt;$$ F(n)=\sum_{d|n}{f(d)} $$&lt;br&gt;则&lt;br&gt;$$ f(n)=\sum_{d|n}{\mu(d)F(\frac {n}{d})} $$&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h3><p>已知<br>$$ F(n)=\sum_{d|n}{f(d)} $$<br>则<br>$$ f(n)=\sum_{d|n}{\mu(d)F(\frac {n}{d})} $$<br><a id="more"></a><br>证明<br>$$ \sum_{d|n}{\mu(d)F(\frac {n}{d})} $$<br>$$ =\sum_{d|n}{\mu(d)\sum_{d’|\frac {n}{d}}{f(d’)}} $$</p><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/06/21/22/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 1415 [Noi2005] 聪聪和可可 概率DP</title>
      <link>https://blog.wildrage.xyz/2017/06/21/21/</link>
      <guid>https://blog.wildrage.xyz/2017/06/21/21/</guid>
      <pubDate>Wed, 21 Jun 2017 09:43:55 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/06/21/594a400282a59.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;数据的第1行为两个整数N和E，以空格分隔，分别表示森林中的景点数和连接相邻景点的路的条数。 第2行包含两个整数C和M，以空格分隔，分别表示初始时聪聪和可可所在的景点的编号。 接下来E行，每行两个整数，第i+2行的两个整数Ai和Bi表示景点Ai和景点Bi之间有一条路。 所有的路都是无向的，即：如果能从A走到B，就可以从B走到A。 输入保证任何两个景点之间不会有多于一条路直接相连，且聪聪和可可之间必有路直接或间接的相连。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p><img src="https://ooo.0o0.ooo/2017/06/21/594a400282a59.jpg" alt=""></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>数据的第1行为两个整数N和E，以空格分隔，分别表示森林中的景点数和连接相邻景点的路的条数。 第2行包含两个整数C和M，以空格分隔，分别表示初始时聪聪和可可所在的景点的编号。 接下来E行，每行两个整数，第i+2行的两个整数Ai和Bi表示景点Ai和景点Bi之间有一条路。 所有的路都是无向的，即：如果能从A走到B，就可以从B走到A。 输入保证任何两个景点之间不会有多于一条路直接相连，且聪聪和可可之间必有路直接或间接的相连。<br><a id="more"></a> </p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出1个实数，四舍五入保留三位小数，表示平均多少个时间单位后聪聪会把可可吃掉。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>【输入样例1】<br>4 3<br>1 4<br>1 2<br>2 3<br>3 4<br>【输入样例2】<br>9 9<br>9 3<br>1 2<br>2 3<br>3 4<br>4 5<br>3 6<br>4 6<br>4 7<br>7 8<br>8 9  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>【输出样例1】<br>1.500<br>【输出样例2】<br>2.167  </p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先每个点跑一遍SPFA<br>求出p[i][j]表示当可可在 j 点时，聪聪在 i 点要走的下一步<br>然后记忆化搜索<br>$$ f[s][e]=\sum_{tmp=p[p[i][e]][e],e-&gt;j}{\frac{f[tmp][j]}{du[e]+1}} $$</p><pre><code class="c++">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;struct edge{    int END,next;}v[100005];int first[1005],Index,du[1005],n;void add(int a,int b){    du[a]++;    v[Index].END=b;    v[Index].next=first[a];    first[a]=Index++;}int p[1005][1005];double f[1005][1005];void spfa(int x){    queue&lt;int&gt; Q;    bool flag[1005]={0};    int dis[1005],fr[1005];    memset(dis,0x3f,sizeof(dis));    memset(fr,0,sizeof(fr));    dis[x]=0;    flag[x]=1;Q.push(x);    while(!Q.empty()){        int k=Q.front();        Q.pop();flag[k]=0;        for(int i=first[k];i!=-1;i=v[i].next){            if(dis[v[i].END]&gt;dis[k]+1||(dis[v[i].END]==dis[k]+1&amp;&amp;k&lt;fr[v[i].END])){                dis[v[i].END]=dis[k]+1;                fr[v[i].END]=k;                if(!flag[v[i].END]){                    flag[v[i].END]=1;                    Q.push(v[i].END);                }            }        }    }    for(int i=1;i&lt;=n;i++)        if(i!=x)            p[i][x]=fr[i];}double dfs(int s,int e){    if(s==e)return f[s][e]=0;    if(p[s][e]==e||p[p[s][e]][e]==e)return f[s][e]=1;    if(f[s][e]&lt;=1e9) return f[s][e];    int tmp=p[p[s][e]][e];    f[s][e]=1;    for(int i=first[e];i!=-1;i=v[i].next){        f[s][e]+=dfs(tmp,v[i].END)/(du[e]+1);    }    f[s][e]+=dfs(tmp,e)/(du[e]+1);    return f[s][e];}int main(){    //freopen(&quot;cchkk.in&quot;,&quot;r&quot;,stdin);    //freopen(&quot;cchkk.out&quot;,&quot;w&quot;,stdout);    memset(first,-1,sizeof(first));    memset(f,0x7f,sizeof(f));    int m,s,e,a,b;    scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;s,&amp;e);    for(int i=1;i&lt;=m;i++){        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        add(a,b);        add(b,a);    }    for(int i=1;i&lt;=n;i++)        spfa(i);    printf(&quot;%.3lf&quot;,dfs(s,e));    //while(1);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/06/21/21/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 3143 [Hnoi2013]游走 高斯消元 概率DP</title>
      <link>https://blog.wildrage.xyz/2017/06/21/20/</link>
      <guid>https://blog.wildrage.xyz/2017/06/21/20/</guid>
      <pubDate>Wed, 21 Jun 2017 07:53:46 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;一个无向连通图，顶点从1编号到N，边从1编号到M。&lt;br&gt;小Z在该图上进行随机游走，初始时小Z在1号顶点，每一步小Z以相等的概率随机选 择当前顶点的某条边，沿着这条边走到下一个顶点，获得等于这条边的编号的分数。当小Z 到达N号顶点时游走结束，总分为所有获得的分数之和。&lt;br&gt;现在，请你对这M条边进行编号，使得小Z获得的总分的期望值最小。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>一个无向连通图，顶点从1编号到N，边从1编号到M。<br>小Z在该图上进行随机游走，初始时小Z在1号顶点，每一步小Z以相等的概率随机选 择当前顶点的某条边，沿着这条边走到下一个顶点，获得等于这条边的编号的分数。当小Z 到达N号顶点时游走结束，总分为所有获得的分数之和。<br>现在，请你对这M条边进行编号，使得小Z获得的总分的期望值最小。<br><a id="more"></a> </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行是正整数N和M，分别表示该图的顶点数 和边数，接下来M行每行是整数u，v(1≤u,v≤N)，表示顶点u与顶点v之间存在一条边。 输入保证30%的数据满足N≤10，100%的数据满足2≤N≤500且是一个无向简单连通图。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>仅包含一个实数，表示最小的期望值，保留3位小数。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>3  3<br>2  3<br>1  2<br>1  3  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>3.333</p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>用贪心的思想<br>要使期望最小 那么可以先求出每条边的期望经过次数<br>然后问题就转化成了求每条边的期望经过次数<br>可能从u走到v,也可能从v走到u,从u走到v的期望次数等于经过点u的次数/u的度数<br>这样就转化成了每个点的期望经过次数<br>易得<br>$$ f[1]=1+\sum_{j!=n}{f[j]/degree(j)} $$<br>$$ f[i]=\sum_{j!=n}{f[j]/degree(j)} (i!=n) $$ </p><p>这样就建立了一个n-1元方程组</p><p>高斯消元解就可以了</p><p>代码比较丑</p><pre><code class="c++">#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;struct edge{    int END,next;}v[500005];int first[505],p,du[505];void add(int a,int b){    v[p].END=b;    v[p].next=first[a];    first[a]=p++;}template&lt;typename T&gt;int cmp(const T a,const T b){    return a &gt; b;}double a[505][505],x[505],f[500005];int n,m;void gauss(){    int im,num=1;    for(int k=1;k&lt;=n;k++,num++){        im=k;        for(int i=k+1;i&lt;=n;i++)            if(fabs(a[i][k])&gt;fabs(a[im][k]))                im=i;        if(im!=k){            for(int i=k;i&lt;=n+1;i++)                swap(a[num][i],a[im][i]);        }        if(!a[num][k]){            num--;continue;        }        for(int i=num+1;i&lt;=n;i++){            if(!a[num][i])continue;            double t=a[i][k]/a[num][k];            for(int j=k;j&lt;=n+1;j++){                a[i][j]-=t*a[k][j];            }        }    }    for(int i=n;i&gt;=1;i--){        for(int j=n;j&gt;=i+1;j--){            a[i][n+1]-=a[i][j]*x[j];        }        x[i]=a[i][n+1]/a[i][i];    }}int main(){    //freopen(&quot;walk.in&quot;,&quot;r&quot;,stdin);    //freopen(&quot;walk.out&quot;,&quot;w&quot;,stdout);    memset(first,-1,sizeof(first));    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    int s,e;    for(int i=1;i&lt;=m;i++){        scanf(&quot;%d%d&quot;,&amp;s,&amp;e);        du[s]++;du[e]++;        add(s,e);add(e,s);    }    n--;    a[1][n+1]=-1;    for(int i=1;i&lt;=n;i++){        a[i][i]=-1;        for(int j=first[i];j!=-1;j=v[j].next){            if(v[j].END!=n+1)                a[i][v[j].END]+=(double)1/(du[v[j].END]);        }    }    gauss();    for(int i=0;i&lt;p;i++){        //if(v[i].END!=n+1)            f[i&gt;&gt;1]+=x[v[i].END]/du[v[i].END];    }    //for(int i=0;i&lt;m;i++){    //    printf(&quot;%lf\n&quot;,f[i+1]);    //}    //while(1);    sort(f,f+m,cmp&lt;double&gt;);    double ans=0;    for(int i=0;i&lt;m;i++){        ans+=f[i]*(i+1);    }    printf(&quot;%.3lf&quot;,ans);    //while(1);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/06/21/20/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 1778 [Usaco2010 Hol] Dotp 驱逐猪猡 高斯消元 概率期望</title>
      <link>https://blog.wildrage.xyz/2017/06/19/19/</link>
      <guid>https://blog.wildrage.xyz/2017/06/19/19/</guid>
      <pubDate>Mon, 19 Jun 2017 09:12:36 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;奶牛们建立了一个随机化的臭气炸弹来驱逐猪猡。猪猡的文明包含1到N (2 &amp;lt;= N &amp;lt;= 300)一共N个猪城。这些城市由M (1 &amp;lt;= M &amp;lt;= 44,850)条由两个不同端点A_j和B_j (1 &amp;lt;= A_j&amp;lt;= N; 1 &amp;lt;= B_j &amp;lt;= N)表示的双向道路连接。保证城市1至少连接一个其它的城市。一开始臭气弹会被放在城市1。每个小时（包括第一个小时），它有P/Q (1 &amp;lt;= P &amp;lt;=1,000,000; 1 &amp;lt;= Q &amp;lt;= 1,000,000)的概率污染它所在的城市。如果这个小时内它没有污染它所在的城市，那麽它随机地选择一条道路，在这个小时内沿着这条道路走到一个新的城市。可以离开这个城市的所有道路被选择的概率均等。因为这个臭气弹的随机的性质，&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>奶牛们建立了一个随机化的臭气炸弹来驱逐猪猡。猪猡的文明包含1到N (2 &lt;= N &lt;= 300)一共N个猪城。这些城市由M (1 &lt;= M &lt;= 44,850)条由两个不同端点A_j和B_j (1 &lt;= A_j&lt;= N; 1 &lt;= B_j &lt;= N)表示的双向道路连接。保证城市1至少连接一个其它的城市。一开始臭气弹会被放在城市1。每个小时（包括第一个小时），它有P/Q (1 &lt;= P &lt;=1,000,000; 1 &lt;= Q &lt;= 1,000,000)的概率污染它所在的城市。如果这个小时内它没有污染它所在的城市，那麽它随机地选择一条道路，在这个小时内沿着这条道路走到一个新的城市。可以离开这个城市的所有道路被选择的概率均等。因为这个臭气弹的随机的性质，<br><a id="more"></a><br>奶牛们很困惑哪个城市最有可能被污染。给定一个猪猡文明的地图和臭气弹在每个小时内爆炸的概率。计算每个城市最终被污染的概率。如下例，假设这个猪猡文明有两个连接在一起的城市。臭气炸弹从城市1出发，每到一个城市，它都有1/2的概率爆炸。 1–2 可知下面这些路径是炸弹可能经过的路径（最后一个城市是臭气弹爆炸的城市）： 1: 1 2: 1-2 3: 1-2-1 4: 1-2-1-2 5: 1-2-1-2-1 … 要得到炸弹在城市1终止的概率，我们可以把上面的第1，第3，第5……条路径的概率加起来，（也就是上表奇数编号的路径）。上表中第k条路径的概率正好是(1/2)^k，也就是必须在前k-1个回合离开所在城市（每次的概率为1 - 1/2 = 1/2）并且留在最后一个城市（概率为1/2）。所以在城市1结束的概率可以表示为1/2 + (1/2)^3 + (1/2)^5 + …。当我们无限地计算把这些项一个个加起来，我们最后会恰好得到2/3，也就是我们要求的概率，大约是0.666666667。这意味着最终停留在城市2的概率为1/3，大约为0.333333333。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行: 四个由空格隔开的整数: N, M, P, 和 Q * 第2到第M+1行: 第i+1行用两个由空格隔开的整数A_j和B_j表示一条道路。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>第1到第N行: 在第i行，用一个浮点数输出城市i被摧毁的概率。误差不超过10^-6的答桉会 被接受（注意这就是说你需要至少输出6位有效数字使得答桉有效）。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>2 1 1 2<br>1 2  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>0.666666667<br>0.333333333  </p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>既可以从概率的方向思考<br>也可以从期望的角度考虑  </p><h4 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h4><pre><code class="c++">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int mp[305][305],du[305],n;long double a[305][305],x[305],sum;void gauss(){    int im,num=1;    for(int k=1;k&lt;=n;k++,num++){        im=k;        for(int i=k+1;i&lt;=n;i++){            if(fabs(a[i][k])&gt;fabs(a[im][k]))                im=i;        }        if(im!=k){            for(int i=k;i&lt;=n+1;i++)                swap(a[num][i],a[im][i]);        }        if(!a[num][k]){            num--;continue;        }        for(int i=num+1;i&lt;=n;i++){            if(!a[num][k])continue;            long double t=a[i][k]/a[num][k];            for(int j=k;j&lt;=n+1;j++){                a[i][j]-=t*a[k][j];            }        }    }    for(int i=n;i&gt;=1;i--){        for(int j=n;j&gt;=i+1;j--){            a[i][n+1]-=a[i][j]*x[j];        }        x[i]=a[i][n+1]/a[i][i];        sum+=x[i];    }}int main(){    freopen(&quot;dotp.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;dotp.out&quot;,&quot;w&quot;,stdout);    int m,p,q,s,e;    scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;p,&amp;q);    for(int i=1;i&lt;=m;i++){        scanf(&quot;%d%d&quot;,&amp;s,&amp;e);        mp[s][e]++;mp[e][s]++;        du[s]++;du[e]++;    }    a[1][n+1]=1;    for(int i=1;i&lt;=n;i++){        a[i][i]=1;        for(int j=1;j&lt;=n;j++){            if(mp[i][j]){                a[i][j]+=((long double)p/q-1)/du[j]*mp[i][j];            }        }    }    gauss();    for(int i=1;i&lt;=n;i++){        printf(&quot;%.9lf\n&quot;,(double)(x[i]/sum));    }    //while(1);}</code></pre><h4 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h4><pre><code class="c++">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int mp[305][305],du[305],n;long double a[305][305],x[305];void gauss(){    int im,num=1;    for(int k=1;k&lt;=n;k++,num++){        im=k;        for(int i=k+1;i&lt;=n;i++){            if(fabs(a[i][k])&gt;fabs(a[im][k]))                im=i;        }        if(im!=k){            for(int i=k;i&lt;=n+1;i++)                swap(a[num][i],a[im][i]);        }        if(!a[num][k]){            num--;continue;        }        for(int i=num+1;i&lt;=n;i++){            if(!a[num][k])continue;            long double t=a[i][k]/a[num][k];            for(int j=k;j&lt;=n+1;j++){                a[i][j]-=t*a[k][j];            }        }    }    for(int i=n;i&gt;=1;i--){        for(int j=n;j&gt;=i+1;j--){            a[i][n+1]-=a[i][j]*x[j];        }        x[i]=a[i][n+1]/a[i][i];    }}int main(){    freopen(&quot;dotp.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;dotp.out&quot;,&quot;w&quot;,stdout);    int m,p,q,s,e;    scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;p,&amp;q);    for(int i=1;i&lt;=m;i++){        scanf(&quot;%d%d&quot;,&amp;s,&amp;e);        mp[s][e]++;mp[e][s]++;        du[s]++;du[e]++;    }    a[1][n+1]=1;    for(int i=1;i&lt;=n;i++){        a[i][i]=1;        for(int j=1;j&lt;=n;j++){            if(mp[i][j]){                a[i][j]+=((long double)p/q-1)/du[j]*mp[i][j];            }        }    }    gauss();    for(int i=1;i&lt;=n;i++){        printf(&quot;%.9lf\n&quot;,(double)x[i]);    }    //while(1);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/06/19/19/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 1013 [JSOI2008]球形空间产生器sphere 高斯消元</title>
      <link>https://blog.wildrage.xyz/2017/06/19/18/</link>
      <guid>https://blog.wildrage.xyz/2017/06/19/18/</guid>
      <pubDate>Mon, 19 Jun 2017 08:28:40 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;　有一个球形空间产生器能够在n维空间中产生一个坚硬的球体。现在，你被困在了这个n维球体中，你只知道球&lt;br&gt;面上n+1个点的坐标，你需要以最快的速度确定这个n维球体的球心坐标，以便于摧毁这个球形空间产生器。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>　有一个球形空间产生器能够在n维空间中产生一个坚硬的球体。现在，你被困在了这个n维球体中，你只知道球<br>面上n+1个点的坐标，你需要以最快的速度确定这个n维球体的球心坐标，以便于摧毁这个球形空间产生器。<br><a id="more"></a> </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>　第一行是一个整数n(1&lt;=N=10)。接下来的n+1行，每行有n个实数，表示球面上一点的n维坐标。每一个实数精确到小数点<br>后6位，且其绝对值都不超过20000。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>　有且只有一行，依次给出球心的n维坐标（n个实数），两个实数之间用一个空格隔开。每个实数精确到小数点<br>后3位。数据保证有解。你的答案必须和标准输出一模一样才能够得分。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>2<br>0.0 0.0<br>-1.0 1.0<br>1.0 0.0  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>0.500 1.500  </p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>直接列方程 到每个点距离相等<br>手动化简一下 就出来了  </p><p>BZOJ 竟然不能多输出一个空格（气）  </p><pre><code class="c++">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;double c[20],a[15][15],b[15],x[15],d;int n;void gauss(){    int im,num=1;    for(int k=1;k&lt;=n;k++,num++){        im=k;        for(int i=k+1;i&lt;=n;i++)            if(fabs(a[i][k])&gt;fabs(a[im][k]))                im=i;        if(im!=k){            for(int i=k;i&lt;=n;i++)                swap(a[num][i],a[im][i]);            swap(b[num],b[im]);        }        if(!a[num][k]){num--;continue;}        for(int i=num+1;i&lt;=n;i++){            if(!a[num][k])continue;            double t=a[i][k]/a[num][k];            for(int j=k;j&lt;=n+1;j++){                a[i][j]-=t*a[k][j];            }            b[i]-=t*b[k];        }    }    for(int i=n;i&gt;=1;i--){        for(int j=n;j&gt;=i+1;j--)            b[i]-=a[i][j]*x[j];        x[i]=b[i]/a[i][i];    }}int main(){    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=n;i++)scanf(&quot;%lf&quot;,&amp;c[i]);    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=n;j++){            scanf(&quot;%lf&quot;,&amp;d);            a[i][j]=d-c[j];            b[i]+=d*d-c[j]*c[j];        }        b[i]/=2;    }    gauss();    for(int i=1;i&lt;n;i++){        printf(&quot;%.3lf &quot;,x[i]);    }    printf(&quot;%.3lf&quot;,x[n]);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/06/19/18/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[SDOI2007] 线性方程组 高斯消元模板</title>
      <link>https://blog.wildrage.xyz/2017/06/19/17/</link>
      <guid>https://blog.wildrage.xyz/2017/06/19/17/</guid>
      <pubDate>Mon, 19 Jun 2017 08:06:31 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;【问题描述】&quot;&gt;&lt;a href=&quot;#【问题描述】&quot; class=&quot;headerlink&quot; title=&quot;【问题描述】&quot;&gt;&lt;/a&gt;【问题描述】&lt;/h3&gt;&lt;p&gt;已知 n 元线性一次方程组。&lt;br&gt;$$ a_{1,1}x_1+a_{1,2}x_2+…+a_{1,n}x_n=b_1 $$&lt;br&gt;$$ a_{2,1}x_1+a_{2,2}x_2+…+a_{2,n}x_n=b_2 $$&lt;br&gt;$$…………$$&lt;br&gt;$$ a_{n,1}x_1+a_{n,2}x_2+…+a_{n,n}x_n=b_n $$&lt;br&gt;其中： n&amp;lt;=50．系数是整数，绝对值&amp;lt;=100 , bi的值都是正整数且&amp;lt;300。&lt;br&gt;编程任务：&lt;br&gt;根据输入的数据，编程输出方程组的解的情况。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="【问题描述】"><a href="#【问题描述】" class="headerlink" title="【问题描述】"></a>【问题描述】</h3><p>已知 n 元线性一次方程组。<br>$$ a_{1,1}x_1+a_{1,2}x_2+…+a_{1,n}x_n=b_1 $$<br>$$ a_{2,1}x_1+a_{2,2}x_2+…+a_{2,n}x_n=b_2 $$<br>$$…………$$<br>$$ a_{n,1}x_1+a_{n,2}x_2+…+a_{n,n}x_n=b_n $$<br>其中： n&lt;=50．系数是整数，绝对值&lt;=100 , bi的值都是正整数且&lt;300。<br>编程任务：<br>根据输入的数据，编程输出方程组的解的情况。</p><a id="more"></a>   <h3 id="【输入】"><a href="#【输入】" class="headerlink" title="【输入】"></a>【输入】</h3><p>第一行，未知数的个数。以下n行n+1列：分别表示每一格方程的系数及方程右边的值。<br>$$ n $$<br>$$ a_{1,1} a_{1,2} … a_{1,n} b_1 $$<br>$$ a_{2,1} a_{2,2} … a_{2,n} b_2 $$<br>$$…………$$<br>$$ a_{n,1} a_{n,2} … a_{n,n} b_n $$</p><h3 id="【输出】"><a href="#【输出】" class="headerlink" title="【输出】"></a>【输出】</h3><p>如果方程组无实数解输出−1<br>如果有无穷多实数解，输出 0<br>如果有唯一解,则输出解（小数点后保留两位小数，如果解是0,则不保留小数）  </p><h3 id="【样例输入】"><a href="#【样例输入】" class="headerlink" title="【样例输入】"></a>【样例输入】</h3><blockquote><p>3<br>2 -1 1 1<br>4 1 -1 5<br>1 1 1 0  </p></blockquote><h3 id="【样例输出】"><a href="#【样例输出】" class="headerlink" title="【样例输出】"></a>【样例输出】</h3><blockquote><p>x1=1.00<br>x2=0<br>x3=-1.00  </p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>高斯消元板子</p><pre><code class="c++">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;int n;double a[200][200],b[200],x[200];int gauss(){    int im,num=1;    for(int k=1;k&lt;=n;k++,num++){        im=k;        for(int i=k+1;i&lt;=n;i++){            if(fabs(a[i][k])&gt;fabs(a[im][k]))                im=i;        }        if(im!=k){            for(int i=k;i&lt;=n;i++)                swap(a[num][i],a[im][i]);            swap(b[num],b[im]);        }        if(!a[num][k]) {num--;continue;}        for(int i=num+1;i&lt;=n;i++){            if(!a[num][k]) continue;            double t=a[i][k]/a[num][k];            for(int j=k;j&lt;=n+1;j++)                a[i][j]-=t*a[k][j];            b[i]-=t*b[k];        }    }    for(int i=num;i&lt;=n;i++)        if(!a[i][n]&amp;&amp;b[i])            return -1;    for(int i=n;i&gt;=1;i--){        for(int j=n;j&gt;=i+1;j--)            b[i]-=a[i][j]*x[j];        if(!a[i][i]&amp;&amp;b[i]!=0)            return -1;        if(!a[i][i]&amp;&amp;!b[i])            return 0;        x[i]=b[i]/a[i][i];    }    return 1;}int main(){    //freopen(&quot;gaess.in&quot;,&quot;r&quot;,stdin);    //freopen(&quot;gaess.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=n;j++){            scanf(&quot;%lf&quot;,&amp;a[i][j]);        }        scanf(&quot;%lf&quot;,&amp;b[i]);    }    int s=gauss();    if(s!=1)        printf(&quot;%d&quot;,s);    else {        for(int i=1;i&lt;=n;i++){            if(x[i]==0)                printf(&quot;x%d=0\n&quot;,i);            else{                printf(&quot;x%d=%.2lf\n&quot;,i,x[i]);            }        }    }    //while(1);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/06/19/17/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 2097 [Usaco2010 Dec]Exercise 奶牛健美操 题解 二分答案 树贪心 dfs</title>
      <link>https://blog.wildrage.xyz/2017/06/18/16/</link>
      <guid>https://blog.wildrage.xyz/2017/06/18/16/</guid>
      <pubDate>Sun, 18 Jun 2017 09:14:36 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;Farmer John为了保持奶牛们的健康，让可怜的奶牛们不停在牧场之间 的小路上奔跑。这些奶牛的路径集合可以被表示成一个点集和一些连接 两个顶点的双向路，使得每对点之间恰好有一条简单路径。简单的说来， 这些点的布局就是一棵树，且每条边等长，都为1。 对于给定的一个奶牛路径集合，精明的奶牛们会计算出任意点对路径的最大值， 我们称之为这个路径集合的直径。如果直径太大，奶牛们就会拒绝锻炼。 Farmer John把每个点标记为1..V (2 &amp;lt;= V &amp;lt;= 100,000)。为了获得更加短 的直径，他可以选择封锁一些已经存在的道路，这样就可以得到更多的路径集合， 从而减小一些路径集合的直径。 我们从一棵树开始，FJ可以选择封锁S (1 &amp;lt;= S &amp;lt;= V-1)条双向路，从而获得 S+1个路径集合。你要做的是计算出最佳的封锁方案，使得他得到的所有路径集合 直径的最大值尽可能小。 Farmer John告诉你所有V-1条双向道路，每条表述为：顶点A_i (1 &amp;lt;= A_i &amp;lt;= V) 和 B_i (1 &amp;lt;= B_i &amp;lt;= V; A_i!= B_i)连接。 我们来看看如下的例子：线性的路径集合(7个顶点的树) 1—2—3—4—5—6—7 如果FJ可以封锁两条道路，他可能的选择如下： 1—2 | 3—4 | 5—6—7 这样最长的直径是2，即是最优答案(当然不是唯一的)。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Farmer John为了保持奶牛们的健康，让可怜的奶牛们不停在牧场之间 的小路上奔跑。这些奶牛的路径集合可以被表示成一个点集和一些连接 两个顶点的双向路，使得每对点之间恰好有一条简单路径。简单的说来， 这些点的布局就是一棵树，且每条边等长，都为1。 对于给定的一个奶牛路径集合，精明的奶牛们会计算出任意点对路径的最大值， 我们称之为这个路径集合的直径。如果直径太大，奶牛们就会拒绝锻炼。 Farmer John把每个点标记为1..V (2 &lt;= V &lt;= 100,000)。为了获得更加短 的直径，他可以选择封锁一些已经存在的道路，这样就可以得到更多的路径集合， 从而减小一些路径集合的直径。 我们从一棵树开始，FJ可以选择封锁S (1 &lt;= S &lt;= V-1)条双向路，从而获得 S+1个路径集合。你要做的是计算出最佳的封锁方案，使得他得到的所有路径集合 直径的最大值尽可能小。 Farmer John告诉你所有V-1条双向道路，每条表述为：顶点A_i (1 &lt;= A_i &lt;= V) 和 B_i (1 &lt;= B_i &lt;= V; A_i!= B_i)连接。 我们来看看如下的例子：线性的路径集合(7个顶点的树) 1—2—3—4—5—6—7 如果FJ可以封锁两条道路，他可能的选择如下： 1—2 | 3—4 | 5—6—7 这样最长的直径是2，即是最优答案(当然不是唯一的)。<br><a id="more"></a> </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p> 第1行： 两个空格分隔的整数V和S * 第2…V行： 两个空格分隔的整数A_i和B_i</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>第1行：一个整数，表示FJ可以获得的最大的直径。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>7 2<br>6 7<br>3 4<br>6 5<br>1 2<br>3 2<br>4 5  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>2</p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>二分答案<br>贪心验证<br>每次dfs时将子节点到他的dis记录一直删边直到小于mid</p><pre><code class="c++">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int son[100005],mid;struct edge{    int END,next;}v[200005];int first[100005],p,f[100005],q[100005],tot;void add(int a,int b){    v[p].END=b;v[p].next=first[a];first[a]=p++;    v[p].END=a;v[p].next=first[b];first[b]=p++;}int cmp(const int a,const int b){    return b&lt;a;}void dfs(int rt,int fa){    f[rt]=0;    for(int i=first[rt];i!=-1;i=v[i].next)        if(v[i].END!=fa) dfs(v[i].END,rt);    int cnt=0;q[0]=0;    for(int i=first[rt];i!=-1;i=v[i].next)        if(v[i].END!=fa) q[++cnt]=f[v[i].END]+1;    sort(q+1,q+cnt+1,cmp);    if(!cnt) return;    if(cnt==1){        if(q[1]&gt;mid){            tot++;            return;        }        else {f[rt]=q[1];return;}    }    int i=2;    while(q[i-1]+q[i]&gt;mid&amp;&amp;i&lt;=cnt){        tot++;        i++;    }    if(i==cnt+1&amp;&amp;q[i-1]&gt;mid)tot++;    f[rt]=q[i-1];}int main(){    memset(first,-1,sizeof(first));    int n,m;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    int a,b;    for(int i=1;i&lt;n;i++){        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        add(a,b);    }    //int ans=0;    int l=1,r=n;    while(l&lt;r){        mid=l+r&gt;&gt;1;tot=0;        dfs(1,0);        if(tot&lt;=m)r=mid;        else l=mid+1;    }    printf(&quot;%d&quot;,l);    //while(1);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/06/18/16/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 3507 [Cqoi2014]通配符匹配 hash 题解</title>
      <link>https://blog.wildrage.xyz/2017/06/18/15/</link>
      <guid>https://blog.wildrage.xyz/2017/06/18/15/</guid>
      <pubDate>Sun, 18 Jun 2017 08:21:32 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;几乎所有操作系统的命令行界面(CLI)中都支持文件名的通配符匹配以方便用户。最常见的通配符有两个，一个&lt;br&gt;是星号(“”’)，可以匹配0个及以上的任意字符：另一个是问号(“？”)，可以匹配恰好一个任意字符。&lt;br&gt;现在需要你编写一个程序，对于给定的文件名列表和一个包含通配符的字符串，判断哪些文件可以被匹配。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>几乎所有操作系统的命令行界面(CLI)中都支持文件名的通配符匹配以方便用户。最常见的通配符有两个，一个<br>是星号(“”’)，可以匹配0个及以上的任意字符：另一个是问号(“？”)，可以匹配恰好一个任意字符。<br>现在需要你编写一个程序，对于给定的文件名列表和一个包含通配符的字符串，判断哪些文件可以被匹配。<br><a id="more"></a> </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行是一个由小写字母和上述通配符组成的字符串。<br>第二行包含一个整数n，表示文件个数。<br>接下来n行，每行为一个仅包含小写字母字符串，表示文件名列表。  </p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出n行，每行为“YES”或“NO”，表示对应文件能否被通配符匹配。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>*aca?ctc<br>6<br>acaacatctc<br>acatctc<br>aacacatctc<br>aggggcaacacctc<br>aggggcaacatctc<br>aggggcaacctct  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>YES<br>YES<br>YES<br>YES<br>YES<br>NO  </p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>将原字符串由’*’分成若干段<br>记录每一个’?’的位置<br>分段hash<br>将文件首尾先匹配然后在中间贪心的匹配</p><pre><code class="c++">/* * @Author: WildRage  * @Date: 2017-06-17 10:45:09  * @Last Modified by: WildRage * @Last Modified time: 2017-06-17 11:09:39 */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;stack&gt;using namespace std;#define ULL unsigned long longconst ULL base=31; ULL pw[100005],f[15][15],HASH[100005];int pos[15],cnt,num[15],s[15][15],n,lenth;char S[100005],a[100005];ULL get_hash(int l,int r){    return HASH[r]-HASH[l-1]*pw[r-l+1];}bool OK(int i,int k){    for(int j=0;j&lt;=num[k];j++){        if(s[k][j]==0){i++;continue;}        if(f[k][j]!=get_hash(i,i+s[k][j]-1))return 0;        i+=s[k][j]+1;    }    return 1;}bool work(char *b){    int len=strlen(b+1);    if(!cnt){        if(lenth!=len)return 0;        for(int i=1;i&lt;=lenth;i++)            if(S[i]!=b[i]&amp;&amp;S[i]!=&#39;?&#39;)return 0;        return 1;    }    if(len&lt;(pos[1]-1)+(lenth-pos[cnt]))return 0;    for(int i=1;i&lt;pos[1];i++)if(S[i]!=b[i]&amp;&amp;S[i]!=&#39;?&#39;)return 0;    for(int i=lenth,j=len;i&gt;pos[cnt];i--,j--)        if(S[i]!=b[j]&amp;&amp;S[i]!=&#39;?&#39;)return 0;    for(int i=1;i&lt;=len;i++) HASH[i]=HASH[i-1]*base+b[i];    int MAX=len-(lenth-pos[cnt])+1;    int i=pos[1];    for(int k=2;k&lt;=cnt;k++){        while(i&lt;=MAX){            if(OK(i,k))break;            i++;        }        i+=pos[k]-pos[k-1]-1;        if(i&gt;MAX) return 0;    }    return 1;}int main(){    //freopen(&quot;match.in&quot;,&quot;r&quot;,stdin);    //freopen(&quot;match.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%s&quot;,S+1);    lenth=strlen(S+1);    pw[0]=1;    cnt=0;    for(int i=1;i&lt;=100000;i++)pw[i]=pw[i-1]*base;    for(int i=1;i&lt;=lenth;i++)        if(S[i]==&#39;*&#39;)             pos[++cnt]=i;    for(int i=2;i&lt;=cnt;i++){        num[i]=0;        for(int j=pos[i-1]+1;j&lt;pos[i];j++){            if(S[j]==&#39;?&#39;){                num[i]++;                continue;            }            s[i][num[i]]++;            f[i][num[i]]=f[i][num[i]]*base+S[j];        }    }    scanf(&quot;%d&quot;,&amp;n);    while(n--){        scanf(&quot;%s&quot;,a+1);        if(work(a))puts(&quot;YES&quot;);        else puts(&quot;NO&quot;);    }    //while(1);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/06/18/15/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 4027 [HEOI2015]兔子与樱花 贪心 dfs</title>
      <link>https://blog.wildrage.xyz/2017/06/17/14/</link>
      <guid>https://blog.wildrage.xyz/2017/06/17/14/</guid>
      <pubDate>Sat, 17 Jun 2017 02:10:22 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;很久很久之前，森林里住着一群兔子。有一天，兔子们突然决定要去看樱花。兔子们所在森林里的樱花树很特殊。樱花树由n个树枝分叉点组成，编号从0到n-1，这n个分叉点由n-1个树枝连接，我们可以把它看成一个有根树结构，其中0号节点是根节点。这个树的每个节点上都会有一些樱花，其中第i个节点有c_i朵樱花。樱花树的每一个节点都有最大的载重m，对于每一个节点i，它的儿子节点的个数和i节点上樱花个数之和不能超过m，即son(i) + c_i &amp;lt;= m，其中son(i)表示i的儿子的个数，如果i为叶子节点，则son(i) = 0&lt;br&gt;现在兔子们觉得樱花树上节点太多，希望去掉一些节点。当一个节点被去掉之后，这个节点上的樱花和它的儿子节点都被连到删掉节点的父节点上。如果父节点也被删除，那么就会继续向上连接，直到第一个没有被删除的节点为止。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>很久很久之前，森林里住着一群兔子。有一天，兔子们突然决定要去看樱花。兔子们所在森林里的樱花树很特殊。樱花树由n个树枝分叉点组成，编号从0到n-1，这n个分叉点由n-1个树枝连接，我们可以把它看成一个有根树结构，其中0号节点是根节点。这个树的每个节点上都会有一些樱花，其中第i个节点有c_i朵樱花。樱花树的每一个节点都有最大的载重m，对于每一个节点i，它的儿子节点的个数和i节点上樱花个数之和不能超过m，即son(i) + c_i &lt;= m，其中son(i)表示i的儿子的个数，如果i为叶子节点，则son(i) = 0<br>现在兔子们觉得樱花树上节点太多，希望去掉一些节点。当一个节点被去掉之后，这个节点上的樱花和它的儿子节点都被连到删掉节点的父节点上。如果父节点也被删除，那么就会继续向上连接，直到第一个没有被删除的节点为止。<br><a id="more"></a><br>现在兔子们希望计算在不违背最大载重的情况下，最多能删除多少节点。<br>注意根节点不能被删除，被删除的节点不被计入载重。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行输入两个正整数，n和m分别表示节点个数和最大载重<br>第二行n个整数c_i，表示第i个节点上的樱花个数<br>接下来n行，每行第一个数k_i表示这个节点的儿子个数，接下来k_i个整数表示这个节点儿子的编号</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一行一个整数，表示最多能删除多少节点。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>10 4<br>0 2 2 2 4 1 0 4 1 1<br>3 6 2 3<br>1 9<br>1 8<br>1 1<br>0<br>0<br>2 7 4<br>0<br>1 5<br>0  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>1  </p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>跑一遍dfs由下到上贪心就好<br>选最小的</p><pre><code class="c++">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;vector&lt;int&gt; ch[2000005];struct Tree{    int v;}tree[2000005];int m,ans;int cmp(const int a,const int b){    return tree[a].v&lt;tree[b].v;}void dfs(int rt){    for(int i=0;i&lt;ch[rt].size();i++) dfs(ch[rt][i]);    sort(ch[rt].begin(),ch[rt].end(),cmp);    int i;    for(i=0;i&lt;ch[rt].size();i++){        if(tree[rt].v+tree[ch[rt][i]].v-1&lt;=m){            tree[rt].v+=tree[ch[rt][i]].v-1;            ans++;                    }        else break;            }}int main(){    //freopen(&quot;sakura.in&quot;,&quot;r&quot;,stdin);    //freopen(&quot;sakura.out&quot;,&quot;w&quot;,stdout);    int n,t,s;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;tree[i].v);    for(int i=0;i&lt;n;i++){        scanf(&quot;%d&quot;,&amp;t);        tree[i].v+=t;        while(t--){            scanf(&quot;%d&quot;,&amp;s);            ch[i].push_back(s);        }    }    dfs(0);    printf(&quot;%d\n&quot;,ans);    //while(1);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/06/17/14/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 4873 [Shoi2017]寿司餐厅 网络流</title>
      <link>https://blog.wildrage.xyz/2017/06/14/11/</link>
      <guid>https://blog.wildrage.xyz/2017/06/14/11/</guid>
      <pubDate>Wed, 14 Jun 2017 08:18:56 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;Kiana最近喜欢到一家非常美味的寿司餐厅用餐。每天晚上，这家餐厅都会按顺序提供n种寿司，第i种寿司有一个&lt;br&gt;代号ai和美味度di,i，不同种类的寿司有可能使用相同的代号。每种寿司的份数都是无限的，Kiana也可以无限次&lt;br&gt;取寿司来吃，但每种寿司每次只能取一份，且每次取走的寿司必须是按餐厅提供寿司的顺序连续的一段，即Kiana&lt;br&gt;可以一次取走第1,2种寿司各一份，也可以一次取走第2,3种寿司各一份，但不可以一次取走第1,3种寿司。由于餐&lt;br&gt;厅提供的寿司种类繁多，而不同种类的寿司之间相互会有影响：三文鱼寿司和鱿鱼寿司一起吃或许会很棒，但和水&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Kiana最近喜欢到一家非常美味的寿司餐厅用餐。每天晚上，这家餐厅都会按顺序提供n种寿司，第i种寿司有一个<br>代号ai和美味度di,i，不同种类的寿司有可能使用相同的代号。每种寿司的份数都是无限的，Kiana也可以无限次<br>取寿司来吃，但每种寿司每次只能取一份，且每次取走的寿司必须是按餐厅提供寿司的顺序连续的一段，即Kiana<br>可以一次取走第1,2种寿司各一份，也可以一次取走第2,3种寿司各一份，但不可以一次取走第1,3种寿司。由于餐<br>厅提供的寿司种类繁多，而不同种类的寿司之间相互会有影响：三文鱼寿司和鱿鱼寿司一起吃或许会很棒，但和水<br><a id="more"></a><br>果寿司一起吃就可能会肚子痛。因此，Kiana定义了一个综合美味度d(i,j)(i&lt;j)，表示在一次取的寿司中，如果包含<br>了餐厅提供的从第i份到第j份的所有寿司，吃掉这次取的所有寿司后将获得的额外美味度。由于取寿司需要花费一<br>些时间，所以我们认为分两次取来的寿司之间相互不会影响。注意在吃一次取的寿司时，不止一个综合美味度会被<br>累加，比如若Kiana一次取走了第1,2,3种寿司各一份，除了d(1,3)以外，d(1,2),d(2,3)也会被累加进总美味度中。神奇<br>的是，Kiana的美食评判标准是有记忆性的，无论是单种寿司的美味度，还是多种寿司组合起来的综合美味度，在<br>计入Kiana的总美味度时都只会被累加一次。比如，若Kiana某一次取走了第1,2种寿司各一份，另一次取走了第2,3<br>种寿司各一份，那么这两次取寿司的总美味度为d(1,1)+d(2,2)+d(3,3)+d(1,2)+d(2,3)，其中d(2,2)只会计算一次。奇怪的是，<br>这家寿司餐厅的收费标准很不同寻常。具体来说，如果Kiana一共吃过了c(c&gt;0)种代号为x的寿司，则她需要为这些<br>寿司付出mx^2+cx元钱，其中m是餐厅给出的一个常数。现在Kiana想知道，在这家餐厅吃寿司，自己能获得的总美<br>味度（包括所有吃掉的单种寿司的美味度和所有被累加的综合美味度）减去花费的总钱数的最大值是多少。由于她<br>不会算，所以希望由你告诉她</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含两个正整数n,m，分别表示这家餐厅提供的寿司总数和计算寿司价格中使用的常数。<br>第二行包含n个正整数，其中第k个数ak表示第k份寿司的代号。<br>接下来n行，第i行包含n-i+1个整数，其中第j个数d(i,i+j-1)表示吃掉寿司能<br>获得的相应的美味度，具体含义见问题描述。<br>N&lt;=100,Ai&lt;=1000</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出共一行包含一个正整数，表示Kiana能获得的总美味度减去花费的总钱数的最大值。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>3 1<br>2 3 2<br>5 -10 15<br>-10 15<br>15  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>12  </p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>将区间看做点<br>每个[i,j]区间只要向[i+1,j],[i,j-1]连边<br>转换为最大权闭合子图<br>现在最麻烦的是解决每个点的权值<br>将单个的点即[i,j] (i==j)每个点的美味度减去它的代号(解决cm)向 Idx[a[i]]连边 Idx[]用来限制第一次吃的额外的花费  </p><p>剩下的就和标准的最大权闭合子图一样了</p><pre><code class="c++">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;const int INF=0x7fffffff;int idIndex;int read(){    int res=0;    static char ch;int flag=1;    while((ch=getchar())&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)if(ch==&#39;-&#39;)flag=-1;res=ch-48;    while((ch=getchar())&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)res=(res&lt;&lt;1)+(res&lt;&lt;3)+ch-48;    return res*flag;}struct edge{    int END,next,cap;}v[1000005];int first[10005],p;void add(int a,int b,int c){    v[p].END=b;v[p].next=first[a];v[p].cap=c;first[a]=p++;    v[p].END=a;v[p].next=first[b];v[p].cap=0;first[b]=p++;}int a[150];int Idx[1005],id[150][150];int dis[10005],cur[10005];bool vis[10005];bool BFS(int S,int E){    memset(dis,-1,sizeof(dis));    memset(vis,0,sizeof(vis));    vis[S]=1;dis[S]=0;    queue&lt;int&gt; Q;    Q.push(S);    while(!Q.empty()){        int u=Q.front();Q.pop();        for(int i=first[u];i!=-1;i=v[i].next){            if(!vis[v[i].END]&amp;&amp;v[i].cap&gt;0){                vis[v[i].END]=1;                dis[v[i].END]=dis[u]+1;                if(v[i].END==E)return 1;                Q.push(v[i].END);            }        }    }    return 0;}int DFS(int S,int E,int a){    if(S==E||a==0)return a;    int flow=0,f;    for(int &amp;i=cur[S];i!=-1;i=v[i].next){        if(dis[v[i].END]==dis[S]+1&amp;&amp;(f=DFS(v[i].END,E,min(a,v[i].cap)))&gt;0){            v[i].cap-=f;            v[i^1].cap+=f;            a-=f;            flow+=f;            if(f==0)break;        }    }    //    if(!flow) dis[S]=-1;    return flow; }int Dinic(int S,int E){    int ans=0;    while(BFS(S,E)){        memcpy(cur,first,sizeof(first));        ans+=DFS(S,E,INF);    }    return ans;}int main(){    int n,m;    memset(first,-1,sizeof(first));    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    int S=++idIndex,T=++idIndex;    int maxn=0;    for(int i=1;i&lt;=n;i++) maxn=max(maxn,a[i]=read());    for(int i=1;i&lt;=maxn;i++){        Idx[i]=++idIndex;        add(Idx[i],T,m*i*i);    }    for(int i=1;i&lt;=n;i++)for(int j=i;j&lt;=n;j++)id[i][j]=++idIndex;    int x;    int ans=0;    for(int i=1;i&lt;=n;i++){        for(int j=i;j&lt;=n;j++){            x=read();            if(i==j)x-=a[i],add(id[i][j],Idx[a[i]],INF);            else {                if(id[i+1][j])add(id[i][j],id[i+1][j],INF);                if(id[i][j-1])add(id[i][j],id[i][j-1],INF);            }            if(x&gt;0) ans+=x,add(S,id[i][j],x);            else add(id[i][j],T,-x);        }    }    ans-=Dinic(S,T);    printf(&quot;%d\n&quot;,ans);    getchar();    getchar();    return 0;}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/06/14/11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 3172 [Tjoi2013]单词 fail tree</title>
      <link>https://blog.wildrage.xyz/2017/06/14/13/</link>
      <guid>https://blog.wildrage.xyz/2017/06/14/13/</guid>
      <pubDate>Wed, 14 Jun 2017 08:18:56 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;某人读论文，一篇论文是由许多单词组成。但他发现一个单词会在论文中出现很多次，现在想知道每个单词分别在论文中出现多少次。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>某人读论文，一篇论文是由许多单词组成。但他发现一个单词会在论文中出现很多次，现在想知道每个单词分别在论文中出现多少次。<br><a id="more"></a> </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一个一个整数N,表示有多少个单词，接下来N行每行一个单词。每个单词由小写字母组成，N&lt;=200,单词长度不超过10^6</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出N个整数，第i行的数字表示第i个单词在文章中出现了多少次。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>3<br>a<br>aa<br>aaa  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>6<br>3<br>1  </p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>fail 树<br>照着打个板子</p><pre><code class="c++">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;char S[1000005];int Index;struct Trie{    Trie *ch[26];    Trie *fail;    int id,num;    Trie(){memset(ch,0,sizeof(ch));fail=NULL;fail=0;num=0;id=++Index;}}*root,*word[220];void insert(char *s,int x){    int len=strlen(s);    Trie *now=root;    for(int i=0;i&lt;len;i++){        if(!now-&gt;ch[s[i]-&#39;a&#39;])now-&gt;ch[s[i]-&#39;a&#39;]=new Trie();        now=now-&gt;ch[s[i]-&#39;a&#39;];        now-&gt;num++;    }    word[x]=now;}struct edge{    Trie *END;edge *next;}*first[26000500];void add(Trie *a,Trie *b){    edge *k=new edge;    k-&gt;END=b;    k-&gt;next=first[a-&gt;id];    first[a-&gt;id]=k;}void get_fail(){    queue&lt;Trie*&gt; Q;    Trie *now=root,*temp;    Q.push(now);    while(!Q.empty()){        temp=Q.front();Q.pop();        for(int i=0;i&lt;26;i++){            if(temp-&gt;ch[i]){                if(temp==root){                    temp-&gt;ch[i]-&gt;fail=root;                    add(root,temp-&gt;ch[i]);                }                else{                    now=temp-&gt;fail;                    while(now&amp;&amp;now-&gt;ch[i]==NULL) now=now-&gt;fail;                    if(now==NULL)add(root,temp-&gt;ch[i]),temp-&gt;ch[i]-&gt;fail=root;                    else add(now-&gt;ch[i],temp-&gt;ch[i]),temp-&gt;ch[i]-&gt;fail=now-&gt;ch[i];                }                Q.push(temp-&gt;ch[i]);            }        }    }}void dfs(Trie *rt){    for(edge *now=first[rt-&gt;id];now;now=now-&gt;next){        dfs(now-&gt;END);        rt-&gt;num+=now-&gt;END-&gt;num;    }}int main(){    int n;    root=new Trie();    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=n;i++){        scanf(&quot;%s&quot;,S);        insert(S,i);    }    get_fail();    dfs(root);    for(int i=1;i&lt;=n;i++){        printf(&quot;%d\n&quot;,word[i]-&gt;num);    }}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/06/14/13/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 1901 Dynamic Rankings 线段树套Treap</title>
      <link>https://blog.wildrage.xyz/2017/06/14/12/</link>
      <guid>https://blog.wildrage.xyz/2017/06/14/12/</guid>
      <pubDate>Wed, 14 Jun 2017 08:18:56 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;给定一个含有n个数的序列a[1],a[2],a[3]……a[n]，程序必须回答这样的询问：对于给定的i,j,k，在a[i],a[i+1],a[i+2]……a[j]中第k小的数是多少(1≤k≤j-i+1)，并且，你可以改变一些a[i]的值，改变后，程序还能针对改变后的a继续回答上面的问题。你需要编一个这样的程序，从输入文件中读入序列a，然后读入一系列的指令，包括询问指令和修改指令。对于每一个询问指令，你必须输出正确的回答。 第一行有两个正整数n(1≤n≤10000)，m(1≤m≤10000)。分别表示序列的长度和指令的个数。第二行有n个数，表示a[1],a[2]……a[n]，这些数都小于10^9。接下来的m行描述每条指令，每行的格式是下面两种格式中的一种。 Q i j k 或者 C i t Q i j k （i,j,k是数字，1≤i≤j≤n, 1≤k≤j-i+1）表示询问指令，询问a[i]，a[i+1]……a[j]中第k小的数。C i t (1≤i≤n，0≤t≤10^9)表示把a[i]改变成为t。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给定一个含有n个数的序列a[1],a[2],a[3]……a[n]，程序必须回答这样的询问：对于给定的i,j,k，在a[i],a[i+1],a[i+2]……a[j]中第k小的数是多少(1≤k≤j-i+1)，并且，你可以改变一些a[i]的值，改变后，程序还能针对改变后的a继续回答上面的问题。你需要编一个这样的程序，从输入文件中读入序列a，然后读入一系列的指令，包括询问指令和修改指令。对于每一个询问指令，你必须输出正确的回答。 第一行有两个正整数n(1≤n≤10000)，m(1≤m≤10000)。分别表示序列的长度和指令的个数。第二行有n个数，表示a[1],a[2]……a[n]，这些数都小于10^9。接下来的m行描述每条指令，每行的格式是下面两种格式中的一种。 Q i j k 或者 C i t Q i j k （i,j,k是数字，1≤i≤j≤n, 1≤k≤j-i+1）表示询问指令，询问a[i]，a[i+1]……a[j]中第k小的数。C i t (1≤i≤n，0≤t≤10^9)表示把a[i]改变成为t。<br><a id="more"></a> </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>对于每一次询问，你都需要输出他的答案，每一个输出占单独的一行。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>5 3<br>3 2 1 4 7<br>Q 1 4 3<br>C 2 6<br>Q 2 5 3  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>3<br>6  </p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>区间k大+修改<br>直接树套树</p><pre><code class="c++">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int a[10005],n;class Treap{    class Node{    public:        int size,v,key;        Node *ch[2];        Node(int x){            key=rand();v=x;size=1;            ch[0]=ch[1]=NULL;        }        #define size(_) ((_)?(_)-&gt;size:0)        void Pushup(){            size=size(ch[0])+size(ch[1])+1;        }    }*root;    Node *Merge(Node *A,Node *B){        if(!A)return B;        if(!B)return A;        if(A-&gt;key&gt;B-&gt;key){            A-&gt;ch[1]=Merge(A-&gt;ch[1],B);            A-&gt;Pushup();            return A;        }        else {            B-&gt;ch[0]=Merge(A,B-&gt;ch[0]);            B-&gt;Pushup();            return B;        }    }    typedef pair&lt;Node*,Node*&gt; DNode;    DNode Split(Node *rt,int k){        if(!rt)return DNode(NULL,NULL);        DNode o;        if(size(rt-&gt;ch[0])&gt;=k){            o=Split(rt-&gt;ch[0],k);            rt-&gt;ch[0]=o.second;            rt-&gt;Pushup();            o.second=rt;        }        else{            o=Split(rt-&gt;ch[1],k-size(rt-&gt;ch[0])-1);            rt-&gt;ch[1]=o.first;            rt-&gt;Pushup();            o.first=rt;        }        return o;    }public:    Treap(){        root=NULL;    }    int kth(int k){        DNode x=Split(root,k-1);        DNode y=Split(x.second,1);        Node *ans=y.first;        root=Merge(x.first,Merge(y.first,y.second));        return ans-&gt;v;    }    int rank(int x){        return rank(root,x);    }    int rank(Node *rt,int x){        if(!rt)return 0;        return x&lt;=rt-&gt;v?rank(rt-&gt;ch[0],x):rank(rt-&gt;ch[1],x)+size(rt-&gt;ch[0])+1;    }    void Insert(int x){        int k=rank(root,x);        DNode y=Split(root,k);        Node *n=new Node(x);        root=Merge(Merge(y.first,n),y.second);    }    void remove(int x){        int k=rank(root,x);        DNode a=Split(root,k);        DNode b=Split(a.second,1);        root=Merge(a.first,b.second);    }}root[40000];#define lch l,m,rt&lt;&lt;1#define rch m+1,r,rt&lt;&lt;1|1 void build(int l,int r,int rt){    for(int i=l;i&lt;=r;i++) root[rt].Insert(a[i]);}void buildtree(int l,int r,int rt){    build(l,r,rt);    if(l==r)return;    int m=l+r&gt;&gt;1;    buildtree(lch);    buildtree(rch);}void updata(int k,int x,int y,int l,int r,int rt){    root[rt].remove(y);    root[rt].Insert(x);    if(l==r)return;    int m=l+r&gt;&gt;1;    if(k&lt;=m) updata(k,x,y,lch);    else updata(k,x,y,rch);}int rank(int L,int R,int x,int l,int r,int rt){    if(L&lt;=l&amp;&amp;R&gt;=r)return root[rt].rank(x);    int m=l+r&gt;&gt;1;    if(R&lt;=m)return rank(L,R,x,lch);    if(L&gt;m) return rank(L,R,x,rch);    return rank(L,R,x,lch)+rank(L,R,x,rch);}int kth(int L,int R,int k){    int l=-1e10,r=1e10;    while(l&lt;=r){        int m=l+r&gt;&gt;1;        int num=rank(L,R,m,1,n,1)+1;        if(num&lt;=k)l=m+1;        else r=m-1;    }    return r;}int main(){       int m;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]);    buildtree(1,n,1);    char s[5];int i,j,k,t;    while(m--){        scanf(&quot;%s&quot;,s);        if(s[0]==&#39;Q&#39;){            scanf(&quot;%d%d%d&quot;,&amp;i,&amp;j,&amp;k);            printf(&quot;%d\n&quot;,kth(i,j,k));        }        else{            scanf(&quot;%d%d&quot;,&amp;i,&amp;t);            updata(i,t,a[i],1,n,1);            a[i]=t;        }    }}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/06/14/12/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 4318 OSU! 概率DP</title>
      <link>https://blog.wildrage.xyz/2017/06/14/10/</link>
      <guid>https://blog.wildrage.xyz/2017/06/14/10/</guid>
      <pubDate>Wed, 14 Jun 2017 00:22:14 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;osu 是一款群众喜闻乐见的休闲软件。&lt;br&gt;我们可以把osu的规则简化与改编成以下的样子:&lt;br&gt;一共有n次操作，每次操作只有成功与失败之分，成功对应1，失败对应0，n次操作对应为1个长度为n的01串。在这个串中连续的 X个1可以贡献X^3 的分数，这x个1不能被其他连续的1所包含（也就是极长的一串1，具体见样例解释）&lt;br&gt;现在给出n，以及每个操作的成功率，请你输出期望分数，输出四舍五入后保留1位小数。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>osu 是一款群众喜闻乐见的休闲软件。<br>我们可以把osu的规则简化与改编成以下的样子:<br>一共有n次操作，每次操作只有成功与失败之分，成功对应1，失败对应0，n次操作对应为1个长度为n的01串。在这个串中连续的 X个1可以贡献X^3 的分数，这x个1不能被其他连续的1所包含（也就是极长的一串1，具体见样例解释）<br>现在给出n，以及每个操作的成功率，请你输出期望分数，输出四舍五入后保留1位小数。<br><a id="more"></a> </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行有一个正整数n,表示操作个数。接下去n行每行有一个[0,1]之间的实数，表示每个操作的成功率。 </p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>只有一个实数，表示答案。答案四舍五入后保留1位小数。 </p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>3<br>0.5<br>0.5<br>0.5  </p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>6.0 </p></blockquote><h3 id="【样例说明】"><a href="#【样例说明】" class="headerlink" title="【样例说明】"></a>【样例说明】</h3><p>000分数为0，001分数为1，010分数为1，100分数为1，101分数为2，110分数为8，011分数为8，111分数为27，总和为48，期望为48/8=6.0<br>N&lt;=100000</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑前面以确定，第i位如果为1则贡献为 $$(x+1)^3-x^3=3*x^2+3*x+1$$<br>维护$$x^2,x$$就可以了</p><pre><code class="c++">#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;double x[100005],x2[100005],f[100005];int main(){    int n;    double a;    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=n;i++){        scanf(&quot;%lf&quot;,&amp;a);        x[i]=(x[i-1]+1)*a;        x2[i]=(x2[i-1]+2*x[i-1]+1)*a;        f[i]=f[i-1]+(3*x2[i-1]+3*x[i-1]+1)*a;    }    printf(&quot;%.1f&quot;,f[n]);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/06/14/10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BZOJ 1426 收集邮票</title>
      <link>https://blog.wildrage.xyz/2017/06/14/9/</link>
      <guid>https://blog.wildrage.xyz/2017/06/14/9/</guid>
      <pubDate>Wed, 14 Jun 2017 00:22:14 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;有n种不同的邮票，皮皮想收集所有种类的邮票。唯一的收集方法是到同学凡凡那里购买，每次只能买一张，并且买到的邮票究竟是n种邮票中的哪一种是等概率的，概率均为1/n。但是由于凡凡也很喜欢邮票，所以皮皮购买第k张邮票需要支付k元钱。 现在皮皮手中没有邮票，皮皮想知道自己得到所有种类的邮票需要花费的钱数目的期望。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>有n种不同的邮票，皮皮想收集所有种类的邮票。唯一的收集方法是到同学凡凡那里购买，每次只能买一张，并且买到的邮票究竟是n种邮票中的哪一种是等概率的，概率均为1/n。但是由于凡凡也很喜欢邮票，所以皮皮购买第k张邮票需要支付k元钱。 现在皮皮手中没有邮票，皮皮想知道自己得到所有种类的邮票需要花费的钱数目的期望。<br><a id="more"></a> </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>一行,一个数字N N&lt;=10000</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>要付出多少钱. 保留二位小数</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>3</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>21.25</p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先考虑每张邮票1元钱，f[i]为当前有i张邮票，要集齐n种邮票的期望花费.<br>$$f[i]=i/n*f[i]+(n-i)/n*f[i+1]+1$$当花费为k时<br>g[i]为当前有i张邮票,要集齐n种邮票的期望花费。<br>我们可以认为买的最后一张邮票的花费为1,倒数第k张的花费为k。<br>这样<br>$$g[i]=i/n*(g[i]+f[i]+1)+(n-i)/n*(g[i+1]+f[i+1]+1)$$化简后就可以O(n)递推了.</p><pre><code class="c++">/* * @Author: WildRage  * @Date: 2017-06-14 08:15:56  * @Last Modified by: WildRage * @Last Modified time: 2017-06-14 08:19:55 */#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;double f[10005],g[10005];int main(){    int n;    scanf(&quot;%d&quot;,&amp;n);    for(int i=n-1;i&gt;=0;i--)f[i]=f[i+1]+(double)n/(n-i);    for(int i=n-1;i&gt;=0;i--)g[i]=(double)i/(n-i)*f[i]+g[i+1]+f[i+1]+(double)n/(n-i);    printf(&quot;%.2f&quot;,g[0]);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/06/14/9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>网络流24题 太空飞行计划</title>
      <link>https://blog.wildrage.xyz/2017/06/13/8/</link>
      <guid>https://blog.wildrage.xyz/2017/06/13/8/</guid>
      <pubDate>Tue, 13 Jun 2017 23:10:14 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;【问题描述】&quot;&gt;&lt;a href=&quot;#【问题描述】&quot; class=&quot;headerlink&quot; title=&quot;【问题描述】&quot;&gt;&lt;/a&gt;【问题描述】&lt;/h3&gt;&lt;p&gt;W 教授正在为国家航天中心计划一系列的太空飞行。每次太空飞行可进行一系列商业性实验而获取利润。现已确定了一个可供选择的实验集合E={E1,E2,…,Em}，和进行这些实验需要使用的全部仪器的集合I={ I1, I2,…,In }。实验Ej 需要用到的仪器是I的子集Rj∈I。配置仪器Ik 的费用为ck 美元。实验Ej 的赞助商已同意为该实验结果支付pj 美元。W教授的任务是找出一个有效算法，确定在一次太空飞行中要进行哪些实验并因此而配置哪些仪器才能使太空飞行的净收益最大。这里净收益是指进行实验所获得的全部收入与配置仪器的全部费用的差额。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="【问题描述】"><a href="#【问题描述】" class="headerlink" title="【问题描述】"></a>【问题描述】</h3><p>W 教授正在为国家航天中心计划一系列的太空飞行。每次太空飞行可进行一系列商业性实验而获取利润。现已确定了一个可供选择的实验集合E={E1,E2,…,Em}，和进行这些实验需要使用的全部仪器的集合I={ I1, I2,…,In }。实验Ej 需要用到的仪器是I的子集Rj∈I。配置仪器Ik 的费用为ck 美元。实验Ej 的赞助商已同意为该实验结果支付pj 美元。W教授的任务是找出一个有效算法，确定在一次太空飞行中要进行哪些实验并因此而配置哪些仪器才能使太空飞行的净收益最大。这里净收益是指进行实验所获得的全部收入与配置仪器的全部费用的差额。<br><a id="more"></a> </p><h3 id="【编程任务】"><a href="#【编程任务】" class="headerlink" title="【编程任务】"></a>【编程任务】</h3><p>对于给定的实验和仪器配置情况，编程找出净收益最大的试验计划。</p><h3 id="【数据输入】"><a href="#【数据输入】" class="headerlink" title="【数据输入】"></a>【数据输入】</h3><p>第1行有2个正整数m和n(m,n &lt;= 100)。m是实验数，n是仪器数。接下来的m行，每行是一个实验的有关数据。第一个数赞助商同意支付该实验的费用；接着是该实验需要用到的若干仪器的编号。最后一行的n个数是配置每个仪器的费用。</p><h3 id="【结果输出】"><a href="#【结果输出】" class="headerlink" title="【结果输出】"></a>【结果输出】</h3><p>第1行是实验编号；第2行是仪器编号；最后一行是净收益。</p><h3 id="【输入文件示例】shuttle-in"><a href="#【输入文件示例】shuttle-in" class="headerlink" title="【输入文件示例】shuttle.in"></a>【输入文件示例】shuttle.in</h3><blockquote><p>2 3<br>10 1 2<br>25 2 3<br>5 6 7  </p></blockquote><h3 id="【输出文件示例】shuttle-out"><a href="#【输出文件示例】shuttle-out" class="headerlink" title="【输出文件示例】shuttle.out"></a>【输出文件示例】shuttle.out</h3><blockquote><p>1 2<br>1 2 3<br>17  </p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最大权闭合子图<br>很裸的题，复习一下板子</p><pre><code class="c++">/* * @Author: WildRage  * @Date: 2017-06-13 21:23:24  * @Last Modified by: WildRage * @Last Modified time: 2017-06-13 21:48:22 */#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int INF=0x7fffffff;struct edge{    int END,next,cap;}v[100005];int first[1005],p;void add(int a,int b,int c){    v[p].END=b;v[p].next=first[a];v[p].cap=c;first[a]=p++;    v[p].END=a;v[p].next=first[b];v[p].cap=0;first[b]=p++;}int cur[1005],dis[1005];bool vis[1005];bool BFS(int S,int E){    memset(vis,0,sizeof(vis));    memset(dis,-1,sizeof(dis));    queue&lt;int&gt; Q;    Q.push(S);    dis[S]=0;vis[S]=1;    while(!Q.empty()){        int u=Q.front();Q.pop();        for(int i=first[u];i!=-1;i=v[i].next){            if(!vis[v[i].END]&amp;&amp;v[i].cap&gt;0){                vis[v[i].END]=1;                dis[v[i].END]=dis[u]+1;                if(v[i].END==E)return 1;                Q.push(v[i].END);            }        }    }    return 0;}int DFS(int S,int E,int a){    if(S==E||a==0)return a;    int flow=0,f;    for(int i=first[S];i!=-1;i=v[i].next){        if(dis[S]+1==dis[v[i].END]&amp;&amp;(f=DFS(v[i].END,E,min(a,v[i].cap)))&gt;0){            v[i].cap-=f;            v[i^1].cap+=f;            flow+=f;            a-=f;        }    }    if(!flow)dis[S]=-1;    return flow;}int Dinic(int S,int E){    int ans=0;    while(BFS(S,E)){        ans+=DFS(S,E,INF);    }    //printf(&quot;%d\n&quot;,ans);    //while(1);    return ans;}int Main(){    memset(first,-1,sizeof(first));    int n,m;    freopen(&quot;shuttle.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;shuttle.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    int ans=0;    char ch;    for(int x,i=1;i&lt;=n;i++){        scanf(&quot;%d&quot;,&amp;x);ans+=x;        add(0,i,x);        while(1){            while((ch=getchar())==&#39; &#39;);            ungetc(ch,stdin);            if(ch==&#39;\n&#39;||ch==&#39;\r&#39;)break;            scanf(&quot;%d&quot;,&amp;x);            add(i,x+n,INF);        }    }    for(int x,i=1;i&lt;=m;i++){        scanf(&quot;%d&quot;,&amp;x);        add(i+n,m+n+1,x);    }    ans=ans-Dinic(0,n+m+1);    for(int i=1;i&lt;=n;i++)        if(dis[i]&gt;=0)            printf(&quot;%d &quot;,i);    puts(&quot;&quot;);    for(int i=1;i&lt;=m;i++)        if(dis[i+n]&gt;=0)            printf(&quot;%d &quot;,i);    puts(&quot;&quot;);    printf(&quot;%d\n&quot;,ans);    return 0;}int Wild=Main();int main(){;}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/06/13/8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[COGS 2248] 情书 AC自动机模板</title>
      <link>https://blog.wildrage.xyz/2017/06/13/7/</link>
      <guid>https://blog.wildrage.xyz/2017/06/13/7/</guid>
      <pubDate>Tue, 13 Jun 2017 11:45:56 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;【题目描述】&quot;&gt;&lt;a href=&quot;#【题目描述】&quot; class=&quot;headerlink&quot; title=&quot;【题目描述】&quot;&gt;&lt;/a&gt;【题目描述】&lt;/h3&gt;&lt;p&gt;John平静的生活最近有了波澜：他已经连续n天受到陌生人的情书了。小小的心中充满了憧憬，但是某些人觉得有乐子可以找，决定伪造情书。John总结出了那个陌生人写信的习惯，也就是某些关键的字符串。如果一封信中这若干个关键字符串都出现，他就认为这是那个陌生人写的，否则就是他同学的恶作剧。注意，John可能收到多封情书。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>John平静的生活最近有了波澜：他已经连续n天受到陌生人的情书了。小小的心中充满了憧憬，但是某些人觉得有乐子可以找，决定伪造情书。John总结出了那个陌生人写信的习惯，也就是某些关键的字符串。如果一封信中这若干个关键字符串都出现，他就认为这是那个陌生人写的，否则就是他同学的恶作剧。注意，John可能收到多封情书。<br><a id="more"></a> </p><h3 id="【输入格式】"><a href="#【输入格式】" class="headerlink" title="【输入格式】"></a>【输入格式】</h3><p>第一行一个整数n，表示关键字符串的个数，n&lt;=100。<br>接下来n行，每行为一个长度不超过100的字符串。<br>最后是若干段文本，每段文本以 $ 结尾。<br>由于写情书的人太疯狂，每封情书最长可以达到1350000个字符，但情书的个数不超过10。  </p><h3 id="【输出格式】"><a href="#【输出格式】" class="headerlink" title="【输出格式】"></a>【输出格式】</h3><p>对于每一段文本对应一行输出。<br>‘Yes’表示是陌生人的来信，‘No’表示不是。<br>请注意大小写。  </p><h3 id="【样例输入】"><a href="#【样例输入】" class="headerlink" title="【样例输入】"></a>【样例输入】</h3><pre><code>3ilovewzkilovewzk$lovewzk$</code></pre><h3 id="【样例输出】"><a href="#【样例输出】" class="headerlink" title="【样例输出】"></a>【样例输出】</h3><pre><code>YesNo</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>AC自动机板子<br>感谢<a href="http://www.cnblogs.com/TSHugh/" target="_blank" rel="noopener">TS_Hugh</a><br>,<br><a href="http://www.cnblogs.com/LadyLex/" target="_blank" rel="noopener">LadyLex</a>  </p><pre><code class="c++">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;vector&gt;using namespace std;char text[1350005];int n;struct Trie{    vector&lt;int&gt; Q;    Trie *ch[26],*fail;    Trie(){        Q.clear();memset(ch,0,sizeof(ch));fail=NULL;    }    void* operator new(size_t size);}*root,*C,*num,*Q[100005];void* Trie::operator new(size_t size){    if(C==num){        C=new Trie[1&lt;&lt;15];        num=C+(1&lt;&lt;15);    }    return C++;}void insert(char *s,int x){    int len=strlen(s);    Trie *now=root;    for(int i=0;i&lt;len;i++){        if(now-&gt;ch[s[i]-&#39;a&#39;]==NULL)now-&gt;ch[s[i]-&#39;a&#39;]=new Trie();        now=now-&gt;ch[s[i]-&#39;a&#39;];    }    now-&gt;Q.push_back(x);}void build(){    root-&gt;fail=NULL;    Q[0]=root;    for(int i=0,j=0;i&lt;=j;i++){        for(int l=0;l&lt;26;l++){            if(Q[i]-&gt;ch[l]){                Trie *now=Q[i]-&gt;fail;                while(now&amp;&amp;!now-&gt;ch[l])now=now-&gt;fail;                Q[i]-&gt;ch[l]-&gt;fail=now?now-&gt;ch[l]:root;                Q[++j]=Q[i]-&gt;ch[l];            }        }    }}bool read(){    char c;    int head=0;    if(cin&gt;&gt;c){        while(c!=&#39;$&#39;){            if(c==&#39;\n&#39;||c==&#39; &#39;){c=getchar();continue;}            text[head++]=c;c=getchar();        }        text[head++]=&#39;$&#39;;        return 1;    }    return 0;}bool via[105];void work(){    memset(via,0,sizeof(via));    Trie *now=root;    for(int i=0;text[i]!=&#39;$&#39;;i++){        while(now&amp;&amp;!now-&gt;ch[text[i]-&#39;a&#39;])now=now-&gt;fail;        now=now?now-&gt;ch[text[i]-&#39;a&#39;]:root;        for(Trie *i=now;i;i=i-&gt;fail){            if(!i-&gt;Q.empty()){                int l=i-&gt;Q.size();                for(int j=0;j&lt;l;j++)via[i-&gt;Q[j]]=1;            }        }    }    int ans=0;    for(int i=1;i&lt;=n;i++)if(via[i])ans++;    if(ans==n)puts(&quot;Yes&quot;);    else puts(&quot;No&quot;);}int main(){    freopen(&quot;lettera.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;lettera.out&quot;,&quot;w&quot;,stdout);    root=new Trie();    char s[1000];    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=n;i++){        scanf(&quot;%s&quot;,s);        insert(s,i);    }    build();    while(read()) work();}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/06/13/7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[BZOJ 4523][Cqoi2016]路由表 Trie树 单调栈</title>
      <link>https://blog.wildrage.xyz/2017/06/13/6/</link>
      <guid>https://blog.wildrage.xyz/2017/06/13/6/</guid>
      <pubDate>Tue, 13 Jun 2017 09:35:35 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;路由表查找是路由器在转发IP报文时的重要环节。通常路由表中的表项由目的地址、掩码、下一跳（Next Hop）地址和其他辅助信息组成。例如：&lt;br&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/06/13/593fb6d8c246d.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;当路由器收到一个IP报文时，会将报文中的目的IP地址与路由表中的表项逐条进行比较，选&lt;br&gt;择匹配且最明确的表项，将报文转发给该表项中指定的下一跳。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>路由表查找是路由器在转发IP报文时的重要环节。通常路由表中的表项由目的地址、掩码、下一跳（Next Hop）地址和其他辅助信息组成。例如：<br><img src="https://ooo.0o0.ooo/2017/06/13/593fb6d8c246d.png" alt=""><br>当路由器收到一个IP报文时，会将报文中的目的IP地址与路由表中的表项逐条进行比较，选<br>择匹配且最明确的表项，将报文转发给该表项中指定的下一跳。<br><a id="more"></a><br>匹配的过程是将报文中的目的地址和表项中的目的地址分别转为二进制串，再查看表项中的掩<br>码长度，若掩码长度为x，则将两个二进制串的前x位进行比较，如果相同则认为匹配。<br>所谓最明确是指在有多个表项匹配时，总是掩码长度最大的表项。也可以理解为匹配的二进制<br>位最多的项。<br>IP地址转为二进制串的操作是把地址中4个整数（一定在y到255的范围内）分别转为8位<br>二进制数，再顺序拼接起来，得到一个32位的二进制串。例如，192.168.1.253转为二进制串后为<br>11000000 10101000 00000001 11111101<br>我们以报文的目的地址为8.8.8.8为例，说明其在上述路由表的匹配过程。<br><img src="https://ooo.0o0.ooo/2017/06/13/593fb701c18ab.png" alt=""><br>上表将地址均转为二进制串，并用红色标记出待比较的位（由掩码长度决定）。将红色部分与<br>报文中的目的地址比较，可知0.0.0.0/1、8.8.8.0/24、8.8.8.8、32均能够匹配。路由器从中选取掩<br>码长度最长（/32）的表项8.8.8.8/32，将报文转发给其对应的下一跳地址192.168.1.253。<br>在实际的核心路由器中，路由表通常较大（现在互联网的全局路由表已经接60万条记录），<br>并且会随着新接入设备不断扩张。为了分析路由表变化对转发产生的影响，网络工程师想要知道<br>一段时间内某个IP地址的路由表项选择发生了多少次变化（变化是指由于最明确匹配等因素选择<br>了不同的表项，不考虑下一跳地址）。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行为整数M，表示共有M次操作。接下来M行，每行描述一次操作。操作有两种：<br>A D/L<br>其中.为一个IP地址，G为整数（1≤L≤32）。添加一条表项至路由表，其目的地址为  D掩码长度为L。下一跳地址由于没有用到，故省略。<br>Q D a b<br>其中D为一个IP地址，a,b为正整数（a≤b）。查询从第a次至第b次添加表项期间（含a、b），<br>目的地址D的路由表项选择发生了多少次变化。保证查询时表中至少有b个表项。<br>N&lt;=10^6数据保证不会重复添加目的地址和掩码长度都相同的表项。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>包含若干行，每行仅有一个整数，依次对应每个查询操作。</p><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4523" target="_blank" rel="noopener">题面</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>以要查询的IP建一颗Trie树在终止节点打一个时间标记<br>每次查询用单调栈维护  </p><pre><code class="c++">/* * @Author: WildRage  * @Date: 2017-06-13 17:54:04  * @Last Modified by:   WildRage  * @Last Modified time: 2017-06-13 17:54:04  */#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;struct Trie{    int T;    Trie *ch[2];    void *operator new (size_t size);}*root,*num,*C;void* Trie::operator new(size_t size){    if(C==num){        C=new Trie[1&lt;&lt;10];        memset(C,0,sizeof(Trie)*(1&lt;&lt;10));        num=C+(1&lt;&lt;10);    }    return C++;}int Index=0,cnt;void insert(char *s){    Trie *now=root;    for(int i=0;i&lt;cnt;i++){        if(now-&gt;ch[s[i]-&#39;0&#39;]==NULL)now-&gt;ch[s[i]-&#39;0&#39;]=new Trie;        now=now-&gt;ch[s[i]-&#39;0&#39;];    }    now-&gt;T=++Index;}int st[10005];int query(char *s,int l,int r){    int h=0;    Trie *now=root;    for(int i=0;i&lt;cnt;i++){        if(now-&gt;ch[s[i]-&#39;0&#39;]==NULL)break;        now=now-&gt;ch[s[i]-&#39;0&#39;];        if(!now-&gt;T)continue;        if(now-&gt;T&gt;r)continue;        if(now-&gt;T&lt;l)while(h&gt;=1)h--;        if(now-&gt;T&gt;=l&amp;&amp;now-&gt;T&lt;=r){            while(h&gt;=1&amp;&amp;now-&gt;T&lt;st[h])h--;            st[++h]=now-&gt;T;        }    }    return h;}int main(){    int m;    scanf(&quot;%d&quot;,&amp;m);    char S[2],s[105];    int a[5],b,l,r;    root=new Trie;    for(int i=1;i&lt;=m;i++){        scanf(&quot;%s&quot;,S);        if(S[0]==&#39;A&#39;){            cnt=0;            scanf(&quot;%d.%d.%d.%d/%d&quot;,&amp;a[1],&amp;a[2],&amp;a[3],&amp;a[4],&amp;b);            for(int i=1;i&lt;=4;i++){                for(int j=7;j&gt;=0;j--){                    if(cnt+1&gt;b)break;                    if((a[i]&gt;&gt;j)&amp;1)s[cnt]=&#39;1&#39;;                    else s[cnt]=&#39;0&#39;;                    cnt++;                }            }            insert(s);        }        else{            cnt=0;            scanf(&quot;%d.%d.%d.%d %d %d&quot;,&amp;a[1],&amp;a[2],&amp;a[3],&amp;a[4],&amp;l,&amp;r);            for(int i=1;i&lt;=4;i++){                for(int j=7;j&gt;=0;j--){                    if((a[i]&gt;&gt;j)&amp;1)s[cnt]=&#39;1&#39;;                    else s[cnt]=&#39;0&#39;;                    cnt++;                }            }            printf(&quot;%d\n&quot;,query(s,l,r));        }    }}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/06/13/6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[COGS 2051] 王者之剑 题解 网络流最大权闭合子图</title>
      <link>https://blog.wildrage.xyz/2017/06/13/5/</link>
      <guid>https://blog.wildrage.xyz/2017/06/13/5/</guid>
      <pubDate>Tue, 13 Jun 2017 07:35:35 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;【题目描述】&quot;&gt;&lt;a href=&quot;#【题目描述】&quot; class=&quot;headerlink&quot; title=&quot;【题目描述】&quot;&gt;&lt;/a&gt;【题目描述】&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/06/13/593fa2607488e.jpg&quot; alt=&quot;saber&quot;&gt;&lt;br&gt;这是在阿尔托利亚·潘德拉贡成为英灵前的事情，她正要去拔出石中剑成为亚瑟王，在这之前她要去收集一些宝石。&lt;br&gt;宝石排列在一个n*m的网格中，每个网格中有一块价值为v(i,j)的宝石，阿尔托利亚·潘德拉贡可以选择自己的起点。&lt;br&gt;开始时刻为0秒。以下操作，每秒按顺序执行&lt;br&gt;1.在第i秒开始的时候，阿尔托利亚·潘德拉贡在方格（x,y）上，她可以拿走（x，y）中的宝石。&lt;br&gt;2.在偶数秒，阿尔托利亚·潘德拉贡周围四格的宝石会消失&lt;br&gt;3.若阿尔托利亚·潘德拉贡第i秒开始时在方格（x，y）上，则在第i+1秒可以立即移动到（x+1，y），（x，y+1），（x-1，y）或（x，y-1）上，也可以停留在（x,y)上。&lt;br&gt;求阿尔托利亚·潘德拉贡最多可以获得多少价值的宝石&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p><img src="https://ooo.0o0.ooo/2017/06/13/593fa2607488e.jpg" alt="saber"><br>这是在阿尔托利亚·潘德拉贡成为英灵前的事情，她正要去拔出石中剑成为亚瑟王，在这之前她要去收集一些宝石。<br>宝石排列在一个n*m的网格中，每个网格中有一块价值为v(i,j)的宝石，阿尔托利亚·潘德拉贡可以选择自己的起点。<br>开始时刻为0秒。以下操作，每秒按顺序执行<br>1.在第i秒开始的时候，阿尔托利亚·潘德拉贡在方格（x,y）上，她可以拿走（x，y）中的宝石。<br>2.在偶数秒，阿尔托利亚·潘德拉贡周围四格的宝石会消失<br>3.若阿尔托利亚·潘德拉贡第i秒开始时在方格（x，y）上，则在第i+1秒可以立即移动到（x+1，y），（x，y+1），（x-1，y）或（x，y-1）上，也可以停留在（x,y)上。<br>求阿尔托利亚·潘德拉贡最多可以获得多少价值的宝石<br><a id="more"></a> </p><h3 id="【输入格式】"><a href="#【输入格式】" class="headerlink" title="【输入格式】"></a>【输入格式】</h3><p>第一行给出数字N,M代表行列数.N,M均小于等于100，宝石的价值不会超过10000.下面N行M列用于描述数字矩阵</p><h3 id="【输出格式】"><a href="#【输出格式】" class="headerlink" title="【输出格式】"></a>【输出格式】</h3><p>输出最多可以拿到多少价值宝石</p><h3 id="【样例输入】"><a href="#【样例输入】" class="headerlink" title="【样例输入】"></a>【样例输入】</h3><pre><code>2 21 22 1</code></pre><h3 id="【样例输出】"><a href="#【样例输出】" class="headerlink" title="【样例输出】"></a>【样例输出】</h3><pre><code>4</code></pre><p>与网络流24题中方格取数相同<br>最大权闭合子图<br>黑白染色<br>相邻连INF的边<br>源点向白格子连格子权值的边<br>黑格子想汇点连权值的边</p><p>跑一遍最小割也就是最大流<br>Dinic解决</p><pre><code class="c++">/* * @Author: WildRage  * @Date: 2017-06-13 16:37:09  * @Last Modified by:   WildRage  * @Last Modified time: 2017-06-13 16:37:09  */#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int INF=0x7fffffff;struct edge{    int END,cap,next;}v[500000];int first[10005],p;void add(int a,int b,int c){    v[p].END=b;v[p].next=first[a];v[p].cap=c;first[a]=p++;    v[p].END=a;v[p].next=first[b];v[p].cap=0;first[b]=p++;}int dis[10005];bool vis[10005];bool BFS(int S,int E){    memset(vis,0,sizeof(vis));    memset(dis,-1,sizeof(dis));    queue&lt;int&gt; Q;    Q.push(S);    dis[S]=0;vis[S]=1;    while(!Q.empty()){        int u=Q.front();Q.pop();        for(int i=first[u];i!=-1;i=v[i].next){            if(!vis[v[i].END]&amp;&amp;v[i].cap&gt;0){                vis[v[i].END]=1;                dis[v[i].END]=dis[u]+1;                if(v[i].END==E)return 1;                Q.push(v[i].END);            }        }    }    return 0;}int DFS(int x,int a,int E){    if(x==E||a==0)return a;    int flow=0,f;    for(int i=first[x];i!=-1;i=v[i].next){        if(dis[x]+1==dis[v[i].END]&amp;&amp;(f=DFS(v[i].END,min(a,v[i].cap),E))&gt;0){            v[i].cap-=f;            v[i^1].cap+=f;            flow+=f;            a-=f;            if(a==0)break;        }    }    if(!flow)dis[x]=-1;    return flow;}int Dinic(int S,int E){    int flow=0;    while(BFS(S,E)){        flow+=DFS(S,INF,E);    }    return flow;}int a[105][105];template&lt;class T&gt;inline void read(T &amp;res){    static char ch;T flag=1;    while((ch=getchar())&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)if(ch==&#39;-&#39;)flag=-1;res=ch-48;    while((ch=getchar())&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)res=(res&lt;&lt;1)+(res&lt;&lt;3)+ch-48;res*=flag;}int Main(){    freopen(&quot;Excalibur.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;Excalibur.out&quot;,&quot;w&quot;,stdout);    memset(first,-1,sizeof(first));    int m,n;    int sum=0;    read(m),read(n);    for(int i=1;i&lt;=m;i++)        for(int j=1;j&lt;=n;j++){            read(a[i][j]);            sum+=a[i][j];        }    for(int i=1;i&lt;=m;i++){        for(int j=1;j&lt;=n;j++){            if((i&amp;1)^(j&amp;1)){                add(0,n*(i-1)+j,a[i][j]);                if(j-1&gt;=1)add(n*(i-1)+j,n*(i-1)+j-1,INF);                if(i-1&gt;=1)add(n*(i-1)+j,n*(i-2)+j,INF);                if(i+1&lt;=m)add(n*(i-1)+j,n*(i)+j,INF);                if(j+1&lt;=n)add(n*(i-1)+j,n*(i-1)+j+1,INF);            }            else{                add(n*(i-1)+j,n*m+1,a[i][j]);            }        }    }    return printf(&quot;%d&quot;,sum-Dinic(0,m*n+1));}int A=Main();int main(){;}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/06/13/5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>图库</title>
      <link>https://blog.wildrage.xyz/2017/06/13/0/</link>
      <guid>https://blog.wildrage.xyz/2017/06/13/0/</guid>
      <pubDate>Tue, 13 Jun 2017 07:30:32 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/06/13/593f619eef17b.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/06/13/593f619e20c1e.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="https://ooo.0o0.ooo/2017/06/13/593f619eef17b.jpg" alt=""><br><img src="https://ooo.0o0.ooo/2017/06/13/593f619e20c1e.jpg" alt=""><br><a id="more"></a><br><img src="https://ooo.0o0.ooo/2017/06/13/593f6196d31e1.jpg" alt=""><br><img src="https://ooo.0o0.ooo/2017/06/13/593f61947192d.jpg" alt=""><br><img src="https://ooo.0o0.ooo/2017/06/13/593f61946edff.jpg" alt=""><br><img src="https://ooo.0o0.ooo/2017/06/13/593f61647dad8.jpg" alt=""><br><img src="https://ooo.0o0.ooo/2017/06/13/593f616459d33.jpg" alt=""><br><img src="https://ooo.0o0.ooo/2017/06/13/593f6147eecef.jpg" alt=""><br><img src="https://ooo.0o0.ooo/2017/06/13/593f619eef17b.jpg" alt=""><br><img src="https://ooo.0o0.ooo/2017/06/13/593f61637d06d.jpg" alt=""><br><img src="https://ooo.0o0.ooo/2017/06/13/593f6162d88e0.jpg" alt=""><br><img src="https://ooo.0o0.ooo/2017/06/13/593f6162a7ed8.jpg" alt=""><br><img src="https://ooo.0o0.ooo/2017/06/13/593f616230fd7.jpg" alt=""><br><img src="https://ooo.0o0.ooo/2017/06/13/593f6161eac11.jpg" alt=""><br><img src="https://ooo.0o0.ooo/2017/06/13/593f61480c26d.jpg" alt=""><br><img src="https://ooo.0o0.ooo/2017/06/13/593f6147eecef.jpg" alt=""><br><img src="https://ooo.0o0.ooo/2017/06/13/593f6147db6cd.jpg" alt=""><br><img src="https://ooo.0o0.ooo/2017/06/13/593f6147b0f6d.jpg" alt=""><br><img src="https://ooo.0o0.ooo/2017/06/13/593f6147c0379.jpg" alt="">  </p>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/06/13/0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[BZOJ 1954] The xor-longest Path Trie树 贪心</title>
      <link>https://blog.wildrage.xyz/2017/06/13/3/</link>
      <guid>https://blog.wildrage.xyz/2017/06/13/3/</guid>
      <pubDate>Tue, 13 Jun 2017 06:30:32 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/06/13/593f91a517d9c.jpg&quot; alt=&quot;题面&quot;&gt;&lt;br&gt;给定一棵n个点的带权树，求树上最长的异或和路径&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p><img src="https://ooo.0o0.ooo/2017/06/13/593f91a517d9c.jpg" alt="题面"><br>给定一棵n个点的带权树，求树上最长的异或和路径<br><a id="more"></a> </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input contains several test cases. The first line of each test case contains an integer n(1&lt;=n&lt;=100000), The following n-1 lines each contains three integers u(0 &lt;= u &lt; n),v(0 &lt;= v &lt; n),w(0 &lt;= w &lt; 2^31), which means there is an edge between node u and v of length w.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case output the xor-length of the xor-longest path.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>41 2 32 3 42 4 6</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>7</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>本题是要求树上的路径异或<br>只要先预处理出每个点到根的路径的异或值又因为异或两次会抵消所以结果一定是对的</p><p>然后将所有点的异或值都插入一块Trie二进制由高到低</p><p>枚举每一个点 贪心的在Trie树中找就可以了</p><pre><code class="c++">/* * @Author: WildRage  * @Date: 2017-06-13 10:24:04  * @Last Modified by:   WildRage  * @Last Modified time: 2017-06-13 10:24:04  */#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;struct Trie_Node{    Trie_Node *ch[27];    Trie_Node(){        memset(ch,0,sizeof(ch));    }}*root;int ans;inline void insert(char *s){    int len=strlen(s);    Trie_Node *now=root;    for(int i=0;i&lt;len;i++){        if(now-&gt;ch[s[i]-&#39;A&#39;]==NULL)            now-&gt;ch[s[i]-&#39;A&#39;]=new Trie_Node,ans++;        now=now-&gt;ch[s[i]-&#39;A&#39;];    }}int main(){    freopen(&quot;trie.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;trie.out&quot;,&quot;w&quot;,stdout);    char s[105];    root=new Trie_Node;ans++;    while(scanf(&quot;%s&quot;,s)!=EOF) insert(s);    printf(&quot;%d&quot;,ans);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/06/13/3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[NOI2000] 单词查找树</title>
      <link>https://blog.wildrage.xyz/2017/06/13/4/</link>
      <guid>https://blog.wildrage.xyz/2017/06/13/4/</guid>
      <pubDate>Tue, 13 Jun 2017 06:20:10 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;[题目描述]&quot;&gt;&lt;/a&gt;[题目描述]&lt;/h3&gt;&lt;p&gt;在进行文法分析的时候，通常需要检测一个单词是否在我们的单词列表里。为了提高查找和定位的速度，通常都要画出与单词列表所对应的单词查找树，其特点如下：&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="[题目描述]"></a>[题目描述]</h3><p>在进行文法分析的时候，通常需要检测一个单词是否在我们的单词列表里。为了提高查找和定位的速度，通常都要画出与单词列表所对应的单词查找树，其特点如下：<br><a id="more"></a> </p><ul><li>根节点不包含字母，除根节点外每一个节点都仅包含一个大写英文字母；</li><li>从根节点到某一节点，路径上经过的字母依次连起来所构成的字母序列，称为该节点对应的单词。单词列表中的每个词，都是该单词查找树某个节点所对应的单词；</li><li>在满足上述条件下，该单词查找树的节点数最少。  </li></ul><p>单词列表对应的单词查找树</p><pre><code>AAN  ASP  AS  ASC  ASCII  BAS  BASIC</code></pre><p><img src="https://ooo.0o0.ooo/2017/06/13/593f972d8be0a.gif" alt="图二">  </p><p>对一个确定的单词列表，请统计对应的单词查找树的节点数（包括根节点）</p><h3 id="输入文件"><a href="#输入文件" class="headerlink" title="[输入文件]"></a>[输入文件]</h3><p>该文件为一个单词列表，每一行仅包含一个单词和一个换行/回车符。每个单词仅由大写的英文字符组成，长度不超过63个字符。文件总长度不超过32K，至少有一行数据。</p><h3 id="输出文件"><a href="#输出文件" class="headerlink" title="[输出文件]"></a>[输出文件]</h3><p>该文件中仅包含一个整数和一个换行/回车符。该整数为单词列表对应的单词查找树的节点数。</p><h3 id="输入输出文件样例"><a href="#输入输出文件样例" class="headerlink" title="[输入输出文件样例]"></a>[输入输出文件样例]</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>AANASPASASCASCIIBASBASIC</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>13</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>裸的Trie树<br>直接套板子</p><pre><code class="c++">/* * @Author: WildRage  * @Date: 2017-06-13 10:24:04  * @Last Modified by:   WildRage  * @Last Modified time: 2017-06-13 10:24:04  */#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;struct Trie_Node{    Trie_Node *ch[27];    Trie_Node(){        memset(ch,0,sizeof(ch));    }}*root;int ans;inline void insert(char *s){    int len=strlen(s);    Trie_Node *now=root;    for(int i=0;i&lt;len;i++){        if(now-&gt;ch[s[i]-&#39;A&#39;]==NULL)            now-&gt;ch[s[i]-&#39;A&#39;]=new Trie_Node,ans++;        now=now-&gt;ch[s[i]-&#39;A&#39;];    }}int main(){    freopen(&quot;trie.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;trie.out&quot;,&quot;w&quot;,stdout);    char s[105];    root=new Trie_Node;ans++;    while(scanf(&quot;%s&quot;,s)!=EOF) insert(s);    printf(&quot;%d&quot;,ans);}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/06/13/4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>POJ 2406 Power Strings 题解 KMP 适配函数</title>
      <link>https://blog.wildrage.xyz/2017/06/13/2/</link>
      <guid>https://blog.wildrage.xyz/2017/06/13/2/</guid>
      <pubDate>Tue, 13 Jun 2017 05:50:32 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;Given two strings a and b we define a&lt;em&gt;b to be their concatenation. For example, if a = “abc” and b = “def” then a&lt;/em&gt;b = “abcdef” . If we think of concatenation as multiplication, exponentiation by a non-negative integer is defined in the normal way: a^0 = “” (the empty string) and a^(n+1) = a*(a^n) .&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given two strings a and b we define a<em>b to be their concatenation. For example, if a = “abc” and b = “def” then a</em>b = “abcdef” . If we think of concatenation as multiplication, exponentiation by a non-negative integer is defined in the normal way: a^0 = “” (the empty string) and a^(n+1) = a*(a^n) .<br><a id="more"></a> </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>Each test case is a line of input representing s, a string of printable characters. The length of s will be at least 1 and will not exceed 1 million characters. A line containing a period follows the last test case.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each s you should print the largest n such that $$s = a^n$$ for some string a.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code class="c++">abcdaaaaababab.</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code class="c++">143</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>主要考虑 KMP 中失陪函数的意义<br>因为整个串是会重复的<br>所以整个串的长度一定是串长减最后一个字符的fail的倍数  </p><pre><code class="c++">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int N=1000005;char S[N];int next[N],len;void get_next(){    next[0]=-1;next[1]=0;    for(int i=2,j=0;i&lt;=len;i++){        while(~j&amp;&amp;S[j+1]!=S[i])j=next[j];        next[i]=++j;    }}int main(){    while(1){        memset(S,0,sizeof(S));        scanf(&quot;%s&quot;,S);        len=strlen(S)-1;        if(S[0]==&#39;.&#39;)break;        get_next();        //for(int i=1;i&lt;=len;i++)printf(&quot;%d &quot;,next[i]);        //puts(&quot;&quot;);        if((len+1)%(len-next[len])==0)printf(&quot;%d\n&quot;,(len+1)/(len-next[len]));        else puts(&quot;1&quot;);    }}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/06/13/2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[POJ3461] 乌力波 MP 题解 板子</title>
      <link>https://blog.wildrage.xyz/2017/06/13/1/</link>
      <guid>https://blog.wildrage.xyz/2017/06/13/1/</guid>
      <pubDate>Tue, 13 Jun 2017 03:20:00 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;【题目描述】&quot;&gt;&lt;a href=&quot;#【题目描述】&quot; class=&quot;headerlink&quot; title=&quot;【题目描述】&quot;&gt;&lt;/a&gt;【题目描述】&lt;/h3&gt;&lt;p&gt;法国作家乔治·佩雷克(Georges Perec，1936-1982)曾经写过一本书，《敏感字母》（La disparition），全篇没有一个字母‘e’。他是乌力波小组（Oulipo Group）的一员。下面是他书中的一段话：&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>法国作家乔治·佩雷克(Georges Perec，1936-1982)曾经写过一本书，《敏感字母》（La disparition），全篇没有一个字母‘e’。他是乌力波小组（Oulipo Group）的一员。下面是他书中的一段话：<br><a id="more"></a><br>Tout avait Pair normal, mais tout s’affirmait faux. Tout avait Fair normal, d’abord, puis surgissait l’inhumain, l’affolant. Il aurait voulu savoir où s’articulait l’association qui l’unissait au roman : stir son tapis, assaillant à tout instant son imagination, l’intuition d’un tabou, la vision d’un mal obscur, d’un quoi vacant, d’un non-dit : la vision, l’avision d’un oubli commandant tout, où s’abolissait la raison : tout avait l’air normal mais…</p><p>佩雷克很可能在下面的比赛中得到高分（当然，也有可能是低分）。在这个比赛中，人们被要求针对一个主题写出甚至是意味深长的文章，并且让一个给定的“单词”出现次数尽量少。我们的任务是给评委会编写一个程序来数单词出现了几次，用以得出参赛者最终的排名。参赛者经常会写一长串废话，例如500000个连续的‘T’。并且他们不用空格。<br>因此我们想要尽快找到一个单词出现的频数，即一个给定的字符串在文章中出现了几次。更加正式地，给出字母表{‘A’,’B’,’C’,…,’Z’}和两个仅有字母表中字母组成的有限字符串：单词W和文章T，找到W在T中出现的次数。这里“出现”意味着W中所有的连续字符都必须对应T中的连续字符。T中出现的两个W可能会部分重叠。</p><h3 id="【输入格式】"><a href="#【输入格式】" class="headerlink" title="【输入格式】"></a>【输入格式】</h3><p>输入包含多组数据。<br>输入文件的第一行有一个整数，代表数据组数。接下来是这些数据，以如下格式给出：<br>第一行是单词W，一个由{‘A’,’B’,’C’,…,’Z’}中字母组成的字符串，保证1&lt;=|W|&lt;=10000（|W|代表字符串W的长度）<br>第二行是文章T，一个由{‘A’,’B’,’C’,…,’Z’}中字母组成的字符串，保证|W|&lt;=|T|&lt;=1000000。</p><h3 id="【输出格式】"><a href="#【输出格式】" class="headerlink" title="【输出格式】"></a>【输出格式】</h3><p>对每组数据输出一行一个整数，即W在T中出现的次数。</p><h3 id="【样例输入】"><a href="#【样例输入】" class="headerlink" title="【样例输入】"></a>【样例输入】</h3><pre><code class="c++">3BAPCBAPCAZAAZAZAZAVERDIAVERDXIVYERDIAN</code></pre><h3 id="【样例输出】"><a href="#【样例输出】" class="headerlink" title="【样例输出】"></a>【样例输出】</h3><pre><code class="c++">130</code></pre><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>就是MP板子</p><pre><code class="c++">/* * @Author: WildRage  * @Date: 2017-06-12 17:26:02  * @Last Modified by: WildRage * @Last Modified time: 2017-06-12 19:01:45 */#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;char S[1000005],T[1000005];int next[1000005];int len;void get_next(char *a,int n){    int j=0,k=-1;    next[0]=-1;    while(j&lt;n){        if(k==-1||T[j]==T[k]){            next[++j]=++k;        }        else k=next[k];    }}int main(){    freopen(&quot;oulipo.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;oulipo.out&quot;,&quot;w&quot;,stdout);    int t;    scanf(&quot;%d&quot;,&amp;t);    while(t--){        int ans=0;        scanf(&quot;%s&quot;,T);scanf(&quot;%s&quot;,S);        int n=strlen(S);        int m=strlen(T);        get_next(T,m);        int i=0,j=0;        for(int i=0;i&lt;n;i++){            while(j&gt;0&amp;&amp;S[i]!=T[j]) j=next[j];            if(S[i]==T[j])j++;            if(j==m)ans++,j=next[j];        }        printf(&quot;%d\n&quot;,ans);    }}</code></pre>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/06/13/1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>网络流笔记</title>
      <link>https://blog.wildrage.xyz/2017/06/13/%E7%BD%91%E7%BB%9C%E6%B5%81/</link>
      <guid>https://blog.wildrage.xyz/2017/06/13/%E7%BD%91%E7%BB%9C%E6%B5%81/</guid>
      <pubDate>Tue, 13 Jun 2017 01:41:05 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;网络流&quot;&gt;&lt;a href=&quot;#网络流&quot; class=&quot;headerlink&quot; title=&quot;网络流&quot;&gt;&lt;/a&gt;网络流&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;是指在一个每条边都有容量（capacity）的有向图分配流，使一条边的流量不会超过它的容量。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;最大流&quot;&gt;&lt;a href=&quot;#最大流&quot; class=&quot;headerlink&quot; title=&quot;最大流&quot;&gt;&lt;/a&gt;最大流&lt;/h3&gt;&lt;h2 id=&quot;Dinic&quot;&gt;&lt;a href=&quot;#Dinic&quot; class=&quot;headerlink&quot; title=&quot;Dinic&quot;&gt;&lt;/a&gt;Dinic&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Dinic算法（又称Dinitz算法）是一个在网络流中计算最大流的强多项式复杂度的算法，设想由以色列（前苏联）的计算机科学家Yefim (Chaim) A. Dinitz在1970年提出。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><blockquote><p>是指在一个每条边都有容量（capacity）的有向图分配流，使一条边的流量不会超过它的容量。 </p></blockquote><h3 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h3><h2 id="Dinic"><a href="#Dinic" class="headerlink" title="Dinic"></a>Dinic</h2><blockquote><p>Dinic算法（又称Dinitz算法）是一个在网络流中计算最大流的强多项式复杂度的算法，设想由以色列（前苏联）的计算机科学家Yefim (Chaim) A. Dinitz在1970年提出。<br><a id="more"></a> </p></blockquote><h2 id="最大流例题"><a href="#最大流例题" class="headerlink" title="最大流例题"></a>最大流例题</h2><p>[Usaco 2007 Open] Dining吃饭 </p><blockquote><p>题意：<br>有N头牛，F种食物和D种饮料，每头牛有多种喜欢的食物和饮料，每头牛只可以吃一种食物和饮料，且每种食物和饮料都只能被一头牛吃掉。一头牛满意当且仅当它吃到满意的食物并且喝到想喝的饮料，问最多可能让多少头牛满意。   </p></blockquote><h2 id="最小割"><a href="#最小割" class="headerlink" title="最小割"></a>最小割</h2><h3 id="最大权闭合子图"><a href="#最大权闭合子图" class="headerlink" title="最大权闭合子图"></a>最大权闭合子图</h3><blockquote><p>现在有一个有向图，每个点有点权，点权可正可负。对于任意一条有向边i和j，选择了点i就必须选择点j，你需要选择一些点使得得到权值最大。 </p></blockquote><h4 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h4><pre><code>将由源点S向权值为正的点连流量为i的边，将权值为负的点向汇点连边限制关系连流量为INF的图</code></pre><h5 id="NOI2006-最大获利"><a href="#NOI2006-最大获利" class="headerlink" title="[NOI2006 最大获利]"></a>[NOI2006 最大获利]</h5><blockquote><p>建权值为Ci的一个图像Ai与Bi建图<br>转化为最大权闭合子图</p></blockquote><p>其他  </p><pre><code>二分图最大点权匹配二分图最大点权独立集</code></pre><hr><h1 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h1><ul><li>最大费用流</li><li>最小费用最大流</li></ul><h4 id="连续最短路算法"><a href="#连续最短路算法" class="headerlink" title="连续最短路算法"></a>连续最短路算法</h4><ul><li>贪心思想</li><li>从源点开始每次寻找总费用最小的增广路</li><li>直到不能增广为止</li></ul><h6 id="SDOI2009-晨跑"><a href="#SDOI2009-晨跑" class="headerlink" title="[SDOI2009]晨跑"></a>[SDOI2009]晨跑</h6><blockquote><p>Elaxia最近迷恋上了空手道，他为自己设定了一套健身计划，比如俯卧撑、仰卧起坐等 等，不过到目前为止，他坚持下来的只有晨跑。 现在给出一张学校附近的地图，这张地图中包含N个十字路口和M条街道，Elaxia只能从 一个十字路口跑向另外一个十字路口，街道之间只在十字路口处相交。Elaxia每天从寝室出发 跑到学校，保证寝室编号为1，学校编号为N。 Elaxia的晨跑计划是按周期（包含若干天）进行的，由于他不喜欢走重复的路线，所以 在一个周期内，每天的晨跑路线都不会相交（在十字路口处），寝室和学校不算十字路 口。Elaxia耐力不太好，他希望在一个周期内跑的路程尽量短，但是又希望训练周期包含的天 数尽量长。 除了练空手道，Elaxia其他时间都花在了学习和找MM上面，所有他想请你帮忙为他设计 一套满足他要求的晨跑计划。  </p></blockquote><h6 id="SDOI2007-修车"><a href="#SDOI2007-修车" class="headerlink" title="[SDOI2007]修车"></a>[SDOI2007]修车</h6><blockquote><p>同一时刻有N位车主带着他们的爱车来到了汽车维修中心。维修中心共有M位技术人员，不同的技术人员对不同的车进行维修所用的时间是不同的。现在需要安排这M位技术人员所维修的车及顺序，使得顾客平均等待的时间最小。 说明：顾客的等待时间是指从他把车送至维修中心到维修完毕所用的时间。  </p></blockquote><pre><code>将每个人拆成n个点第i个点代表这个人修的车中倒数第i辆将每辆车向这些点连边，流量为1的费用为f[i][j]*i源点连向车，工作人员向汇点连边</code></pre><h6 id="SDOI2016-数字匹配"><a href="#SDOI2016-数字匹配" class="headerlink" title="[SDOI2016]数字匹配"></a>[SDOI2016]数字匹配</h6><blockquote><p>有 n 种数字，第 i 种数字是 ai、有 bi 个，权值是 ci。<br>若两个数字 ai、aj 满足，ai 是 aj 的倍数，且 ai/aj 是一个质数，<br>那么这两个数字可以配对，并获得 ci×cj 的价值。<br>一个数字只能参与一次配对，可以不参与配对。<br>在获得的价值总和不小于 0 的前提下，求最多进行多少次配对。</p></blockquote><pre><code>以奇数和偶数因子建二分图</code></pre><h6 id="SDOI2013-费用流"><a href="#SDOI2013-费用流" class="headerlink" title="[SDOI2013]费用流"></a>[SDOI2013]费用流</h6><blockquote><p>Alice和Bob在图论课程上学习了最大流和最小费用最大流的相关知识。<br>最大流问题：给定一张有向图表示运输网络，一个源点S和一个汇点T，每条边都有最大流量。<br>一个合法的网络流方案必须满足：<br>(1)每条边的实际流量都不超过其最大流量且非负；<br>(2)除了源点S和汇点T之外，对于其余所有点，都满足该点总流入流量等于该点总流出流量；而S点的净流出流量等于T点的净流入流量，这个值也即该网络流方案的总运输量。最大流问题就是对于给定的运输网络，求总运输量最大的网络流方案。<br>上图表示了一个最大流问题。<br>对于每条边，右边的数代表该边的最大流量，左边的数代表在最优解中，该边的实际流量。需要注意到，一个最大流问题的解可能不是唯一的。    对于一张给定的运输网络，Alice先确定一个最大流，如果有多种解，Alice可以任选一种；之后Bob在每条边上分配单位花费（单位花费必须是非负实数），要求所有边的单位花费之和等于P。总费用等于每一条边的实际流量乘以该边的单位花费。需要注意到，Bob在分配单位花费之前，已经知道Alice所给出的最大流方案。现茌Alice希望总费用尽量小，而Bob希望总费用尽量大。我们想知道，如果两个人都执行最优策略，最大流的值和总费用分别为多少。</p></blockquote><h6 id="codevs-1227-方格取数2"><a href="#codevs-1227-方格取数2" class="headerlink" title="[codevs 1227]方格取数2"></a>[codevs 1227]方格取数2</h6><blockquote><p>给出一个n*n的矩阵,每一格有一个非负整数Aij,(Aij &lt;= 1000)现在从(1,1)出发,可以往右或者往下走,最后到达(n,n),每达到一格,把该格子的数取出来,该格子的数就变成0,这样一共走K次,现在要求K次所达到的方格的数的和最大</p></blockquote><h6 id="BZOJ-3438-小M的作物"><a href="#BZOJ-3438-小M的作物" class="headerlink" title="[BZOJ 3438]小M的作物"></a>[BZOJ 3438]小M的作物</h6><blockquote><p>小M在MC里开辟了两块巨大的耕地A和B（你可以认为容量是无穷），现在，小P有n中作物的种子，每种作物的种子<br>有1个（就是可以种一棵作物）（用1…n编号），现在，第i种作物种植在A中种植可以获得ai的收益，在B中种植<br>可以获得bi的收益，而且，现在还有这么一种神奇的现象，就是某些作物共同种在一块耕地中可以获得额外的收益<br>，小M找到了规则中共有m种作物组合，第i个组合中的作物共同种在A中可以获得c1i的额外收益，共同总在B中可以<br>获得c2i的额外收益，所以，小M很快的算出了种植的最大收益，但是他想要考考你，你能回答他这个问题么？</p></blockquote><h6 id="BZOJ1283-序列"><a href="#BZOJ1283-序列" class="headerlink" title="[BZOJ1283] 序列"></a>[BZOJ1283] 序列</h6><blockquote><p>给出一个长度为 的正整数序列Ci，求一个子序列，使得原序列中任意长度为M的子串中被选出的元素不超过K(K,M&lt;=100) 个，并且选出的元素之和最大。</p></blockquote><h6 id="JLOI2014-镜面通道"><a href="#JLOI2014-镜面通道" class="headerlink" title="[JLOI2014]镜面通道"></a>[JLOI2014]镜面通道</h6><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3630" target="_blank" rel="noopener">题面</a></h2>]]></content:encoded>
      
      <comments>https://blog.wildrage.xyz/2017/06/13/%E7%BD%91%E7%BB%9C%E6%B5%81/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
